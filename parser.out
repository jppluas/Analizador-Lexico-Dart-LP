Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DO
    DOT
    ENUM
    EXTENDS
    FINALLY
    GET
    IMPLEMENTS
    IN
    NULL
    RETURN
    SET
    SWITCH
    THROW
    TRY
    TYPEDEF
    ZERO

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> reassignment
Rule 11    statement -> <empty>
Rule 12    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 16    assignment -> type IDENTIFIER ASSIGN expression
Rule 17    reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 18    reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 19    reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 20    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 21    reassignment -> IDENTIFIER INLINE_ARITH
Rule 22    nullable -> QUESTION_MARK
Rule 23    modifier -> LATE
Rule 24    modifier -> FINAL
Rule 25    modifier -> CONST
Rule 26    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 27    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 28    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 29    if_statement -> if_statement ELSE if_statement
Rule 30    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 31    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 32    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 33    function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON
Rule 34    function_call -> IDENTIFIER LPAREN RPAREN
Rule 35    type -> INTEGER_TYPE
Rule 36    type -> DOUBLE_TYPE
Rule 37    type -> BOOLEAN_TYPE
Rule 38    type -> QUEUE_TYPE
Rule 39    type -> STRING_TYPE
Rule 40    type -> ENUM_TYPE
Rule 41    type -> VAR
Rule 42    type -> LIST_TYPE
Rule 43    type -> MAP_TYPE
Rule 44    type -> SET_TYPE
Rule 45    type -> DYNAMIC_TYPE
Rule 46    type -> VOID
Rule 47    expression -> arithmetic
Rule 48    expression -> concate
Rule 49    expression -> logic
Rule 50    expression -> function_call
Rule 51    expression -> division
Rule 52    arithmetic -> number
Rule 53    arithmetic -> arithmetic arith_op arithmetic
Rule 54    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 55    division -> number DIVIDE number
Rule 56    concate -> string
Rule 57    concate -> concate PLUS concate
Rule 58    concate -> LPAREN concate PLUS concate RPAREN
Rule 59    comparison -> value
Rule 60    comparison -> boolean
Rule 61    comparison -> comparison comp_op comparison
Rule 62    comparison -> LPAREN comparison comp_op comparison RPAREN
Rule 63    logic -> comparison
Rule 64    logic -> logic logic_op logic
Rule 65    logic -> LPAREN logic logic_op logic RPAREN
Rule 66    logic -> LOGICAL_NOT logic
Rule 67    logic_op -> LOGICAL_AND
Rule 68    logic_op -> LOGICAL_OR
Rule 69    arith_op -> PLUS
Rule 70    arith_op -> MINUS
Rule 71    arith_op -> TIMES
Rule 72    comp_op -> EQUAL
Rule 73    comp_op -> NOT_EQUAL
Rule 74    comp_op -> LESS
Rule 75    comp_op -> LESS_EQUAL
Rule 76    comp_op -> GREATER
Rule 77    comp_op -> GREATER_EQUAL
Rule 78    values -> value
Rule 79    values -> value COMMA values
Rule 80    value -> IDENTIFIER
Rule 81    value -> number
Rule 82    value -> string
Rule 83    value -> list
Rule 84    number -> INTEGER
Rule 85    number -> DOUBLE
Rule 86    string -> STRING
Rule 87    boolean -> TRUE
Rule 88    boolean -> FALSE
Rule 89    list -> LSQUARE RSQUARE
Rule 90    list -> LSQUARE values RSQUARE
Rule 91    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 92    lines -> line LINE_BREAK lines
Rule 93    lines -> line lines
Rule 94    lines -> line
Rule 95    lines -> LINE_BREAK
Rule 96    lines -> <empty>
Rule 97    line -> print
Rule 98    line -> assignment
Rule 99    line -> function
Rule 100   line -> if_statement
Rule 101   line -> while_statement
Rule 102   line -> for_statement
Rule 103   line -> function_call
Rule 104   line -> reassignment
Rule 105   parameters -> VOID
Rule 106   parameters -> parameter
Rule 107   parameters -> parameter COMMA parameters
Rule 108   parameters -> <empty>
Rule 109   parameter -> type IDENTIFIER
Rule 110   parameter -> IDENTIFIER
Rule 111   map -> MAP_TYPE LESS type COMMA type GREATER
Rule 112   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE values RSQUARE
Rule 113   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE RSQUARE
Rule 114   set -> SET_TYPE LESS type GREATER
Rule 115   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 116   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 117   queue -> QUEUE_TYPE LESS type GREATER
Rule 118   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 119   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 120   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 121   for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
ASSIGN               : 12 13 14 15 16 17
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 37
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 79 107 111 112 113
COMMENT              : 
CONST                : 25
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 55
DO                   : 
DOT                  : 
DOUBLE               : 85
DOUBLE_TYPE          : 36
DYNAMIC_TYPE         : 45
ELSE                 : 29 30
ENUM                 : 
ENUM_TYPE            : 40
EQUAL                : 72
EXTENDS              : 
FALSE                : 88
FINAL                : 24
FINALLY              : 
FOR                  : 121
GET                  : 
GREATER              : 76 111 112 113 114 115 116 117 118 119
GREATER_EQUAL        : 77
IDENTIFIER           : 12 13 14 15 16 17 18 19 20 21 31 32 33 34 80 91 109 110
IF                   : 28
IMPLEMENTS           : 
IN                   : 
INLINE_ARITH         : 18 19 20 21
INTEGER              : 84
INTEGER_TYPE         : 35
LATE                 : 23
LBRACE               : 9 28 30 91 120 121
LESS                 : 74 111 112 113 114 115 116 117 118 119
LESS_EQUAL           : 75
LINE_BREAK           : 92 95
LIST_TYPE            : 42
LOGICAL_AND          : 67
LOGICAL_NOT          : 66
LOGICAL_OR           : 68
LPAREN               : 26 27 28 31 32 33 34 54 58 62 65 91 120 121
LSQUARE              : 89 90 112 113 115 116 118 119
MAP_TYPE             : 43 111 112 113
MINUS                : 70
NOT_EQUAL            : 73
NULL                 : 
PLUS                 : 57 58 69
PRINT                : 26 27
QUESTION_MARK        : 22
QUEUE_TYPE           : 38 117 118 119
RBRACE               : 9 28 30 91 120 121
RETURN               : 
RPAREN               : 26 27 28 31 32 33 34 54 58 62 65 91 120 121
RSQUARE              : 89 90 112 113 115 116 118 119
SEMICOLON            : 12 13 14 15 17 18 19 26 27 31 33 121 121
SET                  : 
SET_TYPE             : 44 114 115 116
STRING               : 86
STRING_TYPE          : 39
SWITCH               : 
THROW                : 
TIMES                : 71
TRUE                 : 87
TRY                  : 
TYPEDEF              : 
VAR                  : 41
VOID                 : 46 105
WHILE                : 120
ZERO                 : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 53 54
arithmetic           : 47 53 53 54 54
assignment           : 2 98 121
boolean              : 60
comp_op              : 61 62
comparison           : 61 61 62 62 63
concate              : 48 57 57 58 58
division             : 51
expression           : 1 12 13 14 15 16 17 26
for_statement        : 7 102
function             : 4 99
function_call        : 50 103
if_statement         : 5 29 29 30 100
line                 : 92 93 94
lines                : 8 9 28 30 91 92 93 120 121
list                 : 83
logic                : 28 49 64 64 65 65 66 120 121
logic_op             : 64 65
map                  : 
modifier             : 12 14
nullable             : 12 13
number               : 18 20 52 55 55 81
parameter            : 106 107
parameters           : 91 107
print                : 3 97
queue                : 
reassignment         : 10 104 121
set                  : 
statement            : 0
string               : 56 82
type                 : 12 13 14 15 16 91 109 111 111 112 112 113 113 114 115 116 117 118 119
value                : 59 78 79
values               : 31 32 79 90 112 115 118
while_statement      : 6 101

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> . reassignment
    (11) statement -> .
    (47) expression -> . arithmetic
    (48) expression -> . concate
    (49) expression -> . logic
    (50) expression -> . function_call
    (51) expression -> . division
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (55) division -> . number DIVIDE number
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
    LBRACE          shift and go to state 10
    $end            reduce using rule 11 (statement -> .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    LINE_BREAK      shift and go to state 26
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

  ! $end            [ reduce using rule 96 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    reassignment                   shift and go to state 11
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 15
    division                       shift and go to state 16
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    line                           shift and go to state 25
    number                         shift and go to state 27
    string                         shift and go to state 28
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (98) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 98 (line -> assignment .)
    PRINT           reduce using rule 98 (line -> assignment .)
    IF              reduce using rule 98 (line -> assignment .)
    WHILE           reduce using rule 98 (line -> assignment .)
    FOR             reduce using rule 98 (line -> assignment .)
    IDENTIFIER      reduce using rule 98 (line -> assignment .)
    LATE            reduce using rule 98 (line -> assignment .)
    FINAL           reduce using rule 98 (line -> assignment .)
    CONST           reduce using rule 98 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 98 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 98 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 98 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 98 (line -> assignment .)
    STRING_TYPE     reduce using rule 98 (line -> assignment .)
    ENUM_TYPE       reduce using rule 98 (line -> assignment .)
    VAR             reduce using rule 98 (line -> assignment .)
    LIST_TYPE       reduce using rule 98 (line -> assignment .)
    MAP_TYPE        reduce using rule 98 (line -> assignment .)
    SET_TYPE        reduce using rule 98 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 98 (line -> assignment .)
    VOID            reduce using rule 98 (line -> assignment .)

  ! $end            [ reduce using rule 98 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (97) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 97 (line -> print .)
    PRINT           reduce using rule 97 (line -> print .)
    IF              reduce using rule 97 (line -> print .)
    WHILE           reduce using rule 97 (line -> print .)
    FOR             reduce using rule 97 (line -> print .)
    IDENTIFIER      reduce using rule 97 (line -> print .)
    LATE            reduce using rule 97 (line -> print .)
    FINAL           reduce using rule 97 (line -> print .)
    CONST           reduce using rule 97 (line -> print .)
    INTEGER_TYPE    reduce using rule 97 (line -> print .)
    DOUBLE_TYPE     reduce using rule 97 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 97 (line -> print .)
    QUEUE_TYPE      reduce using rule 97 (line -> print .)
    STRING_TYPE     reduce using rule 97 (line -> print .)
    ENUM_TYPE       reduce using rule 97 (line -> print .)
    VAR             reduce using rule 97 (line -> print .)
    LIST_TYPE       reduce using rule 97 (line -> print .)
    MAP_TYPE        reduce using rule 97 (line -> print .)
    SET_TYPE        reduce using rule 97 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 97 (line -> print .)
    VOID            reduce using rule 97 (line -> print .)

  ! $end            [ reduce using rule 97 (line -> print .) ]


state 5

    (4) statement -> function .
    (99) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 99 (line -> function .)
    PRINT           reduce using rule 99 (line -> function .)
    IF              reduce using rule 99 (line -> function .)
    WHILE           reduce using rule 99 (line -> function .)
    FOR             reduce using rule 99 (line -> function .)
    IDENTIFIER      reduce using rule 99 (line -> function .)
    LATE            reduce using rule 99 (line -> function .)
    FINAL           reduce using rule 99 (line -> function .)
    CONST           reduce using rule 99 (line -> function .)
    INTEGER_TYPE    reduce using rule 99 (line -> function .)
    DOUBLE_TYPE     reduce using rule 99 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 99 (line -> function .)
    QUEUE_TYPE      reduce using rule 99 (line -> function .)
    STRING_TYPE     reduce using rule 99 (line -> function .)
    ENUM_TYPE       reduce using rule 99 (line -> function .)
    VAR             reduce using rule 99 (line -> function .)
    LIST_TYPE       reduce using rule 99 (line -> function .)
    MAP_TYPE        reduce using rule 99 (line -> function .)
    SET_TYPE        reduce using rule 99 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 99 (line -> function .)
    VOID            reduce using rule 99 (line -> function .)

  ! $end            [ reduce using rule 99 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (29) if_statement -> if_statement . ELSE if_statement
    (30) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (100) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 55
    LINE_BREAK      reduce using rule 100 (line -> if_statement .)
    PRINT           reduce using rule 100 (line -> if_statement .)
    IF              reduce using rule 100 (line -> if_statement .)
    WHILE           reduce using rule 100 (line -> if_statement .)
    FOR             reduce using rule 100 (line -> if_statement .)
    IDENTIFIER      reduce using rule 100 (line -> if_statement .)
    LATE            reduce using rule 100 (line -> if_statement .)
    FINAL           reduce using rule 100 (line -> if_statement .)
    CONST           reduce using rule 100 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 100 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 100 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 100 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 100 (line -> if_statement .)
    STRING_TYPE     reduce using rule 100 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 100 (line -> if_statement .)
    VAR             reduce using rule 100 (line -> if_statement .)
    LIST_TYPE       reduce using rule 100 (line -> if_statement .)
    MAP_TYPE        reduce using rule 100 (line -> if_statement .)
    SET_TYPE        reduce using rule 100 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 100 (line -> if_statement .)
    VOID            reduce using rule 100 (line -> if_statement .)

  ! $end            [ reduce using rule 100 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .
    (101) line -> while_statement .

  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> while_statement .)
    $end            reduce using rule 6 (statement -> while_statement .)
    LINE_BREAK      reduce using rule 101 (line -> while_statement .)
    PRINT           reduce using rule 101 (line -> while_statement .)
    IF              reduce using rule 101 (line -> while_statement .)
    WHILE           reduce using rule 101 (line -> while_statement .)
    FOR             reduce using rule 101 (line -> while_statement .)
    IDENTIFIER      reduce using rule 101 (line -> while_statement .)
    LATE            reduce using rule 101 (line -> while_statement .)
    FINAL           reduce using rule 101 (line -> while_statement .)
    CONST           reduce using rule 101 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 101 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 101 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 101 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 101 (line -> while_statement .)
    STRING_TYPE     reduce using rule 101 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 101 (line -> while_statement .)
    VAR             reduce using rule 101 (line -> while_statement .)
    LIST_TYPE       reduce using rule 101 (line -> while_statement .)
    MAP_TYPE        reduce using rule 101 (line -> while_statement .)
    SET_TYPE        reduce using rule 101 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 101 (line -> while_statement .)
    VOID            reduce using rule 101 (line -> while_statement .)

  ! $end            [ reduce using rule 101 (line -> while_statement .) ]


state 8

    (7) statement -> for_statement .
    (102) line -> for_statement .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    LINE_BREAK      reduce using rule 102 (line -> for_statement .)
    PRINT           reduce using rule 102 (line -> for_statement .)
    IF              reduce using rule 102 (line -> for_statement .)
    WHILE           reduce using rule 102 (line -> for_statement .)
    FOR             reduce using rule 102 (line -> for_statement .)
    IDENTIFIER      reduce using rule 102 (line -> for_statement .)
    LATE            reduce using rule 102 (line -> for_statement .)
    FINAL           reduce using rule 102 (line -> for_statement .)
    CONST           reduce using rule 102 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 102 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 102 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 102 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 102 (line -> for_statement .)
    STRING_TYPE     reduce using rule 102 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 102 (line -> for_statement .)
    VAR             reduce using rule 102 (line -> for_statement .)
    LIST_TYPE       reduce using rule 102 (line -> for_statement .)
    MAP_TYPE        reduce using rule 102 (line -> for_statement .)
    SET_TYPE        reduce using rule 102 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 102 (line -> for_statement .)
    VOID            reduce using rule 102 (line -> for_statement .)

  ! $end            [ reduce using rule 102 (line -> for_statement .) ]


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 26
    RBRACE          reduce using rule 96 (lines -> .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    lines                          shift and go to state 56
    line                           shift and go to state 25
    print                          shift and go to state 57
    assignment                     shift and go to state 58
    function                       shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    reassignment                   shift and go to state 64
    modifier                       shift and go to state 17
    type                           shift and go to state 18

state 11

    (10) statement -> reassignment .
    (104) line -> reassignment .

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> reassignment .)
    $end            reduce using rule 10 (statement -> reassignment .)
    LINE_BREAK      reduce using rule 104 (line -> reassignment .)
    PRINT           reduce using rule 104 (line -> reassignment .)
    IF              reduce using rule 104 (line -> reassignment .)
    WHILE           reduce using rule 104 (line -> reassignment .)
    FOR             reduce using rule 104 (line -> reassignment .)
    IDENTIFIER      reduce using rule 104 (line -> reassignment .)
    LATE            reduce using rule 104 (line -> reassignment .)
    FINAL           reduce using rule 104 (line -> reassignment .)
    CONST           reduce using rule 104 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 104 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 104 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 104 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 104 (line -> reassignment .)
    STRING_TYPE     reduce using rule 104 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 104 (line -> reassignment .)
    VAR             reduce using rule 104 (line -> reassignment .)
    LIST_TYPE       reduce using rule 104 (line -> reassignment .)
    MAP_TYPE        reduce using rule 104 (line -> reassignment .)
    SET_TYPE        reduce using rule 104 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 104 (line -> reassignment .)
    VOID            reduce using rule 104 (line -> reassignment .)

  ! $end            [ reduce using rule 104 (line -> reassignment .) ]


state 12

    (47) expression -> arithmetic .
    (53) arithmetic -> arithmetic . arith_op arithmetic
    (69) arith_op -> . PLUS
    (70) arith_op -> . MINUS
    (71) arith_op -> . TIMES

    $end            reduce using rule 47 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 47 (expression -> arithmetic .)
    RPAREN          reduce using rule 47 (expression -> arithmetic .)
    LINE_BREAK      reduce using rule 47 (expression -> arithmetic .)
    PRINT           reduce using rule 47 (expression -> arithmetic .)
    IF              reduce using rule 47 (expression -> arithmetic .)
    WHILE           reduce using rule 47 (expression -> arithmetic .)
    FOR             reduce using rule 47 (expression -> arithmetic .)
    IDENTIFIER      reduce using rule 47 (expression -> arithmetic .)
    LATE            reduce using rule 47 (expression -> arithmetic .)
    FINAL           reduce using rule 47 (expression -> arithmetic .)
    CONST           reduce using rule 47 (expression -> arithmetic .)
    INTEGER_TYPE    reduce using rule 47 (expression -> arithmetic .)
    DOUBLE_TYPE     reduce using rule 47 (expression -> arithmetic .)
    BOOLEAN_TYPE    reduce using rule 47 (expression -> arithmetic .)
    QUEUE_TYPE      reduce using rule 47 (expression -> arithmetic .)
    STRING_TYPE     reduce using rule 47 (expression -> arithmetic .)
    ENUM_TYPE       reduce using rule 47 (expression -> arithmetic .)
    VAR             reduce using rule 47 (expression -> arithmetic .)
    LIST_TYPE       reduce using rule 47 (expression -> arithmetic .)
    MAP_TYPE        reduce using rule 47 (expression -> arithmetic .)
    SET_TYPE        reduce using rule 47 (expression -> arithmetic .)
    DYNAMIC_TYPE    reduce using rule 47 (expression -> arithmetic .)
    VOID            reduce using rule 47 (expression -> arithmetic .)
    RBRACE          reduce using rule 47 (expression -> arithmetic .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69

    arith_op                       shift and go to state 66

state 13

    (48) expression -> concate .
    (57) concate -> concate . PLUS concate

    $end            reduce using rule 48 (expression -> concate .)
    SEMICOLON       reduce using rule 48 (expression -> concate .)
    RPAREN          reduce using rule 48 (expression -> concate .)
    LINE_BREAK      reduce using rule 48 (expression -> concate .)
    PRINT           reduce using rule 48 (expression -> concate .)
    IF              reduce using rule 48 (expression -> concate .)
    WHILE           reduce using rule 48 (expression -> concate .)
    FOR             reduce using rule 48 (expression -> concate .)
    IDENTIFIER      reduce using rule 48 (expression -> concate .)
    LATE            reduce using rule 48 (expression -> concate .)
    FINAL           reduce using rule 48 (expression -> concate .)
    CONST           reduce using rule 48 (expression -> concate .)
    INTEGER_TYPE    reduce using rule 48 (expression -> concate .)
    DOUBLE_TYPE     reduce using rule 48 (expression -> concate .)
    BOOLEAN_TYPE    reduce using rule 48 (expression -> concate .)
    QUEUE_TYPE      reduce using rule 48 (expression -> concate .)
    STRING_TYPE     reduce using rule 48 (expression -> concate .)
    ENUM_TYPE       reduce using rule 48 (expression -> concate .)
    VAR             reduce using rule 48 (expression -> concate .)
    LIST_TYPE       reduce using rule 48 (expression -> concate .)
    MAP_TYPE        reduce using rule 48 (expression -> concate .)
    SET_TYPE        reduce using rule 48 (expression -> concate .)
    DYNAMIC_TYPE    reduce using rule 48 (expression -> concate .)
    VOID            reduce using rule 48 (expression -> concate .)
    RBRACE          reduce using rule 48 (expression -> concate .)
    PLUS            shift and go to state 70


state 14

    (49) expression -> logic .
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

    $end            reduce using rule 49 (expression -> logic .)
    SEMICOLON       reduce using rule 49 (expression -> logic .)
    RPAREN          reduce using rule 49 (expression -> logic .)
    LINE_BREAK      reduce using rule 49 (expression -> logic .)
    PRINT           reduce using rule 49 (expression -> logic .)
    IF              reduce using rule 49 (expression -> logic .)
    WHILE           reduce using rule 49 (expression -> logic .)
    FOR             reduce using rule 49 (expression -> logic .)
    IDENTIFIER      reduce using rule 49 (expression -> logic .)
    LATE            reduce using rule 49 (expression -> logic .)
    FINAL           reduce using rule 49 (expression -> logic .)
    CONST           reduce using rule 49 (expression -> logic .)
    INTEGER_TYPE    reduce using rule 49 (expression -> logic .)
    DOUBLE_TYPE     reduce using rule 49 (expression -> logic .)
    BOOLEAN_TYPE    reduce using rule 49 (expression -> logic .)
    QUEUE_TYPE      reduce using rule 49 (expression -> logic .)
    STRING_TYPE     reduce using rule 49 (expression -> logic .)
    ENUM_TYPE       reduce using rule 49 (expression -> logic .)
    VAR             reduce using rule 49 (expression -> logic .)
    LIST_TYPE       reduce using rule 49 (expression -> logic .)
    MAP_TYPE        reduce using rule 49 (expression -> logic .)
    SET_TYPE        reduce using rule 49 (expression -> logic .)
    DYNAMIC_TYPE    reduce using rule 49 (expression -> logic .)
    VOID            reduce using rule 49 (expression -> logic .)
    RBRACE          reduce using rule 49 (expression -> logic .)
    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

    logic_op                       shift and go to state 71

state 15

    (50) expression -> function_call .
    (103) line -> function_call .

  ! reduce/reduce conflict for $end resolved using rule 50 (expression -> function_call .)
    $end            reduce using rule 50 (expression -> function_call .)
    LINE_BREAK      reduce using rule 103 (line -> function_call .)
    PRINT           reduce using rule 103 (line -> function_call .)
    IF              reduce using rule 103 (line -> function_call .)
    WHILE           reduce using rule 103 (line -> function_call .)
    FOR             reduce using rule 103 (line -> function_call .)
    IDENTIFIER      reduce using rule 103 (line -> function_call .)
    LATE            reduce using rule 103 (line -> function_call .)
    FINAL           reduce using rule 103 (line -> function_call .)
    CONST           reduce using rule 103 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 103 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 103 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 103 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 103 (line -> function_call .)
    STRING_TYPE     reduce using rule 103 (line -> function_call .)
    ENUM_TYPE       reduce using rule 103 (line -> function_call .)
    VAR             reduce using rule 103 (line -> function_call .)
    LIST_TYPE       reduce using rule 103 (line -> function_call .)
    MAP_TYPE        reduce using rule 103 (line -> function_call .)
    SET_TYPE        reduce using rule 103 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 103 (line -> function_call .)
    VOID            reduce using rule 103 (line -> function_call .)

  ! $end            [ reduce using rule 103 (line -> function_call .) ]


state 16

    (51) expression -> division .

    $end            reduce using rule 51 (expression -> division .)
    SEMICOLON       reduce using rule 51 (expression -> division .)
    RPAREN          reduce using rule 51 (expression -> division .)
    LINE_BREAK      reduce using rule 51 (expression -> division .)
    PRINT           reduce using rule 51 (expression -> division .)
    IF              reduce using rule 51 (expression -> division .)
    WHILE           reduce using rule 51 (expression -> division .)
    FOR             reduce using rule 51 (expression -> division .)
    IDENTIFIER      reduce using rule 51 (expression -> division .)
    LATE            reduce using rule 51 (expression -> division .)
    FINAL           reduce using rule 51 (expression -> division .)
    CONST           reduce using rule 51 (expression -> division .)
    INTEGER_TYPE    reduce using rule 51 (expression -> division .)
    DOUBLE_TYPE     reduce using rule 51 (expression -> division .)
    BOOLEAN_TYPE    reduce using rule 51 (expression -> division .)
    QUEUE_TYPE      reduce using rule 51 (expression -> division .)
    STRING_TYPE     reduce using rule 51 (expression -> division .)
    ENUM_TYPE       reduce using rule 51 (expression -> division .)
    VAR             reduce using rule 51 (expression -> division .)
    LIST_TYPE       reduce using rule 51 (expression -> division .)
    MAP_TYPE        reduce using rule 51 (expression -> division .)
    SET_TYPE        reduce using rule 51 (expression -> division .)
    DYNAMIC_TYPE    reduce using rule 51 (expression -> division .)
    VOID            reduce using rule 51 (expression -> division .)
    RBRACE          reduce using rule 51 (expression -> division .)


state 17

    (12) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    type                           shift and go to state 74

state 18

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (91) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (22) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 76
    QUESTION_MARK   shift and go to state 77

    nullable                       shift and go to state 75

state 19

    (17) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (20) reassignment -> IDENTIFIER . INLINE_ARITH number
    (21) reassignment -> IDENTIFIER . INLINE_ARITH
    (31) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER . LPAREN values RPAREN
    (33) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER . LPAREN RPAREN
    (80) value -> IDENTIFIER .

    ASSIGN          shift and go to state 78
    INLINE_ARITH    shift and go to state 79
    LPAREN          shift and go to state 80
    EQUAL           reduce using rule 80 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 80 (value -> IDENTIFIER .)
    LESS            reduce using rule 80 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 80 (value -> IDENTIFIER .)
    GREATER         reduce using rule 80 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 80 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 80 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 80 (value -> IDENTIFIER .)
    $end            reduce using rule 80 (value -> IDENTIFIER .)


state 20

    (26) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (27) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 81


state 21

    (54) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (58) concate -> LPAREN . concate PLUS concate RPAREN
    (65) logic -> LPAREN . logic logic_op logic RPAREN
    (62) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

    arithmetic                     shift and go to state 82
    concate                        shift and go to state 83
    logic                          shift and go to state 84
    comparison                     shift and go to state 85
    number                         shift and go to state 86
    string                         shift and go to state 28
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 22

    (28) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 88


state 23

    (120) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 89


state 24

    (121) for_statement -> FOR . LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 90


state 25

    (92) lines -> line . LINE_BREAK lines
    (93) lines -> line . lines
    (94) lines -> line .
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 94 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 94 (lines -> line .)
    LINE_BREAK      shift and go to state 91
    $end            reduce using rule 94 (lines -> line .)
    RBRACE          reduce using rule 94 (lines -> line .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

  ! $end            [ reduce using rule 96 (lines -> .) ]
  ! RBRACE          [ reduce using rule 96 (lines -> .) ]

    line                           shift and go to state 25
    lines                          shift and go to state 92
    print                          shift and go to state 57
    assignment                     shift and go to state 58
    function                       shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    reassignment                   shift and go to state 64
    modifier                       shift and go to state 17
    type                           shift and go to state 18

state 26

    (95) lines -> LINE_BREAK .

    $end            reduce using rule 95 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 95 (lines -> LINE_BREAK .)


state 27

    (52) arithmetic -> number .
    (55) division -> number . DIVIDE number
    (81) value -> number .

  ! reduce/reduce conflict for $end resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for RPAREN resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for PRINT resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for IF resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for WHILE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for FOR resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for LATE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for FINAL resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for CONST resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for VAR resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for VOID resolved using rule 52 (arithmetic -> number .)
  ! reduce/reduce conflict for RBRACE resolved using rule 52 (arithmetic -> number .)
    PLUS            reduce using rule 52 (arithmetic -> number .)
    MINUS           reduce using rule 52 (arithmetic -> number .)
    TIMES           reduce using rule 52 (arithmetic -> number .)
    $end            reduce using rule 52 (arithmetic -> number .)
    SEMICOLON       reduce using rule 52 (arithmetic -> number .)
    RPAREN          reduce using rule 52 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 52 (arithmetic -> number .)
    PRINT           reduce using rule 52 (arithmetic -> number .)
    IF              reduce using rule 52 (arithmetic -> number .)
    WHILE           reduce using rule 52 (arithmetic -> number .)
    FOR             reduce using rule 52 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 52 (arithmetic -> number .)
    LATE            reduce using rule 52 (arithmetic -> number .)
    FINAL           reduce using rule 52 (arithmetic -> number .)
    CONST           reduce using rule 52 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 52 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 52 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 52 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 52 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 52 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 52 (arithmetic -> number .)
    VAR             reduce using rule 52 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 52 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 52 (arithmetic -> number .)
    SET_TYPE        reduce using rule 52 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 52 (arithmetic -> number .)
    VOID            reduce using rule 52 (arithmetic -> number .)
    RBRACE          reduce using rule 52 (arithmetic -> number .)
    DIVIDE          shift and go to state 93
    EQUAL           reduce using rule 81 (value -> number .)
    NOT_EQUAL       reduce using rule 81 (value -> number .)
    LESS            reduce using rule 81 (value -> number .)
    LESS_EQUAL      reduce using rule 81 (value -> number .)
    GREATER         reduce using rule 81 (value -> number .)
    GREATER_EQUAL   reduce using rule 81 (value -> number .)
    LOGICAL_AND     reduce using rule 81 (value -> number .)
    LOGICAL_OR      reduce using rule 81 (value -> number .)

  ! $end            [ reduce using rule 81 (value -> number .) ]
  ! SEMICOLON       [ reduce using rule 81 (value -> number .) ]
  ! RPAREN          [ reduce using rule 81 (value -> number .) ]
  ! LINE_BREAK      [ reduce using rule 81 (value -> number .) ]
  ! PRINT           [ reduce using rule 81 (value -> number .) ]
  ! IF              [ reduce using rule 81 (value -> number .) ]
  ! WHILE           [ reduce using rule 81 (value -> number .) ]
  ! FOR             [ reduce using rule 81 (value -> number .) ]
  ! IDENTIFIER      [ reduce using rule 81 (value -> number .) ]
  ! LATE            [ reduce using rule 81 (value -> number .) ]
  ! FINAL           [ reduce using rule 81 (value -> number .) ]
  ! CONST           [ reduce using rule 81 (value -> number .) ]
  ! INTEGER_TYPE    [ reduce using rule 81 (value -> number .) ]
  ! DOUBLE_TYPE     [ reduce using rule 81 (value -> number .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 81 (value -> number .) ]
  ! QUEUE_TYPE      [ reduce using rule 81 (value -> number .) ]
  ! STRING_TYPE     [ reduce using rule 81 (value -> number .) ]
  ! ENUM_TYPE       [ reduce using rule 81 (value -> number .) ]
  ! VAR             [ reduce using rule 81 (value -> number .) ]
  ! LIST_TYPE       [ reduce using rule 81 (value -> number .) ]
  ! MAP_TYPE        [ reduce using rule 81 (value -> number .) ]
  ! SET_TYPE        [ reduce using rule 81 (value -> number .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 81 (value -> number .) ]
  ! VOID            [ reduce using rule 81 (value -> number .) ]
  ! RBRACE          [ reduce using rule 81 (value -> number .) ]


state 28

    (56) concate -> string .
    (82) value -> string .

  ! reduce/reduce conflict for $end resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for RPAREN resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for PRINT resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for IF resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for WHILE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for FOR resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for LATE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for FINAL resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for CONST resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for VAR resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for VOID resolved using rule 56 (concate -> string .)
  ! reduce/reduce conflict for RBRACE resolved using rule 56 (concate -> string .)
    PLUS            reduce using rule 56 (concate -> string .)
    $end            reduce using rule 56 (concate -> string .)
    SEMICOLON       reduce using rule 56 (concate -> string .)
    RPAREN          reduce using rule 56 (concate -> string .)
    LINE_BREAK      reduce using rule 56 (concate -> string .)
    PRINT           reduce using rule 56 (concate -> string .)
    IF              reduce using rule 56 (concate -> string .)
    WHILE           reduce using rule 56 (concate -> string .)
    FOR             reduce using rule 56 (concate -> string .)
    IDENTIFIER      reduce using rule 56 (concate -> string .)
    LATE            reduce using rule 56 (concate -> string .)
    FINAL           reduce using rule 56 (concate -> string .)
    CONST           reduce using rule 56 (concate -> string .)
    INTEGER_TYPE    reduce using rule 56 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 56 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 56 (concate -> string .)
    QUEUE_TYPE      reduce using rule 56 (concate -> string .)
    STRING_TYPE     reduce using rule 56 (concate -> string .)
    ENUM_TYPE       reduce using rule 56 (concate -> string .)
    VAR             reduce using rule 56 (concate -> string .)
    LIST_TYPE       reduce using rule 56 (concate -> string .)
    MAP_TYPE        reduce using rule 56 (concate -> string .)
    SET_TYPE        reduce using rule 56 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 56 (concate -> string .)
    VOID            reduce using rule 56 (concate -> string .)
    RBRACE          reduce using rule 56 (concate -> string .)
    EQUAL           reduce using rule 82 (value -> string .)
    NOT_EQUAL       reduce using rule 82 (value -> string .)
    LESS            reduce using rule 82 (value -> string .)
    LESS_EQUAL      reduce using rule 82 (value -> string .)
    GREATER         reduce using rule 82 (value -> string .)
    GREATER_EQUAL   reduce using rule 82 (value -> string .)
    LOGICAL_AND     reduce using rule 82 (value -> string .)
    LOGICAL_OR      reduce using rule 82 (value -> string .)

  ! $end            [ reduce using rule 82 (value -> string .) ]
  ! SEMICOLON       [ reduce using rule 82 (value -> string .) ]
  ! RPAREN          [ reduce using rule 82 (value -> string .) ]
  ! LINE_BREAK      [ reduce using rule 82 (value -> string .) ]
  ! PRINT           [ reduce using rule 82 (value -> string .) ]
  ! IF              [ reduce using rule 82 (value -> string .) ]
  ! WHILE           [ reduce using rule 82 (value -> string .) ]
  ! FOR             [ reduce using rule 82 (value -> string .) ]
  ! IDENTIFIER      [ reduce using rule 82 (value -> string .) ]
  ! LATE            [ reduce using rule 82 (value -> string .) ]
  ! FINAL           [ reduce using rule 82 (value -> string .) ]
  ! CONST           [ reduce using rule 82 (value -> string .) ]
  ! INTEGER_TYPE    [ reduce using rule 82 (value -> string .) ]
  ! DOUBLE_TYPE     [ reduce using rule 82 (value -> string .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 82 (value -> string .) ]
  ! QUEUE_TYPE      [ reduce using rule 82 (value -> string .) ]
  ! STRING_TYPE     [ reduce using rule 82 (value -> string .) ]
  ! ENUM_TYPE       [ reduce using rule 82 (value -> string .) ]
  ! VAR             [ reduce using rule 82 (value -> string .) ]
  ! LIST_TYPE       [ reduce using rule 82 (value -> string .) ]
  ! MAP_TYPE        [ reduce using rule 82 (value -> string .) ]
  ! SET_TYPE        [ reduce using rule 82 (value -> string .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 82 (value -> string .) ]
  ! VOID            [ reduce using rule 82 (value -> string .) ]
  ! RBRACE          [ reduce using rule 82 (value -> string .) ]


state 29

    (63) logic -> comparison .
    (61) comparison -> comparison . comp_op comparison
    (72) comp_op -> . EQUAL
    (73) comp_op -> . NOT_EQUAL
    (74) comp_op -> . LESS
    (75) comp_op -> . LESS_EQUAL
    (76) comp_op -> . GREATER
    (77) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 63 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 63 (logic -> comparison .)
    $end            reduce using rule 63 (logic -> comparison .)
    SEMICOLON       reduce using rule 63 (logic -> comparison .)
    RPAREN          reduce using rule 63 (logic -> comparison .)
    LINE_BREAK      reduce using rule 63 (logic -> comparison .)
    PRINT           reduce using rule 63 (logic -> comparison .)
    IF              reduce using rule 63 (logic -> comparison .)
    WHILE           reduce using rule 63 (logic -> comparison .)
    FOR             reduce using rule 63 (logic -> comparison .)
    IDENTIFIER      reduce using rule 63 (logic -> comparison .)
    LATE            reduce using rule 63 (logic -> comparison .)
    FINAL           reduce using rule 63 (logic -> comparison .)
    CONST           reduce using rule 63 (logic -> comparison .)
    INTEGER_TYPE    reduce using rule 63 (logic -> comparison .)
    DOUBLE_TYPE     reduce using rule 63 (logic -> comparison .)
    BOOLEAN_TYPE    reduce using rule 63 (logic -> comparison .)
    QUEUE_TYPE      reduce using rule 63 (logic -> comparison .)
    STRING_TYPE     reduce using rule 63 (logic -> comparison .)
    ENUM_TYPE       reduce using rule 63 (logic -> comparison .)
    VAR             reduce using rule 63 (logic -> comparison .)
    LIST_TYPE       reduce using rule 63 (logic -> comparison .)
    MAP_TYPE        reduce using rule 63 (logic -> comparison .)
    SET_TYPE        reduce using rule 63 (logic -> comparison .)
    DYNAMIC_TYPE    reduce using rule 63 (logic -> comparison .)
    VOID            reduce using rule 63 (logic -> comparison .)
    RBRACE          reduce using rule 63 (logic -> comparison .)
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    LESS            shift and go to state 97
    LESS_EQUAL      shift and go to state 98
    GREATER         shift and go to state 99
    GREATER_EQUAL   shift and go to state 100

    comp_op                        shift and go to state 94

state 30

    (66) logic -> LOGICAL_NOT . logic
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 102
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    logic                          shift and go to state 101
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 31

    (23) modifier -> LATE .

    INTEGER_TYPE    reduce using rule 23 (modifier -> LATE .)
    DOUBLE_TYPE     reduce using rule 23 (modifier -> LATE .)
    BOOLEAN_TYPE    reduce using rule 23 (modifier -> LATE .)
    QUEUE_TYPE      reduce using rule 23 (modifier -> LATE .)
    STRING_TYPE     reduce using rule 23 (modifier -> LATE .)
    ENUM_TYPE       reduce using rule 23 (modifier -> LATE .)
    VAR             reduce using rule 23 (modifier -> LATE .)
    LIST_TYPE       reduce using rule 23 (modifier -> LATE .)
    MAP_TYPE        reduce using rule 23 (modifier -> LATE .)
    SET_TYPE        reduce using rule 23 (modifier -> LATE .)
    DYNAMIC_TYPE    reduce using rule 23 (modifier -> LATE .)
    VOID            reduce using rule 23 (modifier -> LATE .)


state 32

    (24) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 24 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 24 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 24 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 24 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 24 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 24 (modifier -> FINAL .)
    VAR             reduce using rule 24 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 24 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 24 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 24 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 24 (modifier -> FINAL .)
    VOID            reduce using rule 24 (modifier -> FINAL .)


state 33

    (25) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 25 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 25 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 25 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 25 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 25 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 25 (modifier -> CONST .)
    VAR             reduce using rule 25 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 25 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 25 (modifier -> CONST .)
    SET_TYPE        reduce using rule 25 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 25 (modifier -> CONST .)
    VOID            reduce using rule 25 (modifier -> CONST .)


state 34

    (35) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 35 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 35 (type -> INTEGER_TYPE .)


state 35

    (36) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 36 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 36 (type -> DOUBLE_TYPE .)


state 36

    (37) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 37 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 37 (type -> BOOLEAN_TYPE .)


state 37

    (38) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 38 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 38 (type -> QUEUE_TYPE .)


state 38

    (39) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 39 (type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 39 (type -> STRING_TYPE .)


state 39

    (40) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 40 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 40 (type -> ENUM_TYPE .)


state 40

    (41) type -> VAR .

    IDENTIFIER      reduce using rule 41 (type -> VAR .)
    QUESTION_MARK   reduce using rule 41 (type -> VAR .)


state 41

    (42) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 42 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 42 (type -> LIST_TYPE .)


state 42

    (43) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 43 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 43 (type -> MAP_TYPE .)


state 43

    (44) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 44 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 44 (type -> SET_TYPE .)


state 44

    (45) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 45 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 45 (type -> DYNAMIC_TYPE .)


state 45

    (46) type -> VOID .

    IDENTIFIER      reduce using rule 46 (type -> VOID .)
    QUESTION_MARK   reduce using rule 46 (type -> VOID .)


state 46

    (84) number -> INTEGER .

    DIVIDE          reduce using rule 84 (number -> INTEGER .)
    PLUS            reduce using rule 84 (number -> INTEGER .)
    MINUS           reduce using rule 84 (number -> INTEGER .)
    TIMES           reduce using rule 84 (number -> INTEGER .)
    $end            reduce using rule 84 (number -> INTEGER .)
    EQUAL           reduce using rule 84 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 84 (number -> INTEGER .)
    LESS            reduce using rule 84 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 84 (number -> INTEGER .)
    GREATER         reduce using rule 84 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 84 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 84 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 84 (number -> INTEGER .)
    SEMICOLON       reduce using rule 84 (number -> INTEGER .)
    RPAREN          reduce using rule 84 (number -> INTEGER .)
    LINE_BREAK      reduce using rule 84 (number -> INTEGER .)
    PRINT           reduce using rule 84 (number -> INTEGER .)
    IF              reduce using rule 84 (number -> INTEGER .)
    WHILE           reduce using rule 84 (number -> INTEGER .)
    FOR             reduce using rule 84 (number -> INTEGER .)
    IDENTIFIER      reduce using rule 84 (number -> INTEGER .)
    LATE            reduce using rule 84 (number -> INTEGER .)
    FINAL           reduce using rule 84 (number -> INTEGER .)
    CONST           reduce using rule 84 (number -> INTEGER .)
    INTEGER_TYPE    reduce using rule 84 (number -> INTEGER .)
    DOUBLE_TYPE     reduce using rule 84 (number -> INTEGER .)
    BOOLEAN_TYPE    reduce using rule 84 (number -> INTEGER .)
    QUEUE_TYPE      reduce using rule 84 (number -> INTEGER .)
    STRING_TYPE     reduce using rule 84 (number -> INTEGER .)
    ENUM_TYPE       reduce using rule 84 (number -> INTEGER .)
    VAR             reduce using rule 84 (number -> INTEGER .)
    LIST_TYPE       reduce using rule 84 (number -> INTEGER .)
    MAP_TYPE        reduce using rule 84 (number -> INTEGER .)
    SET_TYPE        reduce using rule 84 (number -> INTEGER .)
    DYNAMIC_TYPE    reduce using rule 84 (number -> INTEGER .)
    VOID            reduce using rule 84 (number -> INTEGER .)
    RBRACE          reduce using rule 84 (number -> INTEGER .)
    COMMA           reduce using rule 84 (number -> INTEGER .)
    RSQUARE         reduce using rule 84 (number -> INTEGER .)


state 47

    (85) number -> DOUBLE .

    DIVIDE          reduce using rule 85 (number -> DOUBLE .)
    PLUS            reduce using rule 85 (number -> DOUBLE .)
    MINUS           reduce using rule 85 (number -> DOUBLE .)
    TIMES           reduce using rule 85 (number -> DOUBLE .)
    $end            reduce using rule 85 (number -> DOUBLE .)
    EQUAL           reduce using rule 85 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 85 (number -> DOUBLE .)
    LESS            reduce using rule 85 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 85 (number -> DOUBLE .)
    GREATER         reduce using rule 85 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 85 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 85 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 85 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 85 (number -> DOUBLE .)
    RPAREN          reduce using rule 85 (number -> DOUBLE .)
    LINE_BREAK      reduce using rule 85 (number -> DOUBLE .)
    PRINT           reduce using rule 85 (number -> DOUBLE .)
    IF              reduce using rule 85 (number -> DOUBLE .)
    WHILE           reduce using rule 85 (number -> DOUBLE .)
    FOR             reduce using rule 85 (number -> DOUBLE .)
    IDENTIFIER      reduce using rule 85 (number -> DOUBLE .)
    LATE            reduce using rule 85 (number -> DOUBLE .)
    FINAL           reduce using rule 85 (number -> DOUBLE .)
    CONST           reduce using rule 85 (number -> DOUBLE .)
    INTEGER_TYPE    reduce using rule 85 (number -> DOUBLE .)
    DOUBLE_TYPE     reduce using rule 85 (number -> DOUBLE .)
    BOOLEAN_TYPE    reduce using rule 85 (number -> DOUBLE .)
    QUEUE_TYPE      reduce using rule 85 (number -> DOUBLE .)
    STRING_TYPE     reduce using rule 85 (number -> DOUBLE .)
    ENUM_TYPE       reduce using rule 85 (number -> DOUBLE .)
    VAR             reduce using rule 85 (number -> DOUBLE .)
    LIST_TYPE       reduce using rule 85 (number -> DOUBLE .)
    MAP_TYPE        reduce using rule 85 (number -> DOUBLE .)
    SET_TYPE        reduce using rule 85 (number -> DOUBLE .)
    DYNAMIC_TYPE    reduce using rule 85 (number -> DOUBLE .)
    VOID            reduce using rule 85 (number -> DOUBLE .)
    RBRACE          reduce using rule 85 (number -> DOUBLE .)
    COMMA           reduce using rule 85 (number -> DOUBLE .)
    RSQUARE         reduce using rule 85 (number -> DOUBLE .)


state 48

    (86) string -> STRING .

    PLUS            reduce using rule 86 (string -> STRING .)
    $end            reduce using rule 86 (string -> STRING .)
    EQUAL           reduce using rule 86 (string -> STRING .)
    NOT_EQUAL       reduce using rule 86 (string -> STRING .)
    LESS            reduce using rule 86 (string -> STRING .)
    LESS_EQUAL      reduce using rule 86 (string -> STRING .)
    GREATER         reduce using rule 86 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 86 (string -> STRING .)
    LOGICAL_AND     reduce using rule 86 (string -> STRING .)
    LOGICAL_OR      reduce using rule 86 (string -> STRING .)
    SEMICOLON       reduce using rule 86 (string -> STRING .)
    RPAREN          reduce using rule 86 (string -> STRING .)
    LINE_BREAK      reduce using rule 86 (string -> STRING .)
    PRINT           reduce using rule 86 (string -> STRING .)
    IF              reduce using rule 86 (string -> STRING .)
    WHILE           reduce using rule 86 (string -> STRING .)
    FOR             reduce using rule 86 (string -> STRING .)
    IDENTIFIER      reduce using rule 86 (string -> STRING .)
    LATE            reduce using rule 86 (string -> STRING .)
    FINAL           reduce using rule 86 (string -> STRING .)
    CONST           reduce using rule 86 (string -> STRING .)
    INTEGER_TYPE    reduce using rule 86 (string -> STRING .)
    DOUBLE_TYPE     reduce using rule 86 (string -> STRING .)
    BOOLEAN_TYPE    reduce using rule 86 (string -> STRING .)
    QUEUE_TYPE      reduce using rule 86 (string -> STRING .)
    STRING_TYPE     reduce using rule 86 (string -> STRING .)
    ENUM_TYPE       reduce using rule 86 (string -> STRING .)
    VAR             reduce using rule 86 (string -> STRING .)
    LIST_TYPE       reduce using rule 86 (string -> STRING .)
    MAP_TYPE        reduce using rule 86 (string -> STRING .)
    SET_TYPE        reduce using rule 86 (string -> STRING .)
    DYNAMIC_TYPE    reduce using rule 86 (string -> STRING .)
    VOID            reduce using rule 86 (string -> STRING .)
    RBRACE          reduce using rule 86 (string -> STRING .)
    COMMA           reduce using rule 86 (string -> STRING .)
    RSQUARE         reduce using rule 86 (string -> STRING .)


state 49

    (59) comparison -> value .

    EQUAL           reduce using rule 59 (comparison -> value .)
    NOT_EQUAL       reduce using rule 59 (comparison -> value .)
    LESS            reduce using rule 59 (comparison -> value .)
    LESS_EQUAL      reduce using rule 59 (comparison -> value .)
    GREATER         reduce using rule 59 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 59 (comparison -> value .)
    LOGICAL_AND     reduce using rule 59 (comparison -> value .)
    LOGICAL_OR      reduce using rule 59 (comparison -> value .)
    $end            reduce using rule 59 (comparison -> value .)
    SEMICOLON       reduce using rule 59 (comparison -> value .)
    RPAREN          reduce using rule 59 (comparison -> value .)
    LINE_BREAK      reduce using rule 59 (comparison -> value .)
    PRINT           reduce using rule 59 (comparison -> value .)
    IF              reduce using rule 59 (comparison -> value .)
    WHILE           reduce using rule 59 (comparison -> value .)
    FOR             reduce using rule 59 (comparison -> value .)
    IDENTIFIER      reduce using rule 59 (comparison -> value .)
    LATE            reduce using rule 59 (comparison -> value .)
    FINAL           reduce using rule 59 (comparison -> value .)
    CONST           reduce using rule 59 (comparison -> value .)
    INTEGER_TYPE    reduce using rule 59 (comparison -> value .)
    DOUBLE_TYPE     reduce using rule 59 (comparison -> value .)
    BOOLEAN_TYPE    reduce using rule 59 (comparison -> value .)
    QUEUE_TYPE      reduce using rule 59 (comparison -> value .)
    STRING_TYPE     reduce using rule 59 (comparison -> value .)
    ENUM_TYPE       reduce using rule 59 (comparison -> value .)
    VAR             reduce using rule 59 (comparison -> value .)
    LIST_TYPE       reduce using rule 59 (comparison -> value .)
    MAP_TYPE        reduce using rule 59 (comparison -> value .)
    SET_TYPE        reduce using rule 59 (comparison -> value .)
    DYNAMIC_TYPE    reduce using rule 59 (comparison -> value .)
    VOID            reduce using rule 59 (comparison -> value .)
    RBRACE          reduce using rule 59 (comparison -> value .)


state 50

    (60) comparison -> boolean .

    EQUAL           reduce using rule 60 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 60 (comparison -> boolean .)
    LESS            reduce using rule 60 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 60 (comparison -> boolean .)
    GREATER         reduce using rule 60 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 60 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 60 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 60 (comparison -> boolean .)
    $end            reduce using rule 60 (comparison -> boolean .)
    SEMICOLON       reduce using rule 60 (comparison -> boolean .)
    RPAREN          reduce using rule 60 (comparison -> boolean .)
    LINE_BREAK      reduce using rule 60 (comparison -> boolean .)
    PRINT           reduce using rule 60 (comparison -> boolean .)
    IF              reduce using rule 60 (comparison -> boolean .)
    WHILE           reduce using rule 60 (comparison -> boolean .)
    FOR             reduce using rule 60 (comparison -> boolean .)
    IDENTIFIER      reduce using rule 60 (comparison -> boolean .)
    LATE            reduce using rule 60 (comparison -> boolean .)
    FINAL           reduce using rule 60 (comparison -> boolean .)
    CONST           reduce using rule 60 (comparison -> boolean .)
    INTEGER_TYPE    reduce using rule 60 (comparison -> boolean .)
    DOUBLE_TYPE     reduce using rule 60 (comparison -> boolean .)
    BOOLEAN_TYPE    reduce using rule 60 (comparison -> boolean .)
    QUEUE_TYPE      reduce using rule 60 (comparison -> boolean .)
    STRING_TYPE     reduce using rule 60 (comparison -> boolean .)
    ENUM_TYPE       reduce using rule 60 (comparison -> boolean .)
    VAR             reduce using rule 60 (comparison -> boolean .)
    LIST_TYPE       reduce using rule 60 (comparison -> boolean .)
    MAP_TYPE        reduce using rule 60 (comparison -> boolean .)
    SET_TYPE        reduce using rule 60 (comparison -> boolean .)
    DYNAMIC_TYPE    reduce using rule 60 (comparison -> boolean .)
    VOID            reduce using rule 60 (comparison -> boolean .)
    RBRACE          reduce using rule 60 (comparison -> boolean .)


state 51

    (83) value -> list .

    EQUAL           reduce using rule 83 (value -> list .)
    NOT_EQUAL       reduce using rule 83 (value -> list .)
    LESS            reduce using rule 83 (value -> list .)
    LESS_EQUAL      reduce using rule 83 (value -> list .)
    GREATER         reduce using rule 83 (value -> list .)
    GREATER_EQUAL   reduce using rule 83 (value -> list .)
    LOGICAL_AND     reduce using rule 83 (value -> list .)
    LOGICAL_OR      reduce using rule 83 (value -> list .)
    $end            reduce using rule 83 (value -> list .)
    SEMICOLON       reduce using rule 83 (value -> list .)
    RPAREN          reduce using rule 83 (value -> list .)
    LINE_BREAK      reduce using rule 83 (value -> list .)
    PRINT           reduce using rule 83 (value -> list .)
    IF              reduce using rule 83 (value -> list .)
    WHILE           reduce using rule 83 (value -> list .)
    FOR             reduce using rule 83 (value -> list .)
    IDENTIFIER      reduce using rule 83 (value -> list .)
    LATE            reduce using rule 83 (value -> list .)
    FINAL           reduce using rule 83 (value -> list .)
    CONST           reduce using rule 83 (value -> list .)
    INTEGER_TYPE    reduce using rule 83 (value -> list .)
    DOUBLE_TYPE     reduce using rule 83 (value -> list .)
    BOOLEAN_TYPE    reduce using rule 83 (value -> list .)
    QUEUE_TYPE      reduce using rule 83 (value -> list .)
    STRING_TYPE     reduce using rule 83 (value -> list .)
    ENUM_TYPE       reduce using rule 83 (value -> list .)
    VAR             reduce using rule 83 (value -> list .)
    LIST_TYPE       reduce using rule 83 (value -> list .)
    MAP_TYPE        reduce using rule 83 (value -> list .)
    SET_TYPE        reduce using rule 83 (value -> list .)
    DYNAMIC_TYPE    reduce using rule 83 (value -> list .)
    VOID            reduce using rule 83 (value -> list .)
    RBRACE          reduce using rule 83 (value -> list .)
    COMMA           reduce using rule 83 (value -> list .)
    RSQUARE         reduce using rule 83 (value -> list .)


state 52

    (87) boolean -> TRUE .

    EQUAL           reduce using rule 87 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 87 (boolean -> TRUE .)
    LESS            reduce using rule 87 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 87 (boolean -> TRUE .)
    GREATER         reduce using rule 87 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 87 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 87 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 87 (boolean -> TRUE .)
    $end            reduce using rule 87 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 87 (boolean -> TRUE .)
    RPAREN          reduce using rule 87 (boolean -> TRUE .)
    LINE_BREAK      reduce using rule 87 (boolean -> TRUE .)
    PRINT           reduce using rule 87 (boolean -> TRUE .)
    IF              reduce using rule 87 (boolean -> TRUE .)
    WHILE           reduce using rule 87 (boolean -> TRUE .)
    FOR             reduce using rule 87 (boolean -> TRUE .)
    IDENTIFIER      reduce using rule 87 (boolean -> TRUE .)
    LATE            reduce using rule 87 (boolean -> TRUE .)
    FINAL           reduce using rule 87 (boolean -> TRUE .)
    CONST           reduce using rule 87 (boolean -> TRUE .)
    INTEGER_TYPE    reduce using rule 87 (boolean -> TRUE .)
    DOUBLE_TYPE     reduce using rule 87 (boolean -> TRUE .)
    BOOLEAN_TYPE    reduce using rule 87 (boolean -> TRUE .)
    QUEUE_TYPE      reduce using rule 87 (boolean -> TRUE .)
    STRING_TYPE     reduce using rule 87 (boolean -> TRUE .)
    ENUM_TYPE       reduce using rule 87 (boolean -> TRUE .)
    VAR             reduce using rule 87 (boolean -> TRUE .)
    LIST_TYPE       reduce using rule 87 (boolean -> TRUE .)
    MAP_TYPE        reduce using rule 87 (boolean -> TRUE .)
    SET_TYPE        reduce using rule 87 (boolean -> TRUE .)
    DYNAMIC_TYPE    reduce using rule 87 (boolean -> TRUE .)
    VOID            reduce using rule 87 (boolean -> TRUE .)
    RBRACE          reduce using rule 87 (boolean -> TRUE .)


state 53

    (88) boolean -> FALSE .

    EQUAL           reduce using rule 88 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 88 (boolean -> FALSE .)
    LESS            reduce using rule 88 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 88 (boolean -> FALSE .)
    GREATER         reduce using rule 88 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 88 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 88 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 88 (boolean -> FALSE .)
    $end            reduce using rule 88 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 88 (boolean -> FALSE .)
    RPAREN          reduce using rule 88 (boolean -> FALSE .)
    LINE_BREAK      reduce using rule 88 (boolean -> FALSE .)
    PRINT           reduce using rule 88 (boolean -> FALSE .)
    IF              reduce using rule 88 (boolean -> FALSE .)
    WHILE           reduce using rule 88 (boolean -> FALSE .)
    FOR             reduce using rule 88 (boolean -> FALSE .)
    IDENTIFIER      reduce using rule 88 (boolean -> FALSE .)
    LATE            reduce using rule 88 (boolean -> FALSE .)
    FINAL           reduce using rule 88 (boolean -> FALSE .)
    CONST           reduce using rule 88 (boolean -> FALSE .)
    INTEGER_TYPE    reduce using rule 88 (boolean -> FALSE .)
    DOUBLE_TYPE     reduce using rule 88 (boolean -> FALSE .)
    BOOLEAN_TYPE    reduce using rule 88 (boolean -> FALSE .)
    QUEUE_TYPE      reduce using rule 88 (boolean -> FALSE .)
    STRING_TYPE     reduce using rule 88 (boolean -> FALSE .)
    ENUM_TYPE       reduce using rule 88 (boolean -> FALSE .)
    VAR             reduce using rule 88 (boolean -> FALSE .)
    LIST_TYPE       reduce using rule 88 (boolean -> FALSE .)
    MAP_TYPE        reduce using rule 88 (boolean -> FALSE .)
    SET_TYPE        reduce using rule 88 (boolean -> FALSE .)
    DYNAMIC_TYPE    reduce using rule 88 (boolean -> FALSE .)
    VOID            reduce using rule 88 (boolean -> FALSE .)
    RBRACE          reduce using rule 88 (boolean -> FALSE .)


state 54

    (89) list -> LSQUARE . RSQUARE
    (90) list -> LSQUARE . values RSQUARE
    (78) values -> . value
    (79) values -> . value COMMA values
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 105
    IDENTIFIER      shift and go to state 87
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    values                         shift and go to state 106
    value                          shift and go to state 107
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 55

    (29) if_statement -> if_statement ELSE . if_statement
    (30) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 109
    IF              shift and go to state 22

    if_statement                   shift and go to state 108

state 56

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 110


state 57

    (97) line -> print .

    LINE_BREAK      reduce using rule 97 (line -> print .)
    PRINT           reduce using rule 97 (line -> print .)
    IF              reduce using rule 97 (line -> print .)
    WHILE           reduce using rule 97 (line -> print .)
    FOR             reduce using rule 97 (line -> print .)
    IDENTIFIER      reduce using rule 97 (line -> print .)
    LATE            reduce using rule 97 (line -> print .)
    FINAL           reduce using rule 97 (line -> print .)
    CONST           reduce using rule 97 (line -> print .)
    INTEGER_TYPE    reduce using rule 97 (line -> print .)
    DOUBLE_TYPE     reduce using rule 97 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 97 (line -> print .)
    QUEUE_TYPE      reduce using rule 97 (line -> print .)
    STRING_TYPE     reduce using rule 97 (line -> print .)
    ENUM_TYPE       reduce using rule 97 (line -> print .)
    VAR             reduce using rule 97 (line -> print .)
    LIST_TYPE       reduce using rule 97 (line -> print .)
    MAP_TYPE        reduce using rule 97 (line -> print .)
    SET_TYPE        reduce using rule 97 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 97 (line -> print .)
    VOID            reduce using rule 97 (line -> print .)
    RBRACE          reduce using rule 97 (line -> print .)
    $end            reduce using rule 97 (line -> print .)


state 58

    (98) line -> assignment .

    LINE_BREAK      reduce using rule 98 (line -> assignment .)
    PRINT           reduce using rule 98 (line -> assignment .)
    IF              reduce using rule 98 (line -> assignment .)
    WHILE           reduce using rule 98 (line -> assignment .)
    FOR             reduce using rule 98 (line -> assignment .)
    IDENTIFIER      reduce using rule 98 (line -> assignment .)
    LATE            reduce using rule 98 (line -> assignment .)
    FINAL           reduce using rule 98 (line -> assignment .)
    CONST           reduce using rule 98 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 98 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 98 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 98 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 98 (line -> assignment .)
    STRING_TYPE     reduce using rule 98 (line -> assignment .)
    ENUM_TYPE       reduce using rule 98 (line -> assignment .)
    VAR             reduce using rule 98 (line -> assignment .)
    LIST_TYPE       reduce using rule 98 (line -> assignment .)
    MAP_TYPE        reduce using rule 98 (line -> assignment .)
    SET_TYPE        reduce using rule 98 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 98 (line -> assignment .)
    VOID            reduce using rule 98 (line -> assignment .)
    RBRACE          reduce using rule 98 (line -> assignment .)
    $end            reduce using rule 98 (line -> assignment .)


state 59

    (99) line -> function .

    LINE_BREAK      reduce using rule 99 (line -> function .)
    PRINT           reduce using rule 99 (line -> function .)
    IF              reduce using rule 99 (line -> function .)
    WHILE           reduce using rule 99 (line -> function .)
    FOR             reduce using rule 99 (line -> function .)
    IDENTIFIER      reduce using rule 99 (line -> function .)
    LATE            reduce using rule 99 (line -> function .)
    FINAL           reduce using rule 99 (line -> function .)
    CONST           reduce using rule 99 (line -> function .)
    INTEGER_TYPE    reduce using rule 99 (line -> function .)
    DOUBLE_TYPE     reduce using rule 99 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 99 (line -> function .)
    QUEUE_TYPE      reduce using rule 99 (line -> function .)
    STRING_TYPE     reduce using rule 99 (line -> function .)
    ENUM_TYPE       reduce using rule 99 (line -> function .)
    VAR             reduce using rule 99 (line -> function .)
    LIST_TYPE       reduce using rule 99 (line -> function .)
    MAP_TYPE        reduce using rule 99 (line -> function .)
    SET_TYPE        reduce using rule 99 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 99 (line -> function .)
    VOID            reduce using rule 99 (line -> function .)
    RBRACE          reduce using rule 99 (line -> function .)
    $end            reduce using rule 99 (line -> function .)


state 60

    (100) line -> if_statement .
    (29) if_statement -> if_statement . ELSE if_statement
    (30) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 100 (line -> if_statement .)
    PRINT           reduce using rule 100 (line -> if_statement .)
    IF              reduce using rule 100 (line -> if_statement .)
    WHILE           reduce using rule 100 (line -> if_statement .)
    FOR             reduce using rule 100 (line -> if_statement .)
    IDENTIFIER      reduce using rule 100 (line -> if_statement .)
    LATE            reduce using rule 100 (line -> if_statement .)
    FINAL           reduce using rule 100 (line -> if_statement .)
    CONST           reduce using rule 100 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 100 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 100 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 100 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 100 (line -> if_statement .)
    STRING_TYPE     reduce using rule 100 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 100 (line -> if_statement .)
    VAR             reduce using rule 100 (line -> if_statement .)
    LIST_TYPE       reduce using rule 100 (line -> if_statement .)
    MAP_TYPE        reduce using rule 100 (line -> if_statement .)
    SET_TYPE        reduce using rule 100 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 100 (line -> if_statement .)
    VOID            reduce using rule 100 (line -> if_statement .)
    RBRACE          reduce using rule 100 (line -> if_statement .)
    $end            reduce using rule 100 (line -> if_statement .)
    ELSE            shift and go to state 55


state 61

    (101) line -> while_statement .

    LINE_BREAK      reduce using rule 101 (line -> while_statement .)
    PRINT           reduce using rule 101 (line -> while_statement .)
    IF              reduce using rule 101 (line -> while_statement .)
    WHILE           reduce using rule 101 (line -> while_statement .)
    FOR             reduce using rule 101 (line -> while_statement .)
    IDENTIFIER      reduce using rule 101 (line -> while_statement .)
    LATE            reduce using rule 101 (line -> while_statement .)
    FINAL           reduce using rule 101 (line -> while_statement .)
    CONST           reduce using rule 101 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 101 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 101 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 101 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 101 (line -> while_statement .)
    STRING_TYPE     reduce using rule 101 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 101 (line -> while_statement .)
    VAR             reduce using rule 101 (line -> while_statement .)
    LIST_TYPE       reduce using rule 101 (line -> while_statement .)
    MAP_TYPE        reduce using rule 101 (line -> while_statement .)
    SET_TYPE        reduce using rule 101 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 101 (line -> while_statement .)
    VOID            reduce using rule 101 (line -> while_statement .)
    RBRACE          reduce using rule 101 (line -> while_statement .)
    $end            reduce using rule 101 (line -> while_statement .)


state 62

    (102) line -> for_statement .

    LINE_BREAK      reduce using rule 102 (line -> for_statement .)
    PRINT           reduce using rule 102 (line -> for_statement .)
    IF              reduce using rule 102 (line -> for_statement .)
    WHILE           reduce using rule 102 (line -> for_statement .)
    FOR             reduce using rule 102 (line -> for_statement .)
    IDENTIFIER      reduce using rule 102 (line -> for_statement .)
    LATE            reduce using rule 102 (line -> for_statement .)
    FINAL           reduce using rule 102 (line -> for_statement .)
    CONST           reduce using rule 102 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 102 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 102 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 102 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 102 (line -> for_statement .)
    STRING_TYPE     reduce using rule 102 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 102 (line -> for_statement .)
    VAR             reduce using rule 102 (line -> for_statement .)
    LIST_TYPE       reduce using rule 102 (line -> for_statement .)
    MAP_TYPE        reduce using rule 102 (line -> for_statement .)
    SET_TYPE        reduce using rule 102 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 102 (line -> for_statement .)
    VOID            reduce using rule 102 (line -> for_statement .)
    RBRACE          reduce using rule 102 (line -> for_statement .)
    $end            reduce using rule 102 (line -> for_statement .)


state 63

    (103) line -> function_call .

    LINE_BREAK      reduce using rule 103 (line -> function_call .)
    PRINT           reduce using rule 103 (line -> function_call .)
    IF              reduce using rule 103 (line -> function_call .)
    WHILE           reduce using rule 103 (line -> function_call .)
    FOR             reduce using rule 103 (line -> function_call .)
    IDENTIFIER      reduce using rule 103 (line -> function_call .)
    LATE            reduce using rule 103 (line -> function_call .)
    FINAL           reduce using rule 103 (line -> function_call .)
    CONST           reduce using rule 103 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 103 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 103 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 103 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 103 (line -> function_call .)
    STRING_TYPE     reduce using rule 103 (line -> function_call .)
    ENUM_TYPE       reduce using rule 103 (line -> function_call .)
    VAR             reduce using rule 103 (line -> function_call .)
    LIST_TYPE       reduce using rule 103 (line -> function_call .)
    MAP_TYPE        reduce using rule 103 (line -> function_call .)
    SET_TYPE        reduce using rule 103 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 103 (line -> function_call .)
    VOID            reduce using rule 103 (line -> function_call .)
    RBRACE          reduce using rule 103 (line -> function_call .)
    $end            reduce using rule 103 (line -> function_call .)


state 64

    (104) line -> reassignment .

    LINE_BREAK      reduce using rule 104 (line -> reassignment .)
    PRINT           reduce using rule 104 (line -> reassignment .)
    IF              reduce using rule 104 (line -> reassignment .)
    WHILE           reduce using rule 104 (line -> reassignment .)
    FOR             reduce using rule 104 (line -> reassignment .)
    IDENTIFIER      reduce using rule 104 (line -> reassignment .)
    LATE            reduce using rule 104 (line -> reassignment .)
    FINAL           reduce using rule 104 (line -> reassignment .)
    CONST           reduce using rule 104 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 104 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 104 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 104 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 104 (line -> reassignment .)
    STRING_TYPE     reduce using rule 104 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 104 (line -> reassignment .)
    VAR             reduce using rule 104 (line -> reassignment .)
    LIST_TYPE       reduce using rule 104 (line -> reassignment .)
    MAP_TYPE        reduce using rule 104 (line -> reassignment .)
    SET_TYPE        reduce using rule 104 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 104 (line -> reassignment .)
    VOID            reduce using rule 104 (line -> reassignment .)
    RBRACE          reduce using rule 104 (line -> reassignment .)
    $end            reduce using rule 104 (line -> reassignment .)


state 65

    (31) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER . LPAREN values RPAREN
    (33) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER . LPAREN RPAREN
    (17) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (20) reassignment -> IDENTIFIER . INLINE_ARITH number
    (21) reassignment -> IDENTIFIER . INLINE_ARITH

    LPAREN          shift and go to state 80
    ASSIGN          shift and go to state 78
    INLINE_ARITH    shift and go to state 79


state 66

    (53) arithmetic -> arithmetic arith_op . arithmetic
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (84) number -> . INTEGER
    (85) number -> . DOUBLE

    LPAREN          shift and go to state 113
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47

    arithmetic                     shift and go to state 111
    number                         shift and go to state 112

state 67

    (69) arith_op -> PLUS .

    LPAREN          reduce using rule 69 (arith_op -> PLUS .)
    INTEGER         reduce using rule 69 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 69 (arith_op -> PLUS .)


state 68

    (70) arith_op -> MINUS .

    LPAREN          reduce using rule 70 (arith_op -> MINUS .)
    INTEGER         reduce using rule 70 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 70 (arith_op -> MINUS .)


state 69

    (71) arith_op -> TIMES .

    LPAREN          reduce using rule 71 (arith_op -> TIMES .)
    INTEGER         reduce using rule 71 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 71 (arith_op -> TIMES .)


state 70

    (57) concate -> concate PLUS . concate
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (86) string -> . STRING

    LPAREN          shift and go to state 116
    STRING          shift and go to state 48

    concate                        shift and go to state 114
    string                         shift and go to state 115

state 71

    (64) logic -> logic logic_op . logic
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 102
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    logic                          shift and go to state 117
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 72

    (67) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 67 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 67 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 67 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 67 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 67 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 67 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 67 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 67 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 67 (logic_op -> LOGICAL_AND .)


state 73

    (68) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 68 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 68 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 68 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 68 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 68 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 68 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 68 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 68 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 68 (logic_op -> LOGICAL_OR .)


state 74

    (12) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (22) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 119
    QUESTION_MARK   shift and go to state 77

    nullable                       shift and go to state 118

state 75

    (13) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 120


state 76

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression
    (91) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 121
    LPAREN          shift and go to state 122


state 77

    (22) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 22 (nullable -> QUESTION_MARK .)


state 78

    (17) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . concate
    (49) expression -> . logic
    (50) expression -> . function_call
    (51) expression -> . division
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (55) division -> . number DIVIDE number
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 123
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

    expression                     shift and go to state 124
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 125
    division                       shift and go to state 16
    number                         shift and go to state 27
    string                         shift and go to state 28
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 79

    (18) reassignment -> IDENTIFIER INLINE_ARITH . number SEMICOLON
    (19) reassignment -> IDENTIFIER INLINE_ARITH . SEMICOLON
    (20) reassignment -> IDENTIFIER INLINE_ARITH . number
    (21) reassignment -> IDENTIFIER INLINE_ARITH .
    (84) number -> . INTEGER
    (85) number -> . DOUBLE

    SEMICOLON       shift and go to state 127
    $end            reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LINE_BREAK      reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    PRINT           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IF              reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    WHILE           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FOR             reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IDENTIFIER      reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LATE            reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FINAL           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    CONST           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER_TYPE    reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DOUBLE_TYPE     reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    BOOLEAN_TYPE    reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    QUEUE_TYPE      reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    STRING_TYPE     reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    ENUM_TYPE       reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VAR             reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LIST_TYPE       reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    MAP_TYPE        reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    SET_TYPE        reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DYNAMIC_TYPE    reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VOID            reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RBRACE          reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RPAREN          reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47

    number                         shift and go to state 126

state 80

    (31) function_call -> IDENTIFIER LPAREN . values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER LPAREN . values RPAREN
    (33) function_call -> IDENTIFIER LPAREN . RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER LPAREN . RPAREN
    (78) values -> . value
    (79) values -> . value COMMA values
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 129
    IDENTIFIER      shift and go to state 87
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    values                         shift and go to state 128
    value                          shift and go to state 107
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 81

    (26) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (27) print -> PRINT LPAREN . RPAREN SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . concate
    (49) expression -> . logic
    (50) expression -> . function_call
    (51) expression -> . division
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (55) division -> . number DIVIDE number
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 131
    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 123
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

    expression                     shift and go to state 130
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 125
    division                       shift and go to state 16
    number                         shift and go to state 27
    string                         shift and go to state 28
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 82

    (54) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (53) arithmetic -> arithmetic . arith_op arithmetic
    (69) arith_op -> . PLUS
    (70) arith_op -> . MINUS
    (71) arith_op -> . TIMES

    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69

    arith_op                       shift and go to state 132

state 83

    (58) concate -> LPAREN concate . PLUS concate RPAREN
    (57) concate -> concate . PLUS concate

    PLUS            shift and go to state 133


state 84

    (65) logic -> LPAREN logic . logic_op logic RPAREN
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

    logic_op                       shift and go to state 134

state 85

    (62) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (63) logic -> comparison .
    (61) comparison -> comparison . comp_op comparison
    (72) comp_op -> . EQUAL
    (73) comp_op -> . NOT_EQUAL
    (74) comp_op -> . LESS
    (75) comp_op -> . LESS_EQUAL
    (76) comp_op -> . GREATER
    (77) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 63 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 63 (logic -> comparison .)
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    LESS            shift and go to state 97
    LESS_EQUAL      shift and go to state 98
    GREATER         shift and go to state 99
    GREATER_EQUAL   shift and go to state 100

    comp_op                        shift and go to state 135

state 86

    (52) arithmetic -> number .
    (81) value -> number .

    PLUS            reduce using rule 52 (arithmetic -> number .)
    MINUS           reduce using rule 52 (arithmetic -> number .)
    TIMES           reduce using rule 52 (arithmetic -> number .)
    EQUAL           reduce using rule 81 (value -> number .)
    NOT_EQUAL       reduce using rule 81 (value -> number .)
    LESS            reduce using rule 81 (value -> number .)
    LESS_EQUAL      reduce using rule 81 (value -> number .)
    GREATER         reduce using rule 81 (value -> number .)
    GREATER_EQUAL   reduce using rule 81 (value -> number .)
    LOGICAL_AND     reduce using rule 81 (value -> number .)
    LOGICAL_OR      reduce using rule 81 (value -> number .)


state 87

    (80) value -> IDENTIFIER .

    EQUAL           reduce using rule 80 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 80 (value -> IDENTIFIER .)
    LESS            reduce using rule 80 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 80 (value -> IDENTIFIER .)
    GREATER         reduce using rule 80 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 80 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 80 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 80 (value -> IDENTIFIER .)
    $end            reduce using rule 80 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 80 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 80 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 80 (value -> IDENTIFIER .)
    PRINT           reduce using rule 80 (value -> IDENTIFIER .)
    IF              reduce using rule 80 (value -> IDENTIFIER .)
    WHILE           reduce using rule 80 (value -> IDENTIFIER .)
    FOR             reduce using rule 80 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 80 (value -> IDENTIFIER .)
    LATE            reduce using rule 80 (value -> IDENTIFIER .)
    FINAL           reduce using rule 80 (value -> IDENTIFIER .)
    CONST           reduce using rule 80 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 80 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 80 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 80 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 80 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 80 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 80 (value -> IDENTIFIER .)
    VAR             reduce using rule 80 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 80 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 80 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 80 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 80 (value -> IDENTIFIER .)
    VOID            reduce using rule 80 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 80 (value -> IDENTIFIER .)
    COMMA           reduce using rule 80 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 80 (value -> IDENTIFIER .)


state 88

    (28) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 102
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    logic                          shift and go to state 136
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 89

    (120) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 102
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    logic                          shift and go to state 137
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 90

    (121) for_statement -> FOR LPAREN . assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    assignment                     shift and go to state 138
    modifier                       shift and go to state 17
    type                           shift and go to state 139

state 91

    (92) lines -> line LINE_BREAK . lines
    (95) lines -> LINE_BREAK .
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 95 (lines -> LINE_BREAK .)
  ! reduce/reduce conflict for RBRACE resolved using rule 95 (lines -> LINE_BREAK .)
    $end            reduce using rule 95 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 95 (lines -> LINE_BREAK .)
    LINE_BREAK      shift and go to state 26
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

  ! $end            [ reduce using rule 96 (lines -> .) ]
  ! RBRACE          [ reduce using rule 96 (lines -> .) ]

    line                           shift and go to state 25
    lines                          shift and go to state 140
    print                          shift and go to state 57
    assignment                     shift and go to state 58
    function                       shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    reassignment                   shift and go to state 64
    modifier                       shift and go to state 17
    type                           shift and go to state 18

state 92

    (93) lines -> line lines .

    $end            reduce using rule 93 (lines -> line lines .)
    RBRACE          reduce using rule 93 (lines -> line lines .)


state 93

    (55) division -> number DIVIDE . number
    (84) number -> . INTEGER
    (85) number -> . DOUBLE

    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47

    number                         shift and go to state 141

state 94

    (61) comparison -> comparison comp_op . comparison
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 143
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    comparison                     shift and go to state 142
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 95

    (72) comp_op -> EQUAL .

    LPAREN          reduce using rule 72 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 72 (comp_op -> EQUAL .)
    TRUE            reduce using rule 72 (comp_op -> EQUAL .)
    FALSE           reduce using rule 72 (comp_op -> EQUAL .)
    INTEGER         reduce using rule 72 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 72 (comp_op -> EQUAL .)
    STRING          reduce using rule 72 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 72 (comp_op -> EQUAL .)


state 96

    (73) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 73 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 73 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 73 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 73 (comp_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 73 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 73 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 73 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 73 (comp_op -> NOT_EQUAL .)


state 97

    (74) comp_op -> LESS .

    LPAREN          reduce using rule 74 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 74 (comp_op -> LESS .)
    TRUE            reduce using rule 74 (comp_op -> LESS .)
    FALSE           reduce using rule 74 (comp_op -> LESS .)
    INTEGER         reduce using rule 74 (comp_op -> LESS .)
    DOUBLE          reduce using rule 74 (comp_op -> LESS .)
    STRING          reduce using rule 74 (comp_op -> LESS .)
    LSQUARE         reduce using rule 74 (comp_op -> LESS .)


state 98

    (75) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 75 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 75 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 75 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 75 (comp_op -> LESS_EQUAL .)
    INTEGER         reduce using rule 75 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 75 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 75 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 75 (comp_op -> LESS_EQUAL .)


state 99

    (76) comp_op -> GREATER .

    LPAREN          reduce using rule 76 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 76 (comp_op -> GREATER .)
    TRUE            reduce using rule 76 (comp_op -> GREATER .)
    FALSE           reduce using rule 76 (comp_op -> GREATER .)
    INTEGER         reduce using rule 76 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 76 (comp_op -> GREATER .)
    STRING          reduce using rule 76 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 76 (comp_op -> GREATER .)


state 100

    (77) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 77 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 77 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 77 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 77 (comp_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 77 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 77 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 77 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 77 (comp_op -> GREATER_EQUAL .)


state 101

    (66) logic -> LOGICAL_NOT logic .
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    LINE_BREAK      reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    PRINT           reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    IF              reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    WHILE           reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    FOR             reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    IDENTIFIER      reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    LATE            reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    FINAL           reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    CONST           reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    INTEGER_TYPE    reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    DOUBLE_TYPE     reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    BOOLEAN_TYPE    reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    QUEUE_TYPE      reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    STRING_TYPE     reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    ENUM_TYPE       reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    VAR             reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    LIST_TYPE       reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    MAP_TYPE        reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    SET_TYPE        reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    DYNAMIC_TYPE    reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    VOID            reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    RBRACE          reduce using rule 66 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

  ! LOGICAL_AND     [ reduce using rule 66 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 66 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 71

state 102

    (65) logic -> LPAREN . logic logic_op logic RPAREN
    (62) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 102
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    logic                          shift and go to state 84
    comparison                     shift and go to state 85
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 103

    (81) value -> number .

    EQUAL           reduce using rule 81 (value -> number .)
    NOT_EQUAL       reduce using rule 81 (value -> number .)
    LESS            reduce using rule 81 (value -> number .)
    LESS_EQUAL      reduce using rule 81 (value -> number .)
    GREATER         reduce using rule 81 (value -> number .)
    GREATER_EQUAL   reduce using rule 81 (value -> number .)
    LOGICAL_AND     reduce using rule 81 (value -> number .)
    LOGICAL_OR      reduce using rule 81 (value -> number .)
    $end            reduce using rule 81 (value -> number .)
    SEMICOLON       reduce using rule 81 (value -> number .)
    RPAREN          reduce using rule 81 (value -> number .)
    LINE_BREAK      reduce using rule 81 (value -> number .)
    PRINT           reduce using rule 81 (value -> number .)
    IF              reduce using rule 81 (value -> number .)
    WHILE           reduce using rule 81 (value -> number .)
    FOR             reduce using rule 81 (value -> number .)
    IDENTIFIER      reduce using rule 81 (value -> number .)
    LATE            reduce using rule 81 (value -> number .)
    FINAL           reduce using rule 81 (value -> number .)
    CONST           reduce using rule 81 (value -> number .)
    INTEGER_TYPE    reduce using rule 81 (value -> number .)
    DOUBLE_TYPE     reduce using rule 81 (value -> number .)
    BOOLEAN_TYPE    reduce using rule 81 (value -> number .)
    QUEUE_TYPE      reduce using rule 81 (value -> number .)
    STRING_TYPE     reduce using rule 81 (value -> number .)
    ENUM_TYPE       reduce using rule 81 (value -> number .)
    VAR             reduce using rule 81 (value -> number .)
    LIST_TYPE       reduce using rule 81 (value -> number .)
    MAP_TYPE        reduce using rule 81 (value -> number .)
    SET_TYPE        reduce using rule 81 (value -> number .)
    DYNAMIC_TYPE    reduce using rule 81 (value -> number .)
    VOID            reduce using rule 81 (value -> number .)
    RBRACE          reduce using rule 81 (value -> number .)
    COMMA           reduce using rule 81 (value -> number .)
    RSQUARE         reduce using rule 81 (value -> number .)


state 104

    (82) value -> string .

    EQUAL           reduce using rule 82 (value -> string .)
    NOT_EQUAL       reduce using rule 82 (value -> string .)
    LESS            reduce using rule 82 (value -> string .)
    LESS_EQUAL      reduce using rule 82 (value -> string .)
    GREATER         reduce using rule 82 (value -> string .)
    GREATER_EQUAL   reduce using rule 82 (value -> string .)
    LOGICAL_AND     reduce using rule 82 (value -> string .)
    LOGICAL_OR      reduce using rule 82 (value -> string .)
    $end            reduce using rule 82 (value -> string .)
    SEMICOLON       reduce using rule 82 (value -> string .)
    RPAREN          reduce using rule 82 (value -> string .)
    LINE_BREAK      reduce using rule 82 (value -> string .)
    PRINT           reduce using rule 82 (value -> string .)
    IF              reduce using rule 82 (value -> string .)
    WHILE           reduce using rule 82 (value -> string .)
    FOR             reduce using rule 82 (value -> string .)
    IDENTIFIER      reduce using rule 82 (value -> string .)
    LATE            reduce using rule 82 (value -> string .)
    FINAL           reduce using rule 82 (value -> string .)
    CONST           reduce using rule 82 (value -> string .)
    INTEGER_TYPE    reduce using rule 82 (value -> string .)
    DOUBLE_TYPE     reduce using rule 82 (value -> string .)
    BOOLEAN_TYPE    reduce using rule 82 (value -> string .)
    QUEUE_TYPE      reduce using rule 82 (value -> string .)
    STRING_TYPE     reduce using rule 82 (value -> string .)
    ENUM_TYPE       reduce using rule 82 (value -> string .)
    VAR             reduce using rule 82 (value -> string .)
    LIST_TYPE       reduce using rule 82 (value -> string .)
    MAP_TYPE        reduce using rule 82 (value -> string .)
    SET_TYPE        reduce using rule 82 (value -> string .)
    DYNAMIC_TYPE    reduce using rule 82 (value -> string .)
    VOID            reduce using rule 82 (value -> string .)
    RBRACE          reduce using rule 82 (value -> string .)
    COMMA           reduce using rule 82 (value -> string .)
    RSQUARE         reduce using rule 82 (value -> string .)


state 105

    (89) list -> LSQUARE RSQUARE .

    EQUAL           reduce using rule 89 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 89 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 89 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 89 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 89 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 89 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 89 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 89 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 89 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 89 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 89 (list -> LSQUARE RSQUARE .)
    LINE_BREAK      reduce using rule 89 (list -> LSQUARE RSQUARE .)
    PRINT           reduce using rule 89 (list -> LSQUARE RSQUARE .)
    IF              reduce using rule 89 (list -> LSQUARE RSQUARE .)
    WHILE           reduce using rule 89 (list -> LSQUARE RSQUARE .)
    FOR             reduce using rule 89 (list -> LSQUARE RSQUARE .)
    IDENTIFIER      reduce using rule 89 (list -> LSQUARE RSQUARE .)
    LATE            reduce using rule 89 (list -> LSQUARE RSQUARE .)
    FINAL           reduce using rule 89 (list -> LSQUARE RSQUARE .)
    CONST           reduce using rule 89 (list -> LSQUARE RSQUARE .)
    INTEGER_TYPE    reduce using rule 89 (list -> LSQUARE RSQUARE .)
    DOUBLE_TYPE     reduce using rule 89 (list -> LSQUARE RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 89 (list -> LSQUARE RSQUARE .)
    QUEUE_TYPE      reduce using rule 89 (list -> LSQUARE RSQUARE .)
    STRING_TYPE     reduce using rule 89 (list -> LSQUARE RSQUARE .)
    ENUM_TYPE       reduce using rule 89 (list -> LSQUARE RSQUARE .)
    VAR             reduce using rule 89 (list -> LSQUARE RSQUARE .)
    LIST_TYPE       reduce using rule 89 (list -> LSQUARE RSQUARE .)
    MAP_TYPE        reduce using rule 89 (list -> LSQUARE RSQUARE .)
    SET_TYPE        reduce using rule 89 (list -> LSQUARE RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 89 (list -> LSQUARE RSQUARE .)
    VOID            reduce using rule 89 (list -> LSQUARE RSQUARE .)
    RBRACE          reduce using rule 89 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 89 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 89 (list -> LSQUARE RSQUARE .)


state 106

    (90) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 144


state 107

    (78) values -> value .
    (79) values -> value . COMMA values

    RSQUARE         reduce using rule 78 (values -> value .)
    RPAREN          reduce using rule 78 (values -> value .)
    COMMA           shift and go to state 145


state 108

    (29) if_statement -> if_statement ELSE if_statement .
    (29) if_statement -> if_statement . ELSE if_statement
    (30) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    WHILE           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    FOR             reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    IDENTIFIER      reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    LATE            reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 55

  ! ELSE            [ reduce using rule 29 (if_statement -> if_statement ELSE if_statement .) ]


state 109

    (30) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 26
    RBRACE          reduce using rule 96 (lines -> .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    if_statement                   shift and go to state 60
    lines                          shift and go to state 146
    line                           shift and go to state 25
    print                          shift and go to state 57
    assignment                     shift and go to state 58
    function                       shift and go to state 59
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    reassignment                   shift and go to state 64
    modifier                       shift and go to state 17
    type                           shift and go to state 18

state 110

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 111

    (53) arithmetic -> arithmetic arith_op arithmetic .
    (53) arithmetic -> arithmetic . arith_op arithmetic
    (69) arith_op -> . PLUS
    (70) arith_op -> . MINUS
    (71) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    $end            reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    LINE_BREAK      reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    PRINT           reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    IF              reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    WHILE           reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    FOR             reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    IDENTIFIER      reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    LATE            reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    FINAL           reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    CONST           reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER_TYPE    reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE_TYPE     reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    BOOLEAN_TYPE    reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    QUEUE_TYPE      reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING_TYPE     reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    ENUM_TYPE       reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    VAR             reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    LIST_TYPE       reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    MAP_TYPE        reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    SET_TYPE        reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    DYNAMIC_TYPE    reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    VOID            reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    RBRACE          reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69

  ! PLUS            [ reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 66

state 112

    (52) arithmetic -> number .

    PLUS            reduce using rule 52 (arithmetic -> number .)
    MINUS           reduce using rule 52 (arithmetic -> number .)
    TIMES           reduce using rule 52 (arithmetic -> number .)
    $end            reduce using rule 52 (arithmetic -> number .)
    SEMICOLON       reduce using rule 52 (arithmetic -> number .)
    RPAREN          reduce using rule 52 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 52 (arithmetic -> number .)
    PRINT           reduce using rule 52 (arithmetic -> number .)
    IF              reduce using rule 52 (arithmetic -> number .)
    WHILE           reduce using rule 52 (arithmetic -> number .)
    FOR             reduce using rule 52 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 52 (arithmetic -> number .)
    LATE            reduce using rule 52 (arithmetic -> number .)
    FINAL           reduce using rule 52 (arithmetic -> number .)
    CONST           reduce using rule 52 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 52 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 52 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 52 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 52 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 52 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 52 (arithmetic -> number .)
    VAR             reduce using rule 52 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 52 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 52 (arithmetic -> number .)
    SET_TYPE        reduce using rule 52 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 52 (arithmetic -> number .)
    VOID            reduce using rule 52 (arithmetic -> number .)
    RBRACE          reduce using rule 52 (arithmetic -> number .)


state 113

    (54) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (84) number -> . INTEGER
    (85) number -> . DOUBLE

    LPAREN          shift and go to state 113
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47

    arithmetic                     shift and go to state 82
    number                         shift and go to state 112

state 114

    (57) concate -> concate PLUS concate .
    (57) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    $end            reduce using rule 57 (concate -> concate PLUS concate .)
    SEMICOLON       reduce using rule 57 (concate -> concate PLUS concate .)
    RPAREN          reduce using rule 57 (concate -> concate PLUS concate .)
    LINE_BREAK      reduce using rule 57 (concate -> concate PLUS concate .)
    PRINT           reduce using rule 57 (concate -> concate PLUS concate .)
    IF              reduce using rule 57 (concate -> concate PLUS concate .)
    WHILE           reduce using rule 57 (concate -> concate PLUS concate .)
    FOR             reduce using rule 57 (concate -> concate PLUS concate .)
    IDENTIFIER      reduce using rule 57 (concate -> concate PLUS concate .)
    LATE            reduce using rule 57 (concate -> concate PLUS concate .)
    FINAL           reduce using rule 57 (concate -> concate PLUS concate .)
    CONST           reduce using rule 57 (concate -> concate PLUS concate .)
    INTEGER_TYPE    reduce using rule 57 (concate -> concate PLUS concate .)
    DOUBLE_TYPE     reduce using rule 57 (concate -> concate PLUS concate .)
    BOOLEAN_TYPE    reduce using rule 57 (concate -> concate PLUS concate .)
    QUEUE_TYPE      reduce using rule 57 (concate -> concate PLUS concate .)
    STRING_TYPE     reduce using rule 57 (concate -> concate PLUS concate .)
    ENUM_TYPE       reduce using rule 57 (concate -> concate PLUS concate .)
    VAR             reduce using rule 57 (concate -> concate PLUS concate .)
    LIST_TYPE       reduce using rule 57 (concate -> concate PLUS concate .)
    MAP_TYPE        reduce using rule 57 (concate -> concate PLUS concate .)
    SET_TYPE        reduce using rule 57 (concate -> concate PLUS concate .)
    DYNAMIC_TYPE    reduce using rule 57 (concate -> concate PLUS concate .)
    VOID            reduce using rule 57 (concate -> concate PLUS concate .)
    RBRACE          reduce using rule 57 (concate -> concate PLUS concate .)
    PLUS            shift and go to state 70

  ! PLUS            [ reduce using rule 57 (concate -> concate PLUS concate .) ]


state 115

    (56) concate -> string .

    PLUS            reduce using rule 56 (concate -> string .)
    $end            reduce using rule 56 (concate -> string .)
    SEMICOLON       reduce using rule 56 (concate -> string .)
    RPAREN          reduce using rule 56 (concate -> string .)
    LINE_BREAK      reduce using rule 56 (concate -> string .)
    PRINT           reduce using rule 56 (concate -> string .)
    IF              reduce using rule 56 (concate -> string .)
    WHILE           reduce using rule 56 (concate -> string .)
    FOR             reduce using rule 56 (concate -> string .)
    IDENTIFIER      reduce using rule 56 (concate -> string .)
    LATE            reduce using rule 56 (concate -> string .)
    FINAL           reduce using rule 56 (concate -> string .)
    CONST           reduce using rule 56 (concate -> string .)
    INTEGER_TYPE    reduce using rule 56 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 56 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 56 (concate -> string .)
    QUEUE_TYPE      reduce using rule 56 (concate -> string .)
    STRING_TYPE     reduce using rule 56 (concate -> string .)
    ENUM_TYPE       reduce using rule 56 (concate -> string .)
    VAR             reduce using rule 56 (concate -> string .)
    LIST_TYPE       reduce using rule 56 (concate -> string .)
    MAP_TYPE        reduce using rule 56 (concate -> string .)
    SET_TYPE        reduce using rule 56 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 56 (concate -> string .)
    VOID            reduce using rule 56 (concate -> string .)
    RBRACE          reduce using rule 56 (concate -> string .)


state 116

    (58) concate -> LPAREN . concate PLUS concate RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (86) string -> . STRING

    LPAREN          shift and go to state 116
    STRING          shift and go to state 48

    concate                        shift and go to state 83
    string                         shift and go to state 115

state 117

    (64) logic -> logic logic_op logic .
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 64 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 64 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 64 (logic -> logic logic_op logic .)
    LINE_BREAK      reduce using rule 64 (logic -> logic logic_op logic .)
    PRINT           reduce using rule 64 (logic -> logic logic_op logic .)
    IF              reduce using rule 64 (logic -> logic logic_op logic .)
    WHILE           reduce using rule 64 (logic -> logic logic_op logic .)
    FOR             reduce using rule 64 (logic -> logic logic_op logic .)
    IDENTIFIER      reduce using rule 64 (logic -> logic logic_op logic .)
    LATE            reduce using rule 64 (logic -> logic logic_op logic .)
    FINAL           reduce using rule 64 (logic -> logic logic_op logic .)
    CONST           reduce using rule 64 (logic -> logic logic_op logic .)
    INTEGER_TYPE    reduce using rule 64 (logic -> logic logic_op logic .)
    DOUBLE_TYPE     reduce using rule 64 (logic -> logic logic_op logic .)
    BOOLEAN_TYPE    reduce using rule 64 (logic -> logic logic_op logic .)
    QUEUE_TYPE      reduce using rule 64 (logic -> logic logic_op logic .)
    STRING_TYPE     reduce using rule 64 (logic -> logic logic_op logic .)
    ENUM_TYPE       reduce using rule 64 (logic -> logic logic_op logic .)
    VAR             reduce using rule 64 (logic -> logic logic_op logic .)
    LIST_TYPE       reduce using rule 64 (logic -> logic logic_op logic .)
    MAP_TYPE        reduce using rule 64 (logic -> logic logic_op logic .)
    SET_TYPE        reduce using rule 64 (logic -> logic logic_op logic .)
    DYNAMIC_TYPE    reduce using rule 64 (logic -> logic logic_op logic .)
    VOID            reduce using rule 64 (logic -> logic logic_op logic .)
    RBRACE          reduce using rule 64 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

  ! LOGICAL_AND     [ reduce using rule 64 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 64 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 71

state 118

    (12) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 147


state 119

    (14) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 148


state 120

    (13) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 149


state 121

    (15) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN . expression
    (47) expression -> . arithmetic
    (48) expression -> . concate
    (49) expression -> . logic
    (50) expression -> . function_call
    (51) expression -> . division
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (55) division -> . number DIVIDE number
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 123
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

    expression                     shift and go to state 150
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 125
    division                       shift and go to state 16
    number                         shift and go to state 27
    string                         shift and go to state 28
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 122

    (91) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (105) parameters -> . VOID
    (106) parameters -> . parameter
    (107) parameters -> . parameter COMMA parameters
    (108) parameters -> .
    (109) parameter -> . type IDENTIFIER
    (110) parameter -> . IDENTIFIER
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    VOID            shift and go to state 154
    RPAREN          reduce using rule 108 (parameters -> .)
    IDENTIFIER      shift and go to state 152
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44

    type                           shift and go to state 151
    parameters                     shift and go to state 153
    parameter                      shift and go to state 155

state 123

    (31) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER . LPAREN values RPAREN
    (33) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER . LPAREN RPAREN
    (80) value -> IDENTIFIER .

    LPAREN          shift and go to state 80
    EQUAL           reduce using rule 80 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 80 (value -> IDENTIFIER .)
    LESS            reduce using rule 80 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 80 (value -> IDENTIFIER .)
    GREATER         reduce using rule 80 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 80 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 80 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 80 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 80 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 80 (value -> IDENTIFIER .)
    $end            reduce using rule 80 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 80 (value -> IDENTIFIER .)
    PRINT           reduce using rule 80 (value -> IDENTIFIER .)
    IF              reduce using rule 80 (value -> IDENTIFIER .)
    WHILE           reduce using rule 80 (value -> IDENTIFIER .)
    FOR             reduce using rule 80 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 80 (value -> IDENTIFIER .)
    LATE            reduce using rule 80 (value -> IDENTIFIER .)
    FINAL           reduce using rule 80 (value -> IDENTIFIER .)
    CONST           reduce using rule 80 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 80 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 80 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 80 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 80 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 80 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 80 (value -> IDENTIFIER .)
    VAR             reduce using rule 80 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 80 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 80 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 80 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 80 (value -> IDENTIFIER .)
    VOID            reduce using rule 80 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 80 (value -> IDENTIFIER .)


state 124

    (17) reassignment -> IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 156


state 125

    (50) expression -> function_call .

    SEMICOLON       reduce using rule 50 (expression -> function_call .)
    RPAREN          reduce using rule 50 (expression -> function_call .)
    $end            reduce using rule 50 (expression -> function_call .)
    LINE_BREAK      reduce using rule 50 (expression -> function_call .)
    PRINT           reduce using rule 50 (expression -> function_call .)
    IF              reduce using rule 50 (expression -> function_call .)
    WHILE           reduce using rule 50 (expression -> function_call .)
    FOR             reduce using rule 50 (expression -> function_call .)
    IDENTIFIER      reduce using rule 50 (expression -> function_call .)
    LATE            reduce using rule 50 (expression -> function_call .)
    FINAL           reduce using rule 50 (expression -> function_call .)
    CONST           reduce using rule 50 (expression -> function_call .)
    INTEGER_TYPE    reduce using rule 50 (expression -> function_call .)
    DOUBLE_TYPE     reduce using rule 50 (expression -> function_call .)
    BOOLEAN_TYPE    reduce using rule 50 (expression -> function_call .)
    QUEUE_TYPE      reduce using rule 50 (expression -> function_call .)
    STRING_TYPE     reduce using rule 50 (expression -> function_call .)
    ENUM_TYPE       reduce using rule 50 (expression -> function_call .)
    VAR             reduce using rule 50 (expression -> function_call .)
    LIST_TYPE       reduce using rule 50 (expression -> function_call .)
    MAP_TYPE        reduce using rule 50 (expression -> function_call .)
    SET_TYPE        reduce using rule 50 (expression -> function_call .)
    DYNAMIC_TYPE    reduce using rule 50 (expression -> function_call .)
    VOID            reduce using rule 50 (expression -> function_call .)
    RBRACE          reduce using rule 50 (expression -> function_call .)


state 126

    (18) reassignment -> IDENTIFIER INLINE_ARITH number . SEMICOLON
    (20) reassignment -> IDENTIFIER INLINE_ARITH number .

    SEMICOLON       shift and go to state 157
    $end            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LINE_BREAK      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    PRINT           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IF              reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    WHILE           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FOR             reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IDENTIFIER      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LATE            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FINAL           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    CONST           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    INTEGER_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DOUBLE_TYPE     reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    BOOLEAN_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    QUEUE_TYPE      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    STRING_TYPE     reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    ENUM_TYPE       reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VAR             reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LIST_TYPE       reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    MAP_TYPE        reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    SET_TYPE        reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DYNAMIC_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VOID            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RBRACE          reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RPAREN          reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)


state 127

    (19) reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .

    $end            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LINE_BREAK      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    PRINT           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IF              reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    WHILE           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FOR             reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IDENTIFIER      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LATE            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FINAL           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    CONST           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    INTEGER_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    QUEUE_TYPE      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    STRING_TYPE     reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    ENUM_TYPE       reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VAR             reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LIST_TYPE       reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    MAP_TYPE        reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    SET_TYPE        reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VOID            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RBRACE          reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RPAREN          reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)


state 128

    (31) function_call -> IDENTIFIER LPAREN values . RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER LPAREN values . RPAREN

    RPAREN          shift and go to state 158


state 129

    (33) function_call -> IDENTIFIER LPAREN RPAREN . SEMICOLON
    (34) function_call -> IDENTIFIER LPAREN RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 159
    $end            reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LINE_BREAK      reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LATE            reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FINAL           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONST           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER_TYPE    reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE_TYPE     reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BOOLEAN_TYPE    reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    QUEUE_TYPE      reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING_TYPE     reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ENUM_TYPE       reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LIST_TYPE       reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MAP_TYPE        reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SET_TYPE        reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DYNAMIC_TYPE    reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VOID            reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .) ]


state 130

    (26) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 160


state 131

    (27) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 161


state 132

    (54) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (53) arithmetic -> arithmetic arith_op . arithmetic
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (84) number -> . INTEGER
    (85) number -> . DOUBLE

    LPAREN          shift and go to state 113
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47

    arithmetic                     shift and go to state 162
    number                         shift and go to state 112

state 133

    (58) concate -> LPAREN concate PLUS . concate RPAREN
    (57) concate -> concate PLUS . concate
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (86) string -> . STRING

    LPAREN          shift and go to state 116
    STRING          shift and go to state 48

    concate                        shift and go to state 163
    string                         shift and go to state 115

state 134

    (65) logic -> LPAREN logic logic_op . logic RPAREN
    (64) logic -> logic logic_op . logic
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 102
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    logic                          shift and go to state 164
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 135

    (62) comparison -> LPAREN comparison comp_op . comparison RPAREN
    (61) comparison -> comparison comp_op . comparison
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 143
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    comparison                     shift and go to state 165
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 136

    (28) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 166
    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

    logic_op                       shift and go to state 71

state 137

    (120) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 167
    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

    logic_op                       shift and go to state 71

state 138

    (121) for_statement -> FOR LPAREN assignment . SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    SEMICOLON       shift and go to state 168


state 139

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (22) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 169
    QUESTION_MARK   shift and go to state 77

    nullable                       shift and go to state 75

state 140

    (92) lines -> line LINE_BREAK lines .

    $end            reduce using rule 92 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 92 (lines -> line LINE_BREAK lines .)


state 141

    (55) division -> number DIVIDE number .

    $end            reduce using rule 55 (division -> number DIVIDE number .)
    SEMICOLON       reduce using rule 55 (division -> number DIVIDE number .)
    RPAREN          reduce using rule 55 (division -> number DIVIDE number .)
    LINE_BREAK      reduce using rule 55 (division -> number DIVIDE number .)
    PRINT           reduce using rule 55 (division -> number DIVIDE number .)
    IF              reduce using rule 55 (division -> number DIVIDE number .)
    WHILE           reduce using rule 55 (division -> number DIVIDE number .)
    FOR             reduce using rule 55 (division -> number DIVIDE number .)
    IDENTIFIER      reduce using rule 55 (division -> number DIVIDE number .)
    LATE            reduce using rule 55 (division -> number DIVIDE number .)
    FINAL           reduce using rule 55 (division -> number DIVIDE number .)
    CONST           reduce using rule 55 (division -> number DIVIDE number .)
    INTEGER_TYPE    reduce using rule 55 (division -> number DIVIDE number .)
    DOUBLE_TYPE     reduce using rule 55 (division -> number DIVIDE number .)
    BOOLEAN_TYPE    reduce using rule 55 (division -> number DIVIDE number .)
    QUEUE_TYPE      reduce using rule 55 (division -> number DIVIDE number .)
    STRING_TYPE     reduce using rule 55 (division -> number DIVIDE number .)
    ENUM_TYPE       reduce using rule 55 (division -> number DIVIDE number .)
    VAR             reduce using rule 55 (division -> number DIVIDE number .)
    LIST_TYPE       reduce using rule 55 (division -> number DIVIDE number .)
    MAP_TYPE        reduce using rule 55 (division -> number DIVIDE number .)
    SET_TYPE        reduce using rule 55 (division -> number DIVIDE number .)
    DYNAMIC_TYPE    reduce using rule 55 (division -> number DIVIDE number .)
    VOID            reduce using rule 55 (division -> number DIVIDE number .)
    RBRACE          reduce using rule 55 (division -> number DIVIDE number .)


state 142

    (61) comparison -> comparison comp_op comparison .
    (61) comparison -> comparison . comp_op comparison
    (72) comp_op -> . EQUAL
    (73) comp_op -> . NOT_EQUAL
    (74) comp_op -> . LESS
    (75) comp_op -> . LESS_EQUAL
    (76) comp_op -> . GREATER
    (77) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 61 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 61 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 61 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 61 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 61 (comparison -> comparison comp_op comparison .)
    LINE_BREAK      reduce using rule 61 (comparison -> comparison comp_op comparison .)
    PRINT           reduce using rule 61 (comparison -> comparison comp_op comparison .)
    IF              reduce using rule 61 (comparison -> comparison comp_op comparison .)
    WHILE           reduce using rule 61 (comparison -> comparison comp_op comparison .)
    FOR             reduce using rule 61 (comparison -> comparison comp_op comparison .)
    IDENTIFIER      reduce using rule 61 (comparison -> comparison comp_op comparison .)
    LATE            reduce using rule 61 (comparison -> comparison comp_op comparison .)
    FINAL           reduce using rule 61 (comparison -> comparison comp_op comparison .)
    CONST           reduce using rule 61 (comparison -> comparison comp_op comparison .)
    INTEGER_TYPE    reduce using rule 61 (comparison -> comparison comp_op comparison .)
    DOUBLE_TYPE     reduce using rule 61 (comparison -> comparison comp_op comparison .)
    BOOLEAN_TYPE    reduce using rule 61 (comparison -> comparison comp_op comparison .)
    QUEUE_TYPE      reduce using rule 61 (comparison -> comparison comp_op comparison .)
    STRING_TYPE     reduce using rule 61 (comparison -> comparison comp_op comparison .)
    ENUM_TYPE       reduce using rule 61 (comparison -> comparison comp_op comparison .)
    VAR             reduce using rule 61 (comparison -> comparison comp_op comparison .)
    LIST_TYPE       reduce using rule 61 (comparison -> comparison comp_op comparison .)
    MAP_TYPE        reduce using rule 61 (comparison -> comparison comp_op comparison .)
    SET_TYPE        reduce using rule 61 (comparison -> comparison comp_op comparison .)
    DYNAMIC_TYPE    reduce using rule 61 (comparison -> comparison comp_op comparison .)
    VOID            reduce using rule 61 (comparison -> comparison comp_op comparison .)
    RBRACE          reduce using rule 61 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    LESS            shift and go to state 97
    LESS_EQUAL      shift and go to state 98
    GREATER         shift and go to state 99
    GREATER_EQUAL   shift and go to state 100

  ! EQUAL           [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 94

state 143

    (62) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 143
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    comparison                     shift and go to state 170
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 144

    (90) list -> LSQUARE values RSQUARE .

    EQUAL           reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    LINE_BREAK      reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    PRINT           reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    IF              reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    WHILE           reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    FOR             reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    IDENTIFIER      reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    LATE            reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    FINAL           reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    CONST           reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    INTEGER_TYPE    reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    DOUBLE_TYPE     reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    QUEUE_TYPE      reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    STRING_TYPE     reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    ENUM_TYPE       reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    VAR             reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    LIST_TYPE       reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    MAP_TYPE        reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    SET_TYPE        reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    VOID            reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    RBRACE          reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 90 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 90 (list -> LSQUARE values RSQUARE .)


state 145

    (79) values -> value COMMA . values
    (78) values -> . value
    (79) values -> . value COMMA values
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 87
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    value                          shift and go to state 107
    values                         shift and go to state 171
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 146

    (30) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 172


state 147

    (12) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 173


state 148

    (14) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . concate
    (49) expression -> . logic
    (50) expression -> . function_call
    (51) expression -> . division
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (55) division -> . number DIVIDE number
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 123
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

    expression                     shift and go to state 174
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 125
    division                       shift and go to state 16
    number                         shift and go to state 27
    string                         shift and go to state 28
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 149

    (13) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . concate
    (49) expression -> . logic
    (50) expression -> . function_call
    (51) expression -> . division
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (55) division -> . number DIVIDE number
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 123
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

    expression                     shift and go to state 175
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 125
    division                       shift and go to state 16
    number                         shift and go to state 27
    string                         shift and go to state 28
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 150

    (15) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN expression .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 176
    $end            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LINE_BREAK      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    PRINT           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LATE            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FINAL           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    BOOLEAN_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    QUEUE_TYPE      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    ENUM_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LIST_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    MAP_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    SET_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DYNAMIC_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VOID            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)

  ! SEMICOLON       [ reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .) ]


state 151

    (109) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 177


state 152

    (110) parameter -> IDENTIFIER .

    COMMA           reduce using rule 110 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 110 (parameter -> IDENTIFIER .)


state 153

    (91) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 178


state 154

    (105) parameters -> VOID .
    (46) type -> VOID .

    RPAREN          reduce using rule 105 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 46 (type -> VOID .)


state 155

    (106) parameters -> parameter .
    (107) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 106 (parameters -> parameter .)
    COMMA           shift and go to state 179


state 156

    (17) reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 157

    (18) reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .

    $end            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LINE_BREAK      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    PRINT           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IF              reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    WHILE           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FOR             reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IDENTIFIER      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LATE            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FINAL           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    CONST           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    INTEGER_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    QUEUE_TYPE      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    STRING_TYPE     reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    ENUM_TYPE       reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VAR             reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LIST_TYPE       reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    MAP_TYPE        reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    SET_TYPE        reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VOID            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RBRACE          reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RPAREN          reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)


state 158

    (31) function_call -> IDENTIFIER LPAREN values RPAREN . SEMICOLON
    (32) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 180
    $end            reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LINE_BREAK      reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PRINT           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    WHILE           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LATE            reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FINAL           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER_TYPE    reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE_TYPE     reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN_TYPE    reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    QUEUE_TYPE      reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING_TYPE     reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    ENUM_TYPE       reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LIST_TYPE       reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    MAP_TYPE        reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SET_TYPE        reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DYNAMIC_TYPE    reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VOID            reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RBRACE          reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RPAREN          reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! SEMICOLON       [ reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .) ]


state 159

    (33) function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LATE            reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)


state 160

    (26) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 181


state 161

    (27) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LATE            reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 162

    (54) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (53) arithmetic -> arithmetic arith_op arithmetic .
    (53) arithmetic -> arithmetic . arith_op arithmetic
    (69) arith_op -> . PLUS
    (70) arith_op -> . MINUS
    (71) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    RPAREN          shift and go to state 182
    PLUS            shift and go to state 67
    MINUS           shift and go to state 68
    TIMES           shift and go to state 69

  ! PLUS            [ reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 53 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 66

state 163

    (58) concate -> LPAREN concate PLUS concate . RPAREN
    (57) concate -> concate PLUS concate .
    (57) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 183
    PLUS            shift and go to state 70

  ! PLUS            [ reduce using rule 57 (concate -> concate PLUS concate .) ]


state 164

    (65) logic -> LPAREN logic logic_op logic . RPAREN
    (64) logic -> logic logic_op logic .
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 184
    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

  ! LOGICAL_AND     [ reduce using rule 64 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 64 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 71

state 165

    (62) comparison -> LPAREN comparison comp_op comparison . RPAREN
    (61) comparison -> comparison comp_op comparison .
    (61) comparison -> comparison . comp_op comparison
    (72) comp_op -> . EQUAL
    (73) comp_op -> . NOT_EQUAL
    (74) comp_op -> . LESS
    (75) comp_op -> . LESS_EQUAL
    (76) comp_op -> . GREATER
    (77) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    RPAREN          shift and go to state 185
    LOGICAL_AND     reduce using rule 61 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 61 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    LESS            shift and go to state 97
    LESS_EQUAL      shift and go to state 98
    GREATER         shift and go to state 99
    GREATER_EQUAL   shift and go to state 100

  ! EQUAL           [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 61 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 94

state 166

    (28) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 186


state 167

    (120) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 187


state 168

    (121) for_statement -> FOR LPAREN assignment SEMICOLON . logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 102
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 87
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    LSQUARE         shift and go to state 54

    logic                          shift and go to state 188
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    number                         shift and go to state 103
    string                         shift and go to state 104
    list                           shift and go to state 51

state 169

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 121


state 170

    (62) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (61) comparison -> comparison . comp_op comparison
    (72) comp_op -> . EQUAL
    (73) comp_op -> . NOT_EQUAL
    (74) comp_op -> . LESS
    (75) comp_op -> . LESS_EQUAL
    (76) comp_op -> . GREATER
    (77) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    LESS            shift and go to state 97
    LESS_EQUAL      shift and go to state 98
    GREATER         shift and go to state 99
    GREATER_EQUAL   shift and go to state 100

    comp_op                        shift and go to state 135

state 171

    (79) values -> value COMMA values .

    RSQUARE         reduce using rule 79 (values -> value COMMA values .)
    RPAREN          reduce using rule 79 (values -> value COMMA values .)


state 172

    (30) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    WHILE           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FOR             reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LATE            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 173

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . concate
    (49) expression -> . logic
    (50) expression -> . function_call
    (51) expression -> . division
    (52) arithmetic -> . number
    (53) arithmetic -> . arithmetic arith_op arithmetic
    (54) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (56) concate -> . string
    (57) concate -> . concate PLUS concate
    (58) concate -> . LPAREN concate PLUS concate RPAREN
    (63) logic -> . comparison
    (64) logic -> . logic logic_op logic
    (65) logic -> . LPAREN logic logic_op logic RPAREN
    (66) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (55) division -> . number DIVIDE number
    (84) number -> . INTEGER
    (85) number -> . DOUBLE
    (86) string -> . STRING
    (59) comparison -> . value
    (60) comparison -> . boolean
    (61) comparison -> . comparison comp_op comparison
    (62) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (80) value -> . IDENTIFIER
    (81) value -> . number
    (82) value -> . string
    (83) value -> . list
    (87) boolean -> . TRUE
    (88) boolean -> . FALSE
    (89) list -> . LSQUARE RSQUARE
    (90) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 21
    LOGICAL_NOT     shift and go to state 30
    IDENTIFIER      shift and go to state 123
    INTEGER         shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 52
    FALSE           shift and go to state 53
    LSQUARE         shift and go to state 54

    expression                     shift and go to state 189
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 125
    division                       shift and go to state 16
    number                         shift and go to state 27
    string                         shift and go to state 28
    comparison                     shift and go to state 29
    value                          shift and go to state 49
    boolean                        shift and go to state 50
    list                           shift and go to state 51

state 174

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 190


state 175

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 191


state 176

    (15) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 177

    (109) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 109 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 109 (parameter -> type IDENTIFIER .)


state 178

    (91) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 192


state 179

    (107) parameters -> parameter COMMA . parameters
    (105) parameters -> . VOID
    (106) parameters -> . parameter
    (107) parameters -> . parameter COMMA parameters
    (108) parameters -> .
    (109) parameter -> . type IDENTIFIER
    (110) parameter -> . IDENTIFIER
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    VOID            shift and go to state 154
    RPAREN          reduce using rule 108 (parameters -> .)
    IDENTIFIER      shift and go to state 152
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44

    parameter                      shift and go to state 155
    parameters                     shift and go to state 193
    type                           shift and go to state 151

state 180

    (31) function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    WHILE           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LATE            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FINAL           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    CONST           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VOID            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RBRACE          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RPAREN          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)


state 181

    (26) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LATE            reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 182

    (54) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LINE_BREAK      reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    PRINT           reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IF              reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    WHILE           reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FOR             reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LATE            reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FINAL           reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    CONST           reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER_TYPE    reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE_TYPE     reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    QUEUE_TYPE      reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING_TYPE     reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    ENUM_TYPE       reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VAR             reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LIST_TYPE       reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MAP_TYPE        reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SET_TYPE        reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VOID            reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RBRACE          reduce using rule 54 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 183

    (58) concate -> LPAREN concate PLUS concate RPAREN .

    PLUS            reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    $end            reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    SEMICOLON       reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    RPAREN          reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    LINE_BREAK      reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    PRINT           reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    IF              reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    WHILE           reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    FOR             reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    IDENTIFIER      reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    LATE            reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    FINAL           reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    CONST           reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    INTEGER_TYPE    reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    DOUBLE_TYPE     reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    BOOLEAN_TYPE    reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    QUEUE_TYPE      reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    STRING_TYPE     reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    ENUM_TYPE       reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    VAR             reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    LIST_TYPE       reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    MAP_TYPE        reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    SET_TYPE        reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    DYNAMIC_TYPE    reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    VOID            reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)
    RBRACE          reduce using rule 58 (concate -> LPAREN concate PLUS concate RPAREN .)


state 184

    (65) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    LINE_BREAK      reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    PRINT           reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    IF              reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    WHILE           reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    FOR             reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    IDENTIFIER      reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    LATE            reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    FINAL           reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    CONST           reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER_TYPE    reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE_TYPE     reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    QUEUE_TYPE      reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING_TYPE     reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    ENUM_TYPE       reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    VAR             reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    LIST_TYPE       reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    MAP_TYPE        reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    SET_TYPE        reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    VOID            reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)
    RBRACE          reduce using rule 65 (logic -> LPAREN logic logic_op logic RPAREN .)


state 185

    (62) comparison -> LPAREN comparison comp_op comparison RPAREN .

    EQUAL           reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    NOT_EQUAL       reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS            reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS_EQUAL      reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER         reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER_EQUAL   reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_AND     reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_OR      reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    $end            reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SEMICOLON       reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RPAREN          reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LINE_BREAK      reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    PRINT           reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    IF              reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    WHILE           reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    FOR             reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    IDENTIFIER      reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LATE            reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    FINAL           reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    CONST           reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    INTEGER_TYPE    reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    DOUBLE_TYPE     reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    BOOLEAN_TYPE    reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    QUEUE_TYPE      reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    STRING_TYPE     reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    ENUM_TYPE       reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    VAR             reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LIST_TYPE       reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    MAP_TYPE        reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SET_TYPE        reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    DYNAMIC_TYPE    reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    VOID            reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RBRACE          reduce using rule 62 (comparison -> LPAREN comparison comp_op comparison RPAREN .)


state 186

    (28) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 26
    RBRACE          reduce using rule 96 (lines -> .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    lines                          shift and go to state 194
    line                           shift and go to state 25
    print                          shift and go to state 57
    assignment                     shift and go to state 58
    function                       shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    reassignment                   shift and go to state 64
    modifier                       shift and go to state 17
    type                           shift and go to state 18

state 187

    (120) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 26
    RBRACE          reduce using rule 96 (lines -> .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    lines                          shift and go to state 195
    line                           shift and go to state 25
    print                          shift and go to state 57
    assignment                     shift and go to state 58
    function                       shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    reassignment                   shift and go to state 64
    modifier                       shift and go to state 17
    type                           shift and go to state 18

state 188

    (121) for_statement -> FOR LPAREN assignment SEMICOLON logic . SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (64) logic -> logic . logic_op logic
    (67) logic_op -> . LOGICAL_AND
    (68) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 196
    LOGICAL_AND     shift and go to state 72
    LOGICAL_OR      shift and go to state 73

    logic_op                       shift and go to state 71

state 189

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 197


state 190

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 191

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 192

    (91) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 26
    RBRACE          reduce using rule 96 (lines -> .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    type                           shift and go to state 18
    lines                          shift and go to state 198
    line                           shift and go to state 25
    print                          shift and go to state 57
    assignment                     shift and go to state 58
    function                       shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    reassignment                   shift and go to state 64
    modifier                       shift and go to state 17

state 193

    (107) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 107 (parameters -> parameter COMMA parameters .)


state 194

    (28) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 199


state 195

    (120) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 200


state 196

    (121) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON . reassignment RPAREN LBRACE lines RBRACE
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH

    IDENTIFIER      shift and go to state 202

    reassignment                   shift and go to state 201

state 197

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 198

    (91) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 203


state 199

    (28) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 200

    (120) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 120 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 201

    (121) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 204


state 202

    (17) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (20) reassignment -> IDENTIFIER . INLINE_ARITH number
    (21) reassignment -> IDENTIFIER . INLINE_ARITH

    ASSIGN          shift and go to state 78
    INLINE_ARITH    shift and go to state 79


state 203

    (91) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 91 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 204

    (121) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 205


state 205

    (121) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE . lines RBRACE
    (92) lines -> . line LINE_BREAK lines
    (93) lines -> . line lines
    (94) lines -> . line
    (95) lines -> . LINE_BREAK
    (96) lines -> .
    (97) line -> . print
    (98) line -> . assignment
    (99) line -> . function
    (100) line -> . if_statement
    (101) line -> . while_statement
    (102) line -> . for_statement
    (103) line -> . function_call
    (104) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (91) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (120) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (121) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 26
    RBRACE          reduce using rule 96 (lines -> .)
    PRINT           shift and go to state 20
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IDENTIFIER      shift and go to state 65
    LATE            shift and go to state 31
    FINAL           shift and go to state 32
    CONST           shift and go to state 33
    INTEGER_TYPE    shift and go to state 34
    DOUBLE_TYPE     shift and go to state 35
    BOOLEAN_TYPE    shift and go to state 36
    QUEUE_TYPE      shift and go to state 37
    STRING_TYPE     shift and go to state 38
    ENUM_TYPE       shift and go to state 39
    VAR             shift and go to state 40
    LIST_TYPE       shift and go to state 41
    MAP_TYPE        shift and go to state 42
    SET_TYPE        shift and go to state 43
    DYNAMIC_TYPE    shift and go to state 44
    VOID            shift and go to state 45

    assignment                     shift and go to state 58
    reassignment                   shift and go to state 64
    lines                          shift and go to state 206
    line                           shift and go to state 25
    print                          shift and go to state 57
    function                       shift and go to state 59
    if_statement                   shift and go to state 60
    while_statement                shift and go to state 61
    for_statement                  shift and go to state 62
    function_call                  shift and go to state 63
    modifier                       shift and go to state 17
    type                           shift and go to state 18

state 206

    (121) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 207


state 207

    (121) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 121 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 101 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 101 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 111 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 117 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 117 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 129 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for LESS in state 142 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 150 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 158 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 164 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 164 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 165 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 165 resolved as shift
WARNING: shift/reduce conflict for LESS in state 165 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 165 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 165 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 165 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (statement -> while_statement)
WARNING: rejected rule (line -> while_statement) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (statement -> for_statement)
WARNING: rejected rule (line -> for_statement) in state 8
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> reassignment)
WARNING: rejected rule (line -> reassignment) in state 11
WARNING: reduce/reduce conflict in state 15 resolved using rule (expression -> function_call)
WARNING: rejected rule (line -> function_call) in state 15
WARNING: reduce/reduce conflict in state 25 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 25
WARNING: reduce/reduce conflict in state 27 resolved using rule (arithmetic -> number)
WARNING: rejected rule (value -> number) in state 27
WARNING: reduce/reduce conflict in state 28 resolved using rule (concate -> string)
WARNING: rejected rule (value -> string) in state 28
WARNING: reduce/reduce conflict in state 91 resolved using rule (lines -> LINE_BREAK)
WARNING: rejected rule (lines -> <empty>) in state 91
