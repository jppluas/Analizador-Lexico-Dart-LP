Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOT
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FINALLY
    FOR
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    IN
    INTERFACE
    IS
    KEYWORD
    LIBRARY
    NULL
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WHILE
    WITH
    YIELD

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> <empty>
Rule 7     assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 8     assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 9     assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 10    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 11    nullable -> QUESTION_MARK
Rule 12    modifier -> LATE
Rule 13    modifier -> FINAL
Rule 14    modifier -> CONST
Rule 15    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 16    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 17    if_statement -> IF LPAREN expression RPAREN LBRACE statement RBRACE
Rule 18    if_statement -> if_statement ELSE if_statement
Rule 19    if_statement -> if_statement ELSE LBRACE statement RBRACE
Rule 20    type -> INTEGER_TYPE
Rule 21    type -> DOUBLE_TYPE
Rule 22    type -> BOOLEAN_TYPE
Rule 23    type -> QUEUE_TYPE
Rule 24    type -> STRING_TYPE
Rule 25    type -> ENUM_TYPE
Rule 26    type -> VAR
Rule 27    type -> LIST_TYPE
Rule 28    type -> MAP_TYPE
Rule 29    type -> SET_TYPE
Rule 30    type -> DYNAMIC_TYPE
Rule 31    expression -> value
Rule 32    expression -> expression op expression
Rule 33    expression -> LPAREN expression op expression RPAREN
Rule 34    op -> arithmetic
Rule 35    op -> comparation
Rule 36    op -> logical
Rule 37    logical -> LOGICAL_AND
Rule 38    logical -> LOGICAL_OR
Rule 39    logical -> LOGICAL_NOT
Rule 40    arithmetic -> PLUS
Rule 41    arithmetic -> MINUS
Rule 42    arithmetic -> TIMES
Rule 43    arithmetic -> DIVIDE
Rule 44    comparation -> EQUAL
Rule 45    comparation -> NOT_EQUAL
Rule 46    comparation -> LESS
Rule 47    comparation -> LESS_EQUAL
Rule 48    comparation -> GREATER
Rule 49    comparation -> GREATER_EQUAL
Rule 50    values -> value
Rule 51    values -> value COMMA values
Rule 52    value -> IDENTIFIER
Rule 53    value -> INTEGER
Rule 54    value -> DOUBLE
Rule 55    value -> STRING
Rule 56    value -> TRUE
Rule 57    value -> FALSE
Rule 58    value -> list
Rule 59    list -> LSQUARE RSQUARE
Rule 60    list -> LSQUARE values RSQUARE
Rule 61    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE
Rule 62    parameters -> VOID
Rule 63    parameters -> parameter
Rule 64    parameters -> parameter COMMA parameters
Rule 65    parameters -> <empty>
Rule 66    parameter -> type IDENTIFIER

Terminals, with rules where they appear

ABSTRACT             : 
AS                   : 
ASSERT               : 
ASSIGN               : 7 8 9 10
ASYNC                : 
AWAIT                : 
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 22
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 51 64
COMMENT              : 
CONST                : 14
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 43
DO                   : 
DOT                  : 
DOUBLE               : 54
DOUBLE_TYPE          : 21
DYNAMIC_TYPE         : 30
ELSE                 : 18 19
ENUM                 : 
ENUM_TYPE            : 25
EQUAL                : 44
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FALSE                : 57
FINAL                : 13
FINALLY              : 
FOR                  : 
GET                  : 
GREATER              : 48
GREATER_EQUAL        : 49
HIDE                 : 
IDENTIFIER           : 7 8 9 10 52 61 66
IF                   : 17
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INTEGER              : 53
INTEGER_TYPE         : 20
INTERFACE            : 
IS                   : 
KEYWORD              : 
LATE                 : 12
LBRACE               : 17 19 61
LESS                 : 46
LESS_EQUAL           : 47
LIBRARY              : 
LIST_TYPE            : 27
LOGICAL_AND          : 37
LOGICAL_NOT          : 39
LOGICAL_OR           : 38
LPAREN               : 15 16 17 33 61
LSQUARE              : 59 60
MAP_TYPE             : 28
MINUS                : 41
NOT_EQUAL            : 45
NULL                 : 
ON                   : 
OPERATOR             : 
PART                 : 
PLUS                 : 40
PRINT                : 15 16
QUESTION_MARK        : 11
QUEUE_TYPE           : 23
RBRACE               : 17 19 61
RETHROW              : 
RETURN               : 
RPAREN               : 15 16 17 33 61
RSQUARE              : 59 60
SEMICOLON            : 7 8 9 10 15 16
SET                  : 
SET_TYPE             : 29
SHOW                 : 
STATIC               : 
STRING               : 55
STRING_TYPE          : 24
SUPER                : 
SWITCH               : 
SYNC                 : 
THROW                : 
TIMES                : 42
TRUE                 : 56
TRY                  : 
TYPEDEF              : 
VAR                  : 26
VOID                 : 62
WHILE                : 
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arithmetic           : 34
assignment           : 2
comparation          : 35
expression           : 1 7 8 9 10 15 17 32 32 33 33
function             : 4
if_statement         : 5 18 18 19
list                 : 58
logical              : 36
modifier             : 7 9
nullable             : 7 8
op                   : 32 33
parameter            : 63 64
parameters           : 61 64
print                : 3
statement            : 17 19 61 0
type                 : 7 8 9 10 61 66
value                : 31 50 51
values               : 51 60

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> .
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (7) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (8) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (15) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (16) print -> . PRINT LPAREN RPAREN SEMICOLON
    (61) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE
    (17) if_statement -> . IF LPAREN expression RPAREN LBRACE statement RBRACE
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . if_statement ELSE LBRACE statement RBRACE
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (12) modifier -> . LATE
    (13) modifier -> . FINAL
    (14) modifier -> . CONST
    (20) type -> . INTEGER_TYPE
    (21) type -> . DOUBLE_TYPE
    (22) type -> . BOOLEAN_TYPE
    (23) type -> . QUEUE_TYPE
    (24) type -> . STRING_TYPE
    (25) type -> . ENUM_TYPE
    (26) type -> . VAR
    (27) type -> . LIST_TYPE
    (28) type -> . MAP_TYPE
    (29) type -> . SET_TYPE
    (30) type -> . DYNAMIC_TYPE
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    $end            reduce using rule 6 (statement -> .)
    LPAREN          shift and go to state 8
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LATE            shift and go to state 20
    FINAL           shift and go to state 21
    CONST           shift and go to state 22
    INTEGER_TYPE    shift and go to state 23
    DOUBLE_TYPE     shift and go to state 24
    BOOLEAN_TYPE    shift and go to state 25
    QUEUE_TYPE      shift and go to state 26
    STRING_TYPE     shift and go to state 27
    ENUM_TYPE       shift and go to state 28
    VAR             shift and go to state 29
    LIST_TYPE       shift and go to state 30
    MAP_TYPE        shift and go to state 31
    SET_TYPE        shift and go to state 32
    DYNAMIC_TYPE    shift and go to state 33
    LSQUARE         shift and go to state 34

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    value                          shift and go to state 7
    modifier                       shift and go to state 9
    type                           shift and go to state 10
    list                           shift and go to state 19

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    $end            reduce using rule 1 (statement -> expression .)
    RBRACE          reduce using rule 1 (statement -> expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 3

    (2) statement -> assignment .

    $end            reduce using rule 2 (statement -> assignment .)
    RBRACE          reduce using rule 2 (statement -> assignment .)


state 4

    (3) statement -> print .

    $end            reduce using rule 3 (statement -> print .)
    RBRACE          reduce using rule 3 (statement -> print .)


state 5

    (4) statement -> function .

    $end            reduce using rule 4 (statement -> function .)
    RBRACE          reduce using rule 4 (statement -> function .)


state 6

    (5) statement -> if_statement .
    (18) if_statement -> if_statement . ELSE if_statement
    (19) if_statement -> if_statement . ELSE LBRACE statement RBRACE

    $end            reduce using rule 5 (statement -> if_statement .)
    RBRACE          reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 52


state 7

    (31) expression -> value .

    PLUS            reduce using rule 31 (expression -> value .)
    MINUS           reduce using rule 31 (expression -> value .)
    TIMES           reduce using rule 31 (expression -> value .)
    DIVIDE          reduce using rule 31 (expression -> value .)
    EQUAL           reduce using rule 31 (expression -> value .)
    NOT_EQUAL       reduce using rule 31 (expression -> value .)
    LESS            reduce using rule 31 (expression -> value .)
    LESS_EQUAL      reduce using rule 31 (expression -> value .)
    GREATER         reduce using rule 31 (expression -> value .)
    GREATER_EQUAL   reduce using rule 31 (expression -> value .)
    LOGICAL_AND     reduce using rule 31 (expression -> value .)
    LOGICAL_OR      reduce using rule 31 (expression -> value .)
    LOGICAL_NOT     reduce using rule 31 (expression -> value .)
    $end            reduce using rule 31 (expression -> value .)
    RPAREN          reduce using rule 31 (expression -> value .)
    RBRACE          reduce using rule 31 (expression -> value .)
    SEMICOLON       reduce using rule 31 (expression -> value .)


state 8

    (33) expression -> LPAREN . expression op expression RPAREN
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 53
    value                          shift and go to state 7
    list                           shift and go to state 19

state 9

    (7) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (20) type -> . INTEGER_TYPE
    (21) type -> . DOUBLE_TYPE
    (22) type -> . BOOLEAN_TYPE
    (23) type -> . QUEUE_TYPE
    (24) type -> . STRING_TYPE
    (25) type -> . ENUM_TYPE
    (26) type -> . VAR
    (27) type -> . LIST_TYPE
    (28) type -> . MAP_TYPE
    (29) type -> . SET_TYPE
    (30) type -> . DYNAMIC_TYPE

    INTEGER_TYPE    shift and go to state 23
    DOUBLE_TYPE     shift and go to state 24
    BOOLEAN_TYPE    shift and go to state 25
    QUEUE_TYPE      shift and go to state 26
    STRING_TYPE     shift and go to state 27
    ENUM_TYPE       shift and go to state 28
    VAR             shift and go to state 29
    LIST_TYPE       shift and go to state 30
    MAP_TYPE        shift and go to state 31
    SET_TYPE        shift and go to state 32
    DYNAMIC_TYPE    shift and go to state 33

    type                           shift and go to state 54

state 10

    (8) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (61) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE
    (11) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 56
    QUESTION_MARK   shift and go to state 57

    nullable                       shift and go to state 55

state 11

    (52) value -> IDENTIFIER .

    PLUS            reduce using rule 52 (value -> IDENTIFIER .)
    MINUS           reduce using rule 52 (value -> IDENTIFIER .)
    TIMES           reduce using rule 52 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 52 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 52 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 52 (value -> IDENTIFIER .)
    LESS            reduce using rule 52 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 52 (value -> IDENTIFIER .)
    GREATER         reduce using rule 52 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 52 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 52 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 52 (value -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 52 (value -> IDENTIFIER .)
    $end            reduce using rule 52 (value -> IDENTIFIER .)
    COMMA           reduce using rule 52 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 52 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 52 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 52 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 52 (value -> IDENTIFIER .)


state 12

    (15) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (16) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 58


state 13

    (17) if_statement -> IF . LPAREN expression RPAREN LBRACE statement RBRACE

    LPAREN          shift and go to state 59


state 14

    (53) value -> INTEGER .

    PLUS            reduce using rule 53 (value -> INTEGER .)
    MINUS           reduce using rule 53 (value -> INTEGER .)
    TIMES           reduce using rule 53 (value -> INTEGER .)
    DIVIDE          reduce using rule 53 (value -> INTEGER .)
    EQUAL           reduce using rule 53 (value -> INTEGER .)
    NOT_EQUAL       reduce using rule 53 (value -> INTEGER .)
    LESS            reduce using rule 53 (value -> INTEGER .)
    LESS_EQUAL      reduce using rule 53 (value -> INTEGER .)
    GREATER         reduce using rule 53 (value -> INTEGER .)
    GREATER_EQUAL   reduce using rule 53 (value -> INTEGER .)
    LOGICAL_AND     reduce using rule 53 (value -> INTEGER .)
    LOGICAL_OR      reduce using rule 53 (value -> INTEGER .)
    LOGICAL_NOT     reduce using rule 53 (value -> INTEGER .)
    $end            reduce using rule 53 (value -> INTEGER .)
    COMMA           reduce using rule 53 (value -> INTEGER .)
    RSQUARE         reduce using rule 53 (value -> INTEGER .)
    RPAREN          reduce using rule 53 (value -> INTEGER .)
    RBRACE          reduce using rule 53 (value -> INTEGER .)
    SEMICOLON       reduce using rule 53 (value -> INTEGER .)


state 15

    (54) value -> DOUBLE .

    PLUS            reduce using rule 54 (value -> DOUBLE .)
    MINUS           reduce using rule 54 (value -> DOUBLE .)
    TIMES           reduce using rule 54 (value -> DOUBLE .)
    DIVIDE          reduce using rule 54 (value -> DOUBLE .)
    EQUAL           reduce using rule 54 (value -> DOUBLE .)
    NOT_EQUAL       reduce using rule 54 (value -> DOUBLE .)
    LESS            reduce using rule 54 (value -> DOUBLE .)
    LESS_EQUAL      reduce using rule 54 (value -> DOUBLE .)
    GREATER         reduce using rule 54 (value -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 54 (value -> DOUBLE .)
    LOGICAL_AND     reduce using rule 54 (value -> DOUBLE .)
    LOGICAL_OR      reduce using rule 54 (value -> DOUBLE .)
    LOGICAL_NOT     reduce using rule 54 (value -> DOUBLE .)
    $end            reduce using rule 54 (value -> DOUBLE .)
    COMMA           reduce using rule 54 (value -> DOUBLE .)
    RSQUARE         reduce using rule 54 (value -> DOUBLE .)
    RPAREN          reduce using rule 54 (value -> DOUBLE .)
    RBRACE          reduce using rule 54 (value -> DOUBLE .)
    SEMICOLON       reduce using rule 54 (value -> DOUBLE .)


state 16

    (55) value -> STRING .

    PLUS            reduce using rule 55 (value -> STRING .)
    MINUS           reduce using rule 55 (value -> STRING .)
    TIMES           reduce using rule 55 (value -> STRING .)
    DIVIDE          reduce using rule 55 (value -> STRING .)
    EQUAL           reduce using rule 55 (value -> STRING .)
    NOT_EQUAL       reduce using rule 55 (value -> STRING .)
    LESS            reduce using rule 55 (value -> STRING .)
    LESS_EQUAL      reduce using rule 55 (value -> STRING .)
    GREATER         reduce using rule 55 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 55 (value -> STRING .)
    LOGICAL_AND     reduce using rule 55 (value -> STRING .)
    LOGICAL_OR      reduce using rule 55 (value -> STRING .)
    LOGICAL_NOT     reduce using rule 55 (value -> STRING .)
    $end            reduce using rule 55 (value -> STRING .)
    COMMA           reduce using rule 55 (value -> STRING .)
    RSQUARE         reduce using rule 55 (value -> STRING .)
    RPAREN          reduce using rule 55 (value -> STRING .)
    RBRACE          reduce using rule 55 (value -> STRING .)
    SEMICOLON       reduce using rule 55 (value -> STRING .)


state 17

    (56) value -> TRUE .

    PLUS            reduce using rule 56 (value -> TRUE .)
    MINUS           reduce using rule 56 (value -> TRUE .)
    TIMES           reduce using rule 56 (value -> TRUE .)
    DIVIDE          reduce using rule 56 (value -> TRUE .)
    EQUAL           reduce using rule 56 (value -> TRUE .)
    NOT_EQUAL       reduce using rule 56 (value -> TRUE .)
    LESS            reduce using rule 56 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 56 (value -> TRUE .)
    GREATER         reduce using rule 56 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 56 (value -> TRUE .)
    LOGICAL_AND     reduce using rule 56 (value -> TRUE .)
    LOGICAL_OR      reduce using rule 56 (value -> TRUE .)
    LOGICAL_NOT     reduce using rule 56 (value -> TRUE .)
    $end            reduce using rule 56 (value -> TRUE .)
    COMMA           reduce using rule 56 (value -> TRUE .)
    RSQUARE         reduce using rule 56 (value -> TRUE .)
    RPAREN          reduce using rule 56 (value -> TRUE .)
    RBRACE          reduce using rule 56 (value -> TRUE .)
    SEMICOLON       reduce using rule 56 (value -> TRUE .)


state 18

    (57) value -> FALSE .

    PLUS            reduce using rule 57 (value -> FALSE .)
    MINUS           reduce using rule 57 (value -> FALSE .)
    TIMES           reduce using rule 57 (value -> FALSE .)
    DIVIDE          reduce using rule 57 (value -> FALSE .)
    EQUAL           reduce using rule 57 (value -> FALSE .)
    NOT_EQUAL       reduce using rule 57 (value -> FALSE .)
    LESS            reduce using rule 57 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 57 (value -> FALSE .)
    GREATER         reduce using rule 57 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 57 (value -> FALSE .)
    LOGICAL_AND     reduce using rule 57 (value -> FALSE .)
    LOGICAL_OR      reduce using rule 57 (value -> FALSE .)
    LOGICAL_NOT     reduce using rule 57 (value -> FALSE .)
    $end            reduce using rule 57 (value -> FALSE .)
    COMMA           reduce using rule 57 (value -> FALSE .)
    RSQUARE         reduce using rule 57 (value -> FALSE .)
    RPAREN          reduce using rule 57 (value -> FALSE .)
    RBRACE          reduce using rule 57 (value -> FALSE .)
    SEMICOLON       reduce using rule 57 (value -> FALSE .)


state 19

    (58) value -> list .

    PLUS            reduce using rule 58 (value -> list .)
    MINUS           reduce using rule 58 (value -> list .)
    TIMES           reduce using rule 58 (value -> list .)
    DIVIDE          reduce using rule 58 (value -> list .)
    EQUAL           reduce using rule 58 (value -> list .)
    NOT_EQUAL       reduce using rule 58 (value -> list .)
    LESS            reduce using rule 58 (value -> list .)
    LESS_EQUAL      reduce using rule 58 (value -> list .)
    GREATER         reduce using rule 58 (value -> list .)
    GREATER_EQUAL   reduce using rule 58 (value -> list .)
    LOGICAL_AND     reduce using rule 58 (value -> list .)
    LOGICAL_OR      reduce using rule 58 (value -> list .)
    LOGICAL_NOT     reduce using rule 58 (value -> list .)
    $end            reduce using rule 58 (value -> list .)
    COMMA           reduce using rule 58 (value -> list .)
    RSQUARE         reduce using rule 58 (value -> list .)
    RPAREN          reduce using rule 58 (value -> list .)
    RBRACE          reduce using rule 58 (value -> list .)
    SEMICOLON       reduce using rule 58 (value -> list .)


state 20

    (12) modifier -> LATE .

    INTEGER_TYPE    reduce using rule 12 (modifier -> LATE .)
    DOUBLE_TYPE     reduce using rule 12 (modifier -> LATE .)
    BOOLEAN_TYPE    reduce using rule 12 (modifier -> LATE .)
    QUEUE_TYPE      reduce using rule 12 (modifier -> LATE .)
    STRING_TYPE     reduce using rule 12 (modifier -> LATE .)
    ENUM_TYPE       reduce using rule 12 (modifier -> LATE .)
    VAR             reduce using rule 12 (modifier -> LATE .)
    LIST_TYPE       reduce using rule 12 (modifier -> LATE .)
    MAP_TYPE        reduce using rule 12 (modifier -> LATE .)
    SET_TYPE        reduce using rule 12 (modifier -> LATE .)
    DYNAMIC_TYPE    reduce using rule 12 (modifier -> LATE .)


state 21

    (13) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 13 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 13 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 13 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 13 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 13 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 13 (modifier -> FINAL .)
    VAR             reduce using rule 13 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 13 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 13 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 13 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 13 (modifier -> FINAL .)


state 22

    (14) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 14 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 14 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 14 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 14 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 14 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 14 (modifier -> CONST .)
    VAR             reduce using rule 14 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 14 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 14 (modifier -> CONST .)
    SET_TYPE        reduce using rule 14 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 14 (modifier -> CONST .)


state 23

    (20) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 20 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 20 (type -> INTEGER_TYPE .)


state 24

    (21) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 21 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 21 (type -> DOUBLE_TYPE .)


state 25

    (22) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 22 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 22 (type -> BOOLEAN_TYPE .)


state 26

    (23) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 23 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 23 (type -> QUEUE_TYPE .)


state 27

    (24) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 24 (type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 24 (type -> STRING_TYPE .)


state 28

    (25) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 25 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 25 (type -> ENUM_TYPE .)


state 29

    (26) type -> VAR .

    IDENTIFIER      reduce using rule 26 (type -> VAR .)
    QUESTION_MARK   reduce using rule 26 (type -> VAR .)


state 30

    (27) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 27 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 27 (type -> LIST_TYPE .)


state 31

    (28) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 28 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 28 (type -> MAP_TYPE .)


state 32

    (29) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 29 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 29 (type -> SET_TYPE .)


state 33

    (30) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 30 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 30 (type -> DYNAMIC_TYPE .)


state 34

    (59) list -> LSQUARE . RSQUARE
    (60) list -> LSQUARE . values RSQUARE
    (50) values -> . value
    (51) values -> . value COMMA values
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 60
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    values                         shift and go to state 61
    value                          shift and go to state 62
    list                           shift and go to state 19

state 35

    (32) expression -> expression op . expression
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 63
    value                          shift and go to state 7
    list                           shift and go to state 19

state 36

    (34) op -> arithmetic .

    LPAREN          reduce using rule 34 (op -> arithmetic .)
    IDENTIFIER      reduce using rule 34 (op -> arithmetic .)
    INTEGER         reduce using rule 34 (op -> arithmetic .)
    DOUBLE          reduce using rule 34 (op -> arithmetic .)
    STRING          reduce using rule 34 (op -> arithmetic .)
    TRUE            reduce using rule 34 (op -> arithmetic .)
    FALSE           reduce using rule 34 (op -> arithmetic .)
    LSQUARE         reduce using rule 34 (op -> arithmetic .)


state 37

    (35) op -> comparation .

    LPAREN          reduce using rule 35 (op -> comparation .)
    IDENTIFIER      reduce using rule 35 (op -> comparation .)
    INTEGER         reduce using rule 35 (op -> comparation .)
    DOUBLE          reduce using rule 35 (op -> comparation .)
    STRING          reduce using rule 35 (op -> comparation .)
    TRUE            reduce using rule 35 (op -> comparation .)
    FALSE           reduce using rule 35 (op -> comparation .)
    LSQUARE         reduce using rule 35 (op -> comparation .)


state 38

    (36) op -> logical .

    LPAREN          reduce using rule 36 (op -> logical .)
    IDENTIFIER      reduce using rule 36 (op -> logical .)
    INTEGER         reduce using rule 36 (op -> logical .)
    DOUBLE          reduce using rule 36 (op -> logical .)
    STRING          reduce using rule 36 (op -> logical .)
    TRUE            reduce using rule 36 (op -> logical .)
    FALSE           reduce using rule 36 (op -> logical .)
    LSQUARE         reduce using rule 36 (op -> logical .)


state 39

    (40) arithmetic -> PLUS .

    LPAREN          reduce using rule 40 (arithmetic -> PLUS .)
    IDENTIFIER      reduce using rule 40 (arithmetic -> PLUS .)
    INTEGER         reduce using rule 40 (arithmetic -> PLUS .)
    DOUBLE          reduce using rule 40 (arithmetic -> PLUS .)
    STRING          reduce using rule 40 (arithmetic -> PLUS .)
    TRUE            reduce using rule 40 (arithmetic -> PLUS .)
    FALSE           reduce using rule 40 (arithmetic -> PLUS .)
    LSQUARE         reduce using rule 40 (arithmetic -> PLUS .)


state 40

    (41) arithmetic -> MINUS .

    LPAREN          reduce using rule 41 (arithmetic -> MINUS .)
    IDENTIFIER      reduce using rule 41 (arithmetic -> MINUS .)
    INTEGER         reduce using rule 41 (arithmetic -> MINUS .)
    DOUBLE          reduce using rule 41 (arithmetic -> MINUS .)
    STRING          reduce using rule 41 (arithmetic -> MINUS .)
    TRUE            reduce using rule 41 (arithmetic -> MINUS .)
    FALSE           reduce using rule 41 (arithmetic -> MINUS .)
    LSQUARE         reduce using rule 41 (arithmetic -> MINUS .)


state 41

    (42) arithmetic -> TIMES .

    LPAREN          reduce using rule 42 (arithmetic -> TIMES .)
    IDENTIFIER      reduce using rule 42 (arithmetic -> TIMES .)
    INTEGER         reduce using rule 42 (arithmetic -> TIMES .)
    DOUBLE          reduce using rule 42 (arithmetic -> TIMES .)
    STRING          reduce using rule 42 (arithmetic -> TIMES .)
    TRUE            reduce using rule 42 (arithmetic -> TIMES .)
    FALSE           reduce using rule 42 (arithmetic -> TIMES .)
    LSQUARE         reduce using rule 42 (arithmetic -> TIMES .)


state 42

    (43) arithmetic -> DIVIDE .

    LPAREN          reduce using rule 43 (arithmetic -> DIVIDE .)
    IDENTIFIER      reduce using rule 43 (arithmetic -> DIVIDE .)
    INTEGER         reduce using rule 43 (arithmetic -> DIVIDE .)
    DOUBLE          reduce using rule 43 (arithmetic -> DIVIDE .)
    STRING          reduce using rule 43 (arithmetic -> DIVIDE .)
    TRUE            reduce using rule 43 (arithmetic -> DIVIDE .)
    FALSE           reduce using rule 43 (arithmetic -> DIVIDE .)
    LSQUARE         reduce using rule 43 (arithmetic -> DIVIDE .)


state 43

    (44) comparation -> EQUAL .

    LPAREN          reduce using rule 44 (comparation -> EQUAL .)
    IDENTIFIER      reduce using rule 44 (comparation -> EQUAL .)
    INTEGER         reduce using rule 44 (comparation -> EQUAL .)
    DOUBLE          reduce using rule 44 (comparation -> EQUAL .)
    STRING          reduce using rule 44 (comparation -> EQUAL .)
    TRUE            reduce using rule 44 (comparation -> EQUAL .)
    FALSE           reduce using rule 44 (comparation -> EQUAL .)
    LSQUARE         reduce using rule 44 (comparation -> EQUAL .)


state 44

    (45) comparation -> NOT_EQUAL .

    LPAREN          reduce using rule 45 (comparation -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 45 (comparation -> NOT_EQUAL .)
    INTEGER         reduce using rule 45 (comparation -> NOT_EQUAL .)
    DOUBLE          reduce using rule 45 (comparation -> NOT_EQUAL .)
    STRING          reduce using rule 45 (comparation -> NOT_EQUAL .)
    TRUE            reduce using rule 45 (comparation -> NOT_EQUAL .)
    FALSE           reduce using rule 45 (comparation -> NOT_EQUAL .)
    LSQUARE         reduce using rule 45 (comparation -> NOT_EQUAL .)


state 45

    (46) comparation -> LESS .

    LPAREN          reduce using rule 46 (comparation -> LESS .)
    IDENTIFIER      reduce using rule 46 (comparation -> LESS .)
    INTEGER         reduce using rule 46 (comparation -> LESS .)
    DOUBLE          reduce using rule 46 (comparation -> LESS .)
    STRING          reduce using rule 46 (comparation -> LESS .)
    TRUE            reduce using rule 46 (comparation -> LESS .)
    FALSE           reduce using rule 46 (comparation -> LESS .)
    LSQUARE         reduce using rule 46 (comparation -> LESS .)


state 46

    (47) comparation -> LESS_EQUAL .

    LPAREN          reduce using rule 47 (comparation -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 47 (comparation -> LESS_EQUAL .)
    INTEGER         reduce using rule 47 (comparation -> LESS_EQUAL .)
    DOUBLE          reduce using rule 47 (comparation -> LESS_EQUAL .)
    STRING          reduce using rule 47 (comparation -> LESS_EQUAL .)
    TRUE            reduce using rule 47 (comparation -> LESS_EQUAL .)
    FALSE           reduce using rule 47 (comparation -> LESS_EQUAL .)
    LSQUARE         reduce using rule 47 (comparation -> LESS_EQUAL .)


state 47

    (48) comparation -> GREATER .

    LPAREN          reduce using rule 48 (comparation -> GREATER .)
    IDENTIFIER      reduce using rule 48 (comparation -> GREATER .)
    INTEGER         reduce using rule 48 (comparation -> GREATER .)
    DOUBLE          reduce using rule 48 (comparation -> GREATER .)
    STRING          reduce using rule 48 (comparation -> GREATER .)
    TRUE            reduce using rule 48 (comparation -> GREATER .)
    FALSE           reduce using rule 48 (comparation -> GREATER .)
    LSQUARE         reduce using rule 48 (comparation -> GREATER .)


state 48

    (49) comparation -> GREATER_EQUAL .

    LPAREN          reduce using rule 49 (comparation -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 49 (comparation -> GREATER_EQUAL .)
    INTEGER         reduce using rule 49 (comparation -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 49 (comparation -> GREATER_EQUAL .)
    STRING          reduce using rule 49 (comparation -> GREATER_EQUAL .)
    TRUE            reduce using rule 49 (comparation -> GREATER_EQUAL .)
    FALSE           reduce using rule 49 (comparation -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 49 (comparation -> GREATER_EQUAL .)


state 49

    (37) logical -> LOGICAL_AND .

    LPAREN          reduce using rule 37 (logical -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 37 (logical -> LOGICAL_AND .)
    INTEGER         reduce using rule 37 (logical -> LOGICAL_AND .)
    DOUBLE          reduce using rule 37 (logical -> LOGICAL_AND .)
    STRING          reduce using rule 37 (logical -> LOGICAL_AND .)
    TRUE            reduce using rule 37 (logical -> LOGICAL_AND .)
    FALSE           reduce using rule 37 (logical -> LOGICAL_AND .)
    LSQUARE         reduce using rule 37 (logical -> LOGICAL_AND .)


state 50

    (38) logical -> LOGICAL_OR .

    LPAREN          reduce using rule 38 (logical -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 38 (logical -> LOGICAL_OR .)
    INTEGER         reduce using rule 38 (logical -> LOGICAL_OR .)
    DOUBLE          reduce using rule 38 (logical -> LOGICAL_OR .)
    STRING          reduce using rule 38 (logical -> LOGICAL_OR .)
    TRUE            reduce using rule 38 (logical -> LOGICAL_OR .)
    FALSE           reduce using rule 38 (logical -> LOGICAL_OR .)
    LSQUARE         reduce using rule 38 (logical -> LOGICAL_OR .)


state 51

    (39) logical -> LOGICAL_NOT .

    LPAREN          reduce using rule 39 (logical -> LOGICAL_NOT .)
    IDENTIFIER      reduce using rule 39 (logical -> LOGICAL_NOT .)
    INTEGER         reduce using rule 39 (logical -> LOGICAL_NOT .)
    DOUBLE          reduce using rule 39 (logical -> LOGICAL_NOT .)
    STRING          reduce using rule 39 (logical -> LOGICAL_NOT .)
    TRUE            reduce using rule 39 (logical -> LOGICAL_NOT .)
    FALSE           reduce using rule 39 (logical -> LOGICAL_NOT .)
    LSQUARE         reduce using rule 39 (logical -> LOGICAL_NOT .)


state 52

    (18) if_statement -> if_statement ELSE . if_statement
    (19) if_statement -> if_statement ELSE . LBRACE statement RBRACE
    (17) if_statement -> . IF LPAREN expression RPAREN LBRACE statement RBRACE
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . if_statement ELSE LBRACE statement RBRACE

    LBRACE          shift and go to state 65
    IF              shift and go to state 13

    if_statement                   shift and go to state 64

state 53

    (33) expression -> LPAREN expression . op expression RPAREN
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 66
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 54

    (7) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (11) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 68
    QUESTION_MARK   shift and go to state 57

    nullable                       shift and go to state 67

state 55

    (8) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 69


state 56

    (10) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (61) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE statement RBRACE

    ASSIGN          shift and go to state 70
    LPAREN          shift and go to state 71


state 57

    (11) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 11 (nullable -> QUESTION_MARK .)


state 58

    (15) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (16) print -> PRINT LPAREN . RPAREN SEMICOLON
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 73
    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 72
    value                          shift and go to state 7
    list                           shift and go to state 19

state 59

    (17) if_statement -> IF LPAREN . expression RPAREN LBRACE statement RBRACE
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 74
    value                          shift and go to state 7
    list                           shift and go to state 19

state 60

    (59) list -> LSQUARE RSQUARE .

    PLUS            reduce using rule 59 (list -> LSQUARE RSQUARE .)
    MINUS           reduce using rule 59 (list -> LSQUARE RSQUARE .)
    TIMES           reduce using rule 59 (list -> LSQUARE RSQUARE .)
    DIVIDE          reduce using rule 59 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 59 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 59 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 59 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 59 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 59 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 59 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 59 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 59 (list -> LSQUARE RSQUARE .)
    LOGICAL_NOT     reduce using rule 59 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 59 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 59 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 59 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 59 (list -> LSQUARE RSQUARE .)
    RBRACE          reduce using rule 59 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 59 (list -> LSQUARE RSQUARE .)


state 61

    (60) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 75


state 62

    (50) values -> value .
    (51) values -> value . COMMA values

    RSQUARE         reduce using rule 50 (values -> value .)
    COMMA           shift and go to state 76


state 63

    (32) expression -> expression op expression .
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_NOT resolved as shift
    $end            reduce using rule 32 (expression -> expression op expression .)
    RPAREN          reduce using rule 32 (expression -> expression op expression .)
    RBRACE          reduce using rule 32 (expression -> expression op expression .)
    SEMICOLON       reduce using rule 32 (expression -> expression op expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

  ! PLUS            [ reduce using rule 32 (expression -> expression op expression .) ]
  ! MINUS           [ reduce using rule 32 (expression -> expression op expression .) ]
  ! TIMES           [ reduce using rule 32 (expression -> expression op expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression op expression .) ]
  ! EQUAL           [ reduce using rule 32 (expression -> expression op expression .) ]
  ! NOT_EQUAL       [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LESS            [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LESS_EQUAL      [ reduce using rule 32 (expression -> expression op expression .) ]
  ! GREATER         [ reduce using rule 32 (expression -> expression op expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LOGICAL_AND     [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LOGICAL_OR      [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LOGICAL_NOT     [ reduce using rule 32 (expression -> expression op expression .) ]

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 64

    (18) if_statement -> if_statement ELSE if_statement .
    (18) if_statement -> if_statement . ELSE if_statement
    (19) if_statement -> if_statement . ELSE LBRACE statement RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 18 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 18 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 52

  ! ELSE            [ reduce using rule 18 (if_statement -> if_statement ELSE if_statement .) ]


state 65

    (19) if_statement -> if_statement ELSE LBRACE . statement RBRACE
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> .
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (7) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (8) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (15) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (16) print -> . PRINT LPAREN RPAREN SEMICOLON
    (61) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE
    (17) if_statement -> . IF LPAREN expression RPAREN LBRACE statement RBRACE
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . if_statement ELSE LBRACE statement RBRACE
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (12) modifier -> . LATE
    (13) modifier -> . FINAL
    (14) modifier -> . CONST
    (20) type -> . INTEGER_TYPE
    (21) type -> . DOUBLE_TYPE
    (22) type -> . BOOLEAN_TYPE
    (23) type -> . QUEUE_TYPE
    (24) type -> . STRING_TYPE
    (25) type -> . ENUM_TYPE
    (26) type -> . VAR
    (27) type -> . LIST_TYPE
    (28) type -> . MAP_TYPE
    (29) type -> . SET_TYPE
    (30) type -> . DYNAMIC_TYPE
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    RBRACE          reduce using rule 6 (statement -> .)
    LPAREN          shift and go to state 8
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LATE            shift and go to state 20
    FINAL           shift and go to state 21
    CONST           shift and go to state 22
    INTEGER_TYPE    shift and go to state 23
    DOUBLE_TYPE     shift and go to state 24
    BOOLEAN_TYPE    shift and go to state 25
    QUEUE_TYPE      shift and go to state 26
    STRING_TYPE     shift and go to state 27
    ENUM_TYPE       shift and go to state 28
    VAR             shift and go to state 29
    LIST_TYPE       shift and go to state 30
    MAP_TYPE        shift and go to state 31
    SET_TYPE        shift and go to state 32
    DYNAMIC_TYPE    shift and go to state 33
    LSQUARE         shift and go to state 34

    if_statement                   shift and go to state 6
    statement                      shift and go to state 77
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    value                          shift and go to state 7
    modifier                       shift and go to state 9
    type                           shift and go to state 10
    list                           shift and go to state 19

state 66

    (33) expression -> LPAREN expression op . expression RPAREN
    (32) expression -> expression op . expression
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 78
    value                          shift and go to state 7
    list                           shift and go to state 19

state 67

    (7) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 79


state 68

    (9) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 80


state 69

    (8) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 81


state 70

    (10) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 82
    value                          shift and go to state 7
    list                           shift and go to state 19

state 71

    (61) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE statement RBRACE
    (62) parameters -> . VOID
    (63) parameters -> . parameter
    (64) parameters -> . parameter COMMA parameters
    (65) parameters -> .
    (66) parameter -> . type IDENTIFIER
    (20) type -> . INTEGER_TYPE
    (21) type -> . DOUBLE_TYPE
    (22) type -> . BOOLEAN_TYPE
    (23) type -> . QUEUE_TYPE
    (24) type -> . STRING_TYPE
    (25) type -> . ENUM_TYPE
    (26) type -> . VAR
    (27) type -> . LIST_TYPE
    (28) type -> . MAP_TYPE
    (29) type -> . SET_TYPE
    (30) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 85
    RPAREN          reduce using rule 65 (parameters -> .)
    INTEGER_TYPE    shift and go to state 23
    DOUBLE_TYPE     shift and go to state 24
    BOOLEAN_TYPE    shift and go to state 25
    QUEUE_TYPE      shift and go to state 26
    STRING_TYPE     shift and go to state 27
    ENUM_TYPE       shift and go to state 28
    VAR             shift and go to state 29
    LIST_TYPE       shift and go to state 30
    MAP_TYPE        shift and go to state 31
    SET_TYPE        shift and go to state 32
    DYNAMIC_TYPE    shift and go to state 33

    type                           shift and go to state 83
    parameters                     shift and go to state 84
    parameter                      shift and go to state 86

state 72

    (15) print -> PRINT LPAREN expression . RPAREN SEMICOLON
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    RPAREN          shift and go to state 87
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 73

    (16) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 88


state 74

    (17) if_statement -> IF LPAREN expression . RPAREN LBRACE statement RBRACE
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    RPAREN          shift and go to state 89
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 75

    (60) list -> LSQUARE values RSQUARE .

    PLUS            reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    MINUS           reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    TIMES           reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    DIVIDE          reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    LOGICAL_NOT     reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    RBRACE          reduce using rule 60 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 60 (list -> LSQUARE values RSQUARE .)


state 76

    (51) values -> value COMMA . values
    (50) values -> . value
    (51) values -> . value COMMA values
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    value                          shift and go to state 62
    values                         shift and go to state 90
    list                           shift and go to state 19

state 77

    (19) if_statement -> if_statement ELSE LBRACE statement . RBRACE

    RBRACE          shift and go to state 91


state 78

    (33) expression -> LPAREN expression op expression . RPAREN
    (32) expression -> expression op expression .
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_NOT resolved as shift
    RPAREN          shift and go to state 92
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

  ! PLUS            [ reduce using rule 32 (expression -> expression op expression .) ]
  ! MINUS           [ reduce using rule 32 (expression -> expression op expression .) ]
  ! TIMES           [ reduce using rule 32 (expression -> expression op expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression op expression .) ]
  ! EQUAL           [ reduce using rule 32 (expression -> expression op expression .) ]
  ! NOT_EQUAL       [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LESS            [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LESS_EQUAL      [ reduce using rule 32 (expression -> expression op expression .) ]
  ! GREATER         [ reduce using rule 32 (expression -> expression op expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LOGICAL_AND     [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LOGICAL_OR      [ reduce using rule 32 (expression -> expression op expression .) ]
  ! LOGICAL_NOT     [ reduce using rule 32 (expression -> expression op expression .) ]

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 79

    (7) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 93


state 80

    (9) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 94
    value                          shift and go to state 7
    list                           shift and go to state 19

state 81

    (8) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 95
    value                          shift and go to state 7
    list                           shift and go to state 19

state 82

    (10) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    SEMICOLON       shift and go to state 96
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 83

    (66) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 97


state 84

    (61) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE statement RBRACE

    RPAREN          shift and go to state 98


state 85

    (62) parameters -> VOID .

    RPAREN          reduce using rule 62 (parameters -> VOID .)


state 86

    (63) parameters -> parameter .
    (64) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 63 (parameters -> parameter .)
    COMMA           shift and go to state 99


state 87

    (15) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 100


state 88

    (16) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 16 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 16 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 89

    (17) if_statement -> IF LPAREN expression RPAREN . LBRACE statement RBRACE

    LBRACE          shift and go to state 101


state 90

    (51) values -> value COMMA values .

    RSQUARE         reduce using rule 51 (values -> value COMMA values .)


state 91

    (19) if_statement -> if_statement ELSE LBRACE statement RBRACE .

    ELSE            reduce using rule 19 (if_statement -> if_statement ELSE LBRACE statement RBRACE .)
    $end            reduce using rule 19 (if_statement -> if_statement ELSE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 19 (if_statement -> if_statement ELSE LBRACE statement RBRACE .)


state 92

    (33) expression -> LPAREN expression op expression RPAREN .

    PLUS            reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    MINUS           reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    TIMES           reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    DIVIDE          reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    EQUAL           reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    NOT_EQUAL       reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    LESS            reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    LESS_EQUAL      reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    GREATER         reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    GREATER_EQUAL   reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    LOGICAL_AND     reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    LOGICAL_OR      reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    LOGICAL_NOT     reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    $end            reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    RPAREN          reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    RBRACE          reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)
    SEMICOLON       reduce using rule 33 (expression -> LPAREN expression op expression RPAREN .)


state 93

    (7) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 8
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 102
    value                          shift and go to state 7
    list                           shift and go to state 19

state 94

    (9) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    SEMICOLON       shift and go to state 103
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 95

    (8) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    SEMICOLON       shift and go to state 104
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 96

    (10) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 10 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 10 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 97

    (66) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 66 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 66 (parameter -> type IDENTIFIER .)


state 98

    (61) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE statement RBRACE

    LBRACE          shift and go to state 105


state 99

    (64) parameters -> parameter COMMA . parameters
    (62) parameters -> . VOID
    (63) parameters -> . parameter
    (64) parameters -> . parameter COMMA parameters
    (65) parameters -> .
    (66) parameter -> . type IDENTIFIER
    (20) type -> . INTEGER_TYPE
    (21) type -> . DOUBLE_TYPE
    (22) type -> . BOOLEAN_TYPE
    (23) type -> . QUEUE_TYPE
    (24) type -> . STRING_TYPE
    (25) type -> . ENUM_TYPE
    (26) type -> . VAR
    (27) type -> . LIST_TYPE
    (28) type -> . MAP_TYPE
    (29) type -> . SET_TYPE
    (30) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 85
    RPAREN          reduce using rule 65 (parameters -> .)
    INTEGER_TYPE    shift and go to state 23
    DOUBLE_TYPE     shift and go to state 24
    BOOLEAN_TYPE    shift and go to state 25
    QUEUE_TYPE      shift and go to state 26
    STRING_TYPE     shift and go to state 27
    ENUM_TYPE       shift and go to state 28
    VAR             shift and go to state 29
    LIST_TYPE       shift and go to state 30
    MAP_TYPE        shift and go to state 31
    SET_TYPE        shift and go to state 32
    DYNAMIC_TYPE    shift and go to state 33

    parameter                      shift and go to state 86
    parameters                     shift and go to state 106
    type                           shift and go to state 83

state 100

    (15) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 15 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 15 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 101

    (17) if_statement -> IF LPAREN expression RPAREN LBRACE . statement RBRACE
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> .
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (7) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (8) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (15) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (16) print -> . PRINT LPAREN RPAREN SEMICOLON
    (61) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE
    (17) if_statement -> . IF LPAREN expression RPAREN LBRACE statement RBRACE
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . if_statement ELSE LBRACE statement RBRACE
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (12) modifier -> . LATE
    (13) modifier -> . FINAL
    (14) modifier -> . CONST
    (20) type -> . INTEGER_TYPE
    (21) type -> . DOUBLE_TYPE
    (22) type -> . BOOLEAN_TYPE
    (23) type -> . QUEUE_TYPE
    (24) type -> . STRING_TYPE
    (25) type -> . ENUM_TYPE
    (26) type -> . VAR
    (27) type -> . LIST_TYPE
    (28) type -> . MAP_TYPE
    (29) type -> . SET_TYPE
    (30) type -> . DYNAMIC_TYPE
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    RBRACE          reduce using rule 6 (statement -> .)
    LPAREN          shift and go to state 8
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LATE            shift and go to state 20
    FINAL           shift and go to state 21
    CONST           shift and go to state 22
    INTEGER_TYPE    shift and go to state 23
    DOUBLE_TYPE     shift and go to state 24
    BOOLEAN_TYPE    shift and go to state 25
    QUEUE_TYPE      shift and go to state 26
    STRING_TYPE     shift and go to state 27
    ENUM_TYPE       shift and go to state 28
    VAR             shift and go to state 29
    LIST_TYPE       shift and go to state 30
    MAP_TYPE        shift and go to state 31
    SET_TYPE        shift and go to state 32
    DYNAMIC_TYPE    shift and go to state 33
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 2
    statement                      shift and go to state 107
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    value                          shift and go to state 7
    modifier                       shift and go to state 9
    type                           shift and go to state 10
    list                           shift and go to state 19

state 102

    (7) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON
    (32) expression -> expression . op expression
    (34) op -> . arithmetic
    (35) op -> . comparation
    (36) op -> . logical
    (40) arithmetic -> . PLUS
    (41) arithmetic -> . MINUS
    (42) arithmetic -> . TIMES
    (43) arithmetic -> . DIVIDE
    (44) comparation -> . EQUAL
    (45) comparation -> . NOT_EQUAL
    (46) comparation -> . LESS
    (47) comparation -> . LESS_EQUAL
    (48) comparation -> . GREATER
    (49) comparation -> . GREATER_EQUAL
    (37) logical -> . LOGICAL_AND
    (38) logical -> . LOGICAL_OR
    (39) logical -> . LOGICAL_NOT

    SEMICOLON       shift and go to state 108
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40
    TIMES           shift and go to state 41
    DIVIDE          shift and go to state 42
    EQUAL           shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS            shift and go to state 45
    LESS_EQUAL      shift and go to state 46
    GREATER         shift and go to state 47
    GREATER_EQUAL   shift and go to state 48
    LOGICAL_AND     shift and go to state 49
    LOGICAL_OR      shift and go to state 50
    LOGICAL_NOT     shift and go to state 51

    op                             shift and go to state 35
    arithmetic                     shift and go to state 36
    comparation                    shift and go to state 37
    logical                        shift and go to state 38

state 103

    (9) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 9 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 9 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 104

    (8) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 8 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 8 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 105

    (61) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . statement RBRACE
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> .
    (31) expression -> . value
    (32) expression -> . expression op expression
    (33) expression -> . LPAREN expression op expression RPAREN
    (7) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (8) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (15) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (16) print -> . PRINT LPAREN RPAREN SEMICOLON
    (61) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE
    (17) if_statement -> . IF LPAREN expression RPAREN LBRACE statement RBRACE
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . if_statement ELSE LBRACE statement RBRACE
    (52) value -> . IDENTIFIER
    (53) value -> . INTEGER
    (54) value -> . DOUBLE
    (55) value -> . STRING
    (56) value -> . TRUE
    (57) value -> . FALSE
    (58) value -> . list
    (12) modifier -> . LATE
    (13) modifier -> . FINAL
    (14) modifier -> . CONST
    (20) type -> . INTEGER_TYPE
    (21) type -> . DOUBLE_TYPE
    (22) type -> . BOOLEAN_TYPE
    (23) type -> . QUEUE_TYPE
    (24) type -> . STRING_TYPE
    (25) type -> . ENUM_TYPE
    (26) type -> . VAR
    (27) type -> . LIST_TYPE
    (28) type -> . MAP_TYPE
    (29) type -> . SET_TYPE
    (30) type -> . DYNAMIC_TYPE
    (59) list -> . LSQUARE RSQUARE
    (60) list -> . LSQUARE values RSQUARE

    RBRACE          reduce using rule 6 (statement -> .)
    LPAREN          shift and go to state 8
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    IDENTIFIER      shift and go to state 11
    INTEGER         shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    TRUE            shift and go to state 17
    FALSE           shift and go to state 18
    LATE            shift and go to state 20
    FINAL           shift and go to state 21
    CONST           shift and go to state 22
    INTEGER_TYPE    shift and go to state 23
    DOUBLE_TYPE     shift and go to state 24
    BOOLEAN_TYPE    shift and go to state 25
    QUEUE_TYPE      shift and go to state 26
    STRING_TYPE     shift and go to state 27
    ENUM_TYPE       shift and go to state 28
    VAR             shift and go to state 29
    LIST_TYPE       shift and go to state 30
    MAP_TYPE        shift and go to state 31
    SET_TYPE        shift and go to state 32
    DYNAMIC_TYPE    shift and go to state 33
    LSQUARE         shift and go to state 34

    type                           shift and go to state 10
    statement                      shift and go to state 109
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    value                          shift and go to state 7
    modifier                       shift and go to state 9
    list                           shift and go to state 19

state 106

    (64) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 64 (parameters -> parameter COMMA parameters .)


state 107

    (17) if_statement -> IF LPAREN expression RPAREN LBRACE statement . RBRACE

    RBRACE          shift and go to state 110


state 108

    (7) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 7 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 7 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 109

    (61) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE statement . RBRACE

    RBRACE          shift and go to state 111


state 110

    (17) if_statement -> IF LPAREN expression RPAREN LBRACE statement RBRACE .

    ELSE            reduce using rule 17 (if_statement -> IF LPAREN expression RPAREN LBRACE statement RBRACE .)
    $end            reduce using rule 17 (if_statement -> IF LPAREN expression RPAREN LBRACE statement RBRACE .)
    RBRACE          reduce using rule 17 (if_statement -> IF LPAREN expression RPAREN LBRACE statement RBRACE .)


state 111

    (61) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE .

    $end            reduce using rule 61 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE .)
    RBRACE          reduce using rule 61 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE statement RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 63 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 63 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for LESS in state 63 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 63 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 63 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 63 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_NOT in state 63 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 78 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 78 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 78 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for LESS in state 78 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 78 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 78 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 78 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_NOT in state 78 resolved as shift
