Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOT
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FINALLY
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    IN
    INTERFACE
    IS
    KEYWORD
    LIBRARY
    NULL
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> <empty>
Rule 11    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 12    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    nullable -> QUESTION_MARK
Rule 16    modifier -> LATE
Rule 17    modifier -> FINAL
Rule 18    modifier -> CONST
Rule 19    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 20    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 21    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 22    if_statement -> if_statement ELSE if_statement
Rule 23    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 24    function_call -> IDENTIFIER LPAREN parameters RPAREN SEMICOLON
Rule 25    type -> INTEGER_TYPE
Rule 26    type -> DOUBLE_TYPE
Rule 27    type -> BOOLEAN_TYPE
Rule 28    type -> QUEUE_TYPE
Rule 29    type -> STRING_TYPE
Rule 30    type -> ENUM_TYPE
Rule 31    type -> VAR
Rule 32    type -> LIST_TYPE
Rule 33    type -> MAP_TYPE
Rule 34    type -> SET_TYPE
Rule 35    type -> DYNAMIC_TYPE
Rule 36    type -> VOID
Rule 37    expression -> arithmetic
Rule 38    expression -> logic
Rule 39    expression -> function_call
Rule 40    arithmetic -> value
Rule 41    arithmetic -> arithmetic arith_op arithmetic
Rule 42    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 43    comparison -> value
Rule 44    comparison -> boolean
Rule 45    comparison -> comparison comp_op comparison
Rule 46    comparison -> LPAREN comparison comp_op comparison RPAREN
Rule 47    logic -> comparison
Rule 48    logic -> logic logic_op logic
Rule 49    logic -> LPAREN logic logic_op logic RPAREN
Rule 50    logic -> LOGICAL_NOT logic
Rule 51    logic_op -> LOGICAL_AND
Rule 52    logic_op -> LOGICAL_OR
Rule 53    arith_op -> PLUS
Rule 54    arith_op -> MINUS
Rule 55    arith_op -> TIMES
Rule 56    arith_op -> DIVIDE
Rule 57    comp_op -> EQUAL
Rule 58    comp_op -> NOT_EQUAL
Rule 59    comp_op -> LESS
Rule 60    comp_op -> LESS_EQUAL
Rule 61    comp_op -> GREATER
Rule 62    comp_op -> GREATER_EQUAL
Rule 63    values -> value
Rule 64    values -> value COMMA values
Rule 65    value -> IDENTIFIER
Rule 66    value -> number
Rule 67    value -> string
Rule 68    value -> list
Rule 69    number -> INTEGER
Rule 70    number -> DOUBLE
Rule 71    string -> STRING
Rule 72    boolean -> TRUE
Rule 73    boolean -> FALSE
Rule 74    list -> LSQUARE RSQUARE
Rule 75    list -> LSQUARE values RSQUARE
Rule 76    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 77    lines -> line LINE_BREAK lines
Rule 78    lines -> line lines
Rule 79    lines -> line
Rule 80    lines -> <empty>
Rule 81    line -> print
Rule 82    line -> assignment
Rule 83    line -> function
Rule 84    line -> if_statement
Rule 85    parameters -> VOID
Rule 86    parameters -> parameter
Rule 87    parameters -> parameter COMMA parameters
Rule 88    parameters -> <empty>
Rule 89    parameter -> type IDENTIFIER
Rule 90    parameter -> IDENTIFIER
Rule 91    map -> MAP_TYPE LESS type COMMA type GREATER
Rule 92    map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE values RSQUARE
Rule 93    map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE RSQUARE
Rule 94    set -> SET_TYPE LESS type GREATER
Rule 95    set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 96    set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 97    queue -> QUEUE_TYPE LESS type GREATER
Rule 98    queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 99    queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 100   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 101   for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
AS                   : 
ASSERT               : 
ASSIGN               : 11 12 13 14
ASYNC                : 
AWAIT                : 
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 27
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 64 87 91 92 93
COMMENT              : 
CONST                : 18
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 56
DO                   : 
DOT                  : 
DOUBLE               : 70
DOUBLE_TYPE          : 26
DYNAMIC_TYPE         : 35
ELSE                 : 22 23
ENUM                 : 
ENUM_TYPE            : 30
EQUAL                : 57
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FALSE                : 73
FINAL                : 17
FINALLY              : 
FOR                  : 101
GET                  : 
GREATER              : 61 91 92 93 94 95 96 97 98 99
GREATER_EQUAL        : 62
HIDE                 : 
IDENTIFIER           : 11 12 13 14 24 65 76 89 90
IF                   : 21
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INTEGER              : 69
INTEGER_TYPE         : 25
INTERFACE            : 
IS                   : 
KEYWORD              : 
LATE                 : 16
LBRACE               : 9 21 23 76 100 101
LESS                 : 59 91 92 93 94 95 96 97 98 99
LESS_EQUAL           : 60
LIBRARY              : 
LINE_BREAK           : 77
LIST_TYPE            : 32
LOGICAL_AND          : 51
LOGICAL_NOT          : 50
LOGICAL_OR           : 52
LPAREN               : 19 20 21 24 42 46 49 76 100 101
LSQUARE              : 74 75 92 93 95 96 98 99
MAP_TYPE             : 33 91 92 93
MINUS                : 54
NOT_EQUAL            : 58
NULL                 : 
ON                   : 
OPERATOR             : 
PART                 : 
PLUS                 : 53
PRINT                : 19 20
QUESTION_MARK        : 15
QUEUE_TYPE           : 28 97 98 99
RBRACE               : 9 21 23 76 100 101
RETHROW              : 
RETURN               : 
RPAREN               : 19 20 21 24 42 46 49 76 100 101
RSQUARE              : 74 75 92 93 95 96 98 99
SEMICOLON            : 11 12 13 14 19 20 24 101 101
SET                  : 
SET_TYPE             : 34 94 95 96
SHOW                 : 
STATIC               : 
STRING               : 71
STRING_TYPE          : 29
SUPER                : 
SWITCH               : 
SYNC                 : 
THROW                : 
TIMES                : 55
TRUE                 : 72
TRY                  : 
TYPEDEF              : 
VAR                  : 31
VOID                 : 36 85
WHILE                : 100
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 41 42
arithmetic           : 37 41 41 42 42
assignment           : 2 82 101 101
boolean              : 44
comp_op              : 45 46
comparison           : 45 45 46 46 47
expression           : 1 11 12 13 14 19
for_statement        : 7
function             : 4 83
function_call        : 39
if_statement         : 5 22 22 23 84
line                 : 77 78 79
lines                : 8 9 21 23 76 77 78 100 101
list                 : 68
logic                : 21 38 48 48 49 49 50 100 101
logic_op             : 48 49
map                  : 
modifier             : 11 13
nullable             : 11 12
number               : 66
parameter            : 86 87
parameters           : 24 76 87
print                : 3 81
queue                : 
set                  : 
statement            : 0
string               : 67
type                 : 11 12 13 14 76 89 91 91 92 92 93 93 94 95 96 97 98 99
value                : 40 43 63 64
values               : 64 75 92 95 98
while_statement      : 6

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> .
    (37) expression -> . arithmetic
    (38) expression -> . logic
    (39) expression -> . function_call
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (100) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (101) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines RBRACE
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (24) function_call -> . IDENTIFIER LPAREN parameters RPAREN SEMICOLON
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> .)
    LBRACE          shift and go to state 10
    $end            reduce using rule 10 (statement -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    FOR             shift and go to state 21
    LPAREN          shift and go to state 18
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 16
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! $end            [ reduce using rule 80 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    arithmetic                     shift and go to state 11
    logic                          shift and go to state 12
    function_call                  shift and go to state 13
    modifier                       shift and go to state 14
    type                           shift and go to state 15
    line                           shift and go to state 22
    value                          shift and go to state 23
    comparison                     shift and go to state 24
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43
    boolean                        shift and go to state 44

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (82) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 82 (line -> assignment .)
    PRINT           reduce using rule 82 (line -> assignment .)
    IF              reduce using rule 82 (line -> assignment .)
    LATE            reduce using rule 82 (line -> assignment .)
    FINAL           reduce using rule 82 (line -> assignment .)
    CONST           reduce using rule 82 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 82 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 82 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 82 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 82 (line -> assignment .)
    STRING_TYPE     reduce using rule 82 (line -> assignment .)
    ENUM_TYPE       reduce using rule 82 (line -> assignment .)
    VAR             reduce using rule 82 (line -> assignment .)
    LIST_TYPE       reduce using rule 82 (line -> assignment .)
    MAP_TYPE        reduce using rule 82 (line -> assignment .)
    SET_TYPE        reduce using rule 82 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 82 (line -> assignment .)
    VOID            reduce using rule 82 (line -> assignment .)

  ! $end            [ reduce using rule 82 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (81) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 81 (line -> print .)
    PRINT           reduce using rule 81 (line -> print .)
    IF              reduce using rule 81 (line -> print .)
    LATE            reduce using rule 81 (line -> print .)
    FINAL           reduce using rule 81 (line -> print .)
    CONST           reduce using rule 81 (line -> print .)
    INTEGER_TYPE    reduce using rule 81 (line -> print .)
    DOUBLE_TYPE     reduce using rule 81 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 81 (line -> print .)
    QUEUE_TYPE      reduce using rule 81 (line -> print .)
    STRING_TYPE     reduce using rule 81 (line -> print .)
    ENUM_TYPE       reduce using rule 81 (line -> print .)
    VAR             reduce using rule 81 (line -> print .)
    LIST_TYPE       reduce using rule 81 (line -> print .)
    MAP_TYPE        reduce using rule 81 (line -> print .)
    SET_TYPE        reduce using rule 81 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 81 (line -> print .)
    VOID            reduce using rule 81 (line -> print .)

  ! $end            [ reduce using rule 81 (line -> print .) ]


state 5

    (4) statement -> function .
    (83) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 83 (line -> function .)
    PRINT           reduce using rule 83 (line -> function .)
    IF              reduce using rule 83 (line -> function .)
    LATE            reduce using rule 83 (line -> function .)
    FINAL           reduce using rule 83 (line -> function .)
    CONST           reduce using rule 83 (line -> function .)
    INTEGER_TYPE    reduce using rule 83 (line -> function .)
    DOUBLE_TYPE     reduce using rule 83 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 83 (line -> function .)
    QUEUE_TYPE      reduce using rule 83 (line -> function .)
    STRING_TYPE     reduce using rule 83 (line -> function .)
    ENUM_TYPE       reduce using rule 83 (line -> function .)
    VAR             reduce using rule 83 (line -> function .)
    LIST_TYPE       reduce using rule 83 (line -> function .)
    MAP_TYPE        reduce using rule 83 (line -> function .)
    SET_TYPE        reduce using rule 83 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 83 (line -> function .)
    VOID            reduce using rule 83 (line -> function .)

  ! $end            [ reduce using rule 83 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (22) if_statement -> if_statement . ELSE if_statement
    (23) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (84) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 51
    LINE_BREAK      reduce using rule 84 (line -> if_statement .)
    PRINT           reduce using rule 84 (line -> if_statement .)
    IF              reduce using rule 84 (line -> if_statement .)
    LATE            reduce using rule 84 (line -> if_statement .)
    FINAL           reduce using rule 84 (line -> if_statement .)
    CONST           reduce using rule 84 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 84 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 84 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 84 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 84 (line -> if_statement .)
    STRING_TYPE     reduce using rule 84 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 84 (line -> if_statement .)
    VAR             reduce using rule 84 (line -> if_statement .)
    LIST_TYPE       reduce using rule 84 (line -> if_statement .)
    MAP_TYPE        reduce using rule 84 (line -> if_statement .)
    SET_TYPE        reduce using rule 84 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 84 (line -> if_statement .)
    VOID            reduce using rule 84 (line -> if_statement .)

  ! $end            [ reduce using rule 84 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .

    $end            reduce using rule 6 (statement -> while_statement .)


state 8

    (7) statement -> for_statement .

    $end            reduce using rule 7 (statement -> for_statement .)


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    RBRACE          reduce using rule 80 (lines -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    lines                          shift and go to state 52
    line                           shift and go to state 22
    print                          shift and go to state 53
    assignment                     shift and go to state 54
    function                       shift and go to state 55
    if_statement                   shift and go to state 56
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 11

    (37) expression -> arithmetic .
    (41) arithmetic -> arithmetic . arith_op arithmetic
    (53) arith_op -> . PLUS
    (54) arith_op -> . MINUS
    (55) arith_op -> . TIMES
    (56) arith_op -> . DIVIDE

    $end            reduce using rule 37 (expression -> arithmetic .)
    RPAREN          reduce using rule 37 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 37 (expression -> arithmetic .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61

    arith_op                       shift and go to state 57

state 12

    (38) expression -> logic .
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

    $end            reduce using rule 38 (expression -> logic .)
    RPAREN          reduce using rule 38 (expression -> logic .)
    SEMICOLON       reduce using rule 38 (expression -> logic .)
    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

    logic_op                       shift and go to state 62

state 13

    (39) expression -> function_call .

    $end            reduce using rule 39 (expression -> function_call .)
    RPAREN          reduce using rule 39 (expression -> function_call .)
    SEMICOLON       reduce using rule 39 (expression -> function_call .)


state 14

    (11) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    type                           shift and go to state 65

state 15

    (12) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (15) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 67
    QUESTION_MARK   shift and go to state 68

    nullable                       shift and go to state 66

state 16

    (24) function_call -> IDENTIFIER . LPAREN parameters RPAREN SEMICOLON
    (65) value -> IDENTIFIER .

    LPAREN          shift and go to state 69
    PLUS            reduce using rule 65 (value -> IDENTIFIER .)
    MINUS           reduce using rule 65 (value -> IDENTIFIER .)
    TIMES           reduce using rule 65 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 65 (value -> IDENTIFIER .)
    $end            reduce using rule 65 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 65 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 65 (value -> IDENTIFIER .)
    LESS            reduce using rule 65 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 65 (value -> IDENTIFIER .)
    GREATER         reduce using rule 65 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 65 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 65 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 65 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 65 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 65 (value -> IDENTIFIER .)


state 17

    (19) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (20) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 70


state 18

    (42) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (49) logic -> LPAREN . logic logic_op logic RPAREN
    (46) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 18
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    arithmetic                     shift and go to state 71
    logic                          shift and go to state 72
    comparison                     shift and go to state 73
    value                          shift and go to state 23
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 19

    (21) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 75


state 20

    (100) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 76


state 21

    (101) for_statement -> FOR . LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 77


state 22

    (77) lines -> line . LINE_BREAK lines
    (78) lines -> line . lines
    (79) lines -> line .
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 79 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 79 (lines -> line .)
    LINE_BREAK      shift and go to state 78
    $end            reduce using rule 79 (lines -> line .)
    RBRACE          reduce using rule 79 (lines -> line .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

  ! $end            [ reduce using rule 80 (lines -> .) ]
  ! RBRACE          [ reduce using rule 80 (lines -> .) ]

    line                           shift and go to state 22
    lines                          shift and go to state 79
    print                          shift and go to state 53
    assignment                     shift and go to state 54
    function                       shift and go to state 55
    if_statement                   shift and go to state 56
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 23

    (40) arithmetic -> value .
    (43) comparison -> value .

  ! reduce/reduce conflict for $end resolved using rule 40 (arithmetic -> value .)
  ! reduce/reduce conflict for RPAREN resolved using rule 40 (arithmetic -> value .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 40 (arithmetic -> value .)
    PLUS            reduce using rule 40 (arithmetic -> value .)
    MINUS           reduce using rule 40 (arithmetic -> value .)
    TIMES           reduce using rule 40 (arithmetic -> value .)
    DIVIDE          reduce using rule 40 (arithmetic -> value .)
    $end            reduce using rule 40 (arithmetic -> value .)
    RPAREN          reduce using rule 40 (arithmetic -> value .)
    SEMICOLON       reduce using rule 40 (arithmetic -> value .)
    EQUAL           reduce using rule 43 (comparison -> value .)
    NOT_EQUAL       reduce using rule 43 (comparison -> value .)
    LESS            reduce using rule 43 (comparison -> value .)
    LESS_EQUAL      reduce using rule 43 (comparison -> value .)
    GREATER         reduce using rule 43 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 43 (comparison -> value .)
    LOGICAL_AND     reduce using rule 43 (comparison -> value .)
    LOGICAL_OR      reduce using rule 43 (comparison -> value .)

  ! $end            [ reduce using rule 43 (comparison -> value .) ]
  ! RPAREN          [ reduce using rule 43 (comparison -> value .) ]
  ! SEMICOLON       [ reduce using rule 43 (comparison -> value .) ]


state 24

    (47) logic -> comparison .
    (45) comparison -> comparison . comp_op comparison
    (57) comp_op -> . EQUAL
    (58) comp_op -> . NOT_EQUAL
    (59) comp_op -> . LESS
    (60) comp_op -> . LESS_EQUAL
    (61) comp_op -> . GREATER
    (62) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 47 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 47 (logic -> comparison .)
    $end            reduce using rule 47 (logic -> comparison .)
    RPAREN          reduce using rule 47 (logic -> comparison .)
    SEMICOLON       reduce using rule 47 (logic -> comparison .)
    EQUAL           shift and go to state 81
    NOT_EQUAL       shift and go to state 82
    LESS            shift and go to state 83
    LESS_EQUAL      shift and go to state 84
    GREATER         shift and go to state 85
    GREATER_EQUAL   shift and go to state 86

    comp_op                        shift and go to state 80

state 25

    (50) logic -> LOGICAL_NOT . logic
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    logic                          shift and go to state 87
    comparison                     shift and go to state 24
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 26

    (16) modifier -> LATE .

    INTEGER_TYPE    reduce using rule 16 (modifier -> LATE .)
    DOUBLE_TYPE     reduce using rule 16 (modifier -> LATE .)
    BOOLEAN_TYPE    reduce using rule 16 (modifier -> LATE .)
    QUEUE_TYPE      reduce using rule 16 (modifier -> LATE .)
    STRING_TYPE     reduce using rule 16 (modifier -> LATE .)
    ENUM_TYPE       reduce using rule 16 (modifier -> LATE .)
    VAR             reduce using rule 16 (modifier -> LATE .)
    LIST_TYPE       reduce using rule 16 (modifier -> LATE .)
    MAP_TYPE        reduce using rule 16 (modifier -> LATE .)
    SET_TYPE        reduce using rule 16 (modifier -> LATE .)
    DYNAMIC_TYPE    reduce using rule 16 (modifier -> LATE .)
    VOID            reduce using rule 16 (modifier -> LATE .)


state 27

    (17) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 17 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 17 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 17 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 17 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 17 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 17 (modifier -> FINAL .)
    VAR             reduce using rule 17 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 17 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 17 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 17 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 17 (modifier -> FINAL .)
    VOID            reduce using rule 17 (modifier -> FINAL .)


state 28

    (18) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 18 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 18 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 18 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 18 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 18 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 18 (modifier -> CONST .)
    VAR             reduce using rule 18 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 18 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 18 (modifier -> CONST .)
    SET_TYPE        reduce using rule 18 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 18 (modifier -> CONST .)
    VOID            reduce using rule 18 (modifier -> CONST .)


state 29

    (25) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 25 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 25 (type -> INTEGER_TYPE .)


state 30

    (26) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 26 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 26 (type -> DOUBLE_TYPE .)


state 31

    (27) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 27 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 27 (type -> BOOLEAN_TYPE .)


state 32

    (28) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 28 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 28 (type -> QUEUE_TYPE .)


state 33

    (29) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 29 (type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 29 (type -> STRING_TYPE .)


state 34

    (30) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 30 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 30 (type -> ENUM_TYPE .)


state 35

    (31) type -> VAR .

    IDENTIFIER      reduce using rule 31 (type -> VAR .)
    QUESTION_MARK   reduce using rule 31 (type -> VAR .)


state 36

    (32) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 32 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 32 (type -> LIST_TYPE .)


state 37

    (33) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 33 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 33 (type -> MAP_TYPE .)


state 38

    (34) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 34 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 34 (type -> SET_TYPE .)


state 39

    (35) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 35 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 35 (type -> DYNAMIC_TYPE .)


state 40

    (36) type -> VOID .

    IDENTIFIER      reduce using rule 36 (type -> VOID .)
    QUESTION_MARK   reduce using rule 36 (type -> VOID .)


state 41

    (66) value -> number .

    PLUS            reduce using rule 66 (value -> number .)
    MINUS           reduce using rule 66 (value -> number .)
    TIMES           reduce using rule 66 (value -> number .)
    DIVIDE          reduce using rule 66 (value -> number .)
    $end            reduce using rule 66 (value -> number .)
    EQUAL           reduce using rule 66 (value -> number .)
    NOT_EQUAL       reduce using rule 66 (value -> number .)
    LESS            reduce using rule 66 (value -> number .)
    LESS_EQUAL      reduce using rule 66 (value -> number .)
    GREATER         reduce using rule 66 (value -> number .)
    GREATER_EQUAL   reduce using rule 66 (value -> number .)
    LOGICAL_AND     reduce using rule 66 (value -> number .)
    LOGICAL_OR      reduce using rule 66 (value -> number .)
    RPAREN          reduce using rule 66 (value -> number .)
    SEMICOLON       reduce using rule 66 (value -> number .)
    COMMA           reduce using rule 66 (value -> number .)
    RSQUARE         reduce using rule 66 (value -> number .)


state 42

    (67) value -> string .

    PLUS            reduce using rule 67 (value -> string .)
    MINUS           reduce using rule 67 (value -> string .)
    TIMES           reduce using rule 67 (value -> string .)
    DIVIDE          reduce using rule 67 (value -> string .)
    $end            reduce using rule 67 (value -> string .)
    EQUAL           reduce using rule 67 (value -> string .)
    NOT_EQUAL       reduce using rule 67 (value -> string .)
    LESS            reduce using rule 67 (value -> string .)
    LESS_EQUAL      reduce using rule 67 (value -> string .)
    GREATER         reduce using rule 67 (value -> string .)
    GREATER_EQUAL   reduce using rule 67 (value -> string .)
    LOGICAL_AND     reduce using rule 67 (value -> string .)
    LOGICAL_OR      reduce using rule 67 (value -> string .)
    RPAREN          reduce using rule 67 (value -> string .)
    SEMICOLON       reduce using rule 67 (value -> string .)
    COMMA           reduce using rule 67 (value -> string .)
    RSQUARE         reduce using rule 67 (value -> string .)


state 43

    (68) value -> list .

    PLUS            reduce using rule 68 (value -> list .)
    MINUS           reduce using rule 68 (value -> list .)
    TIMES           reduce using rule 68 (value -> list .)
    DIVIDE          reduce using rule 68 (value -> list .)
    $end            reduce using rule 68 (value -> list .)
    EQUAL           reduce using rule 68 (value -> list .)
    NOT_EQUAL       reduce using rule 68 (value -> list .)
    LESS            reduce using rule 68 (value -> list .)
    LESS_EQUAL      reduce using rule 68 (value -> list .)
    GREATER         reduce using rule 68 (value -> list .)
    GREATER_EQUAL   reduce using rule 68 (value -> list .)
    LOGICAL_AND     reduce using rule 68 (value -> list .)
    LOGICAL_OR      reduce using rule 68 (value -> list .)
    RPAREN          reduce using rule 68 (value -> list .)
    SEMICOLON       reduce using rule 68 (value -> list .)
    COMMA           reduce using rule 68 (value -> list .)
    RSQUARE         reduce using rule 68 (value -> list .)


state 44

    (44) comparison -> boolean .

    EQUAL           reduce using rule 44 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 44 (comparison -> boolean .)
    LESS            reduce using rule 44 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 44 (comparison -> boolean .)
    GREATER         reduce using rule 44 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 44 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 44 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 44 (comparison -> boolean .)
    $end            reduce using rule 44 (comparison -> boolean .)
    RPAREN          reduce using rule 44 (comparison -> boolean .)
    SEMICOLON       reduce using rule 44 (comparison -> boolean .)


state 45

    (69) number -> INTEGER .

    PLUS            reduce using rule 69 (number -> INTEGER .)
    MINUS           reduce using rule 69 (number -> INTEGER .)
    TIMES           reduce using rule 69 (number -> INTEGER .)
    DIVIDE          reduce using rule 69 (number -> INTEGER .)
    $end            reduce using rule 69 (number -> INTEGER .)
    EQUAL           reduce using rule 69 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 69 (number -> INTEGER .)
    LESS            reduce using rule 69 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 69 (number -> INTEGER .)
    GREATER         reduce using rule 69 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 69 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 69 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 69 (number -> INTEGER .)
    RPAREN          reduce using rule 69 (number -> INTEGER .)
    SEMICOLON       reduce using rule 69 (number -> INTEGER .)
    COMMA           reduce using rule 69 (number -> INTEGER .)
    RSQUARE         reduce using rule 69 (number -> INTEGER .)


state 46

    (70) number -> DOUBLE .

    PLUS            reduce using rule 70 (number -> DOUBLE .)
    MINUS           reduce using rule 70 (number -> DOUBLE .)
    TIMES           reduce using rule 70 (number -> DOUBLE .)
    DIVIDE          reduce using rule 70 (number -> DOUBLE .)
    $end            reduce using rule 70 (number -> DOUBLE .)
    EQUAL           reduce using rule 70 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 70 (number -> DOUBLE .)
    LESS            reduce using rule 70 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 70 (number -> DOUBLE .)
    GREATER         reduce using rule 70 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 70 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 70 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 70 (number -> DOUBLE .)
    RPAREN          reduce using rule 70 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 70 (number -> DOUBLE .)
    COMMA           reduce using rule 70 (number -> DOUBLE .)
    RSQUARE         reduce using rule 70 (number -> DOUBLE .)


state 47

    (71) string -> STRING .

    PLUS            reduce using rule 71 (string -> STRING .)
    MINUS           reduce using rule 71 (string -> STRING .)
    TIMES           reduce using rule 71 (string -> STRING .)
    DIVIDE          reduce using rule 71 (string -> STRING .)
    $end            reduce using rule 71 (string -> STRING .)
    EQUAL           reduce using rule 71 (string -> STRING .)
    NOT_EQUAL       reduce using rule 71 (string -> STRING .)
    LESS            reduce using rule 71 (string -> STRING .)
    LESS_EQUAL      reduce using rule 71 (string -> STRING .)
    GREATER         reduce using rule 71 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 71 (string -> STRING .)
    LOGICAL_AND     reduce using rule 71 (string -> STRING .)
    LOGICAL_OR      reduce using rule 71 (string -> STRING .)
    RPAREN          reduce using rule 71 (string -> STRING .)
    SEMICOLON       reduce using rule 71 (string -> STRING .)
    COMMA           reduce using rule 71 (string -> STRING .)
    RSQUARE         reduce using rule 71 (string -> STRING .)


state 48

    (74) list -> LSQUARE . RSQUARE
    (75) list -> LSQUARE . values RSQUARE
    (63) values -> . value
    (64) values -> . value COMMA values
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 90
    IDENTIFIER      shift and go to state 74
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    values                         shift and go to state 91
    value                          shift and go to state 92
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 49

    (72) boolean -> TRUE .

    EQUAL           reduce using rule 72 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 72 (boolean -> TRUE .)
    LESS            reduce using rule 72 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 72 (boolean -> TRUE .)
    GREATER         reduce using rule 72 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 72 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 72 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 72 (boolean -> TRUE .)
    $end            reduce using rule 72 (boolean -> TRUE .)
    RPAREN          reduce using rule 72 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 72 (boolean -> TRUE .)


state 50

    (73) boolean -> FALSE .

    EQUAL           reduce using rule 73 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 73 (boolean -> FALSE .)
    LESS            reduce using rule 73 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 73 (boolean -> FALSE .)
    GREATER         reduce using rule 73 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 73 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 73 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 73 (boolean -> FALSE .)
    $end            reduce using rule 73 (boolean -> FALSE .)
    RPAREN          reduce using rule 73 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 73 (boolean -> FALSE .)


state 51

    (22) if_statement -> if_statement ELSE . if_statement
    (23) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 94
    IF              shift and go to state 19

    if_statement                   shift and go to state 93

state 52

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 95


state 53

    (81) line -> print .

    LINE_BREAK      reduce using rule 81 (line -> print .)
    PRINT           reduce using rule 81 (line -> print .)
    IF              reduce using rule 81 (line -> print .)
    LATE            reduce using rule 81 (line -> print .)
    FINAL           reduce using rule 81 (line -> print .)
    CONST           reduce using rule 81 (line -> print .)
    INTEGER_TYPE    reduce using rule 81 (line -> print .)
    DOUBLE_TYPE     reduce using rule 81 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 81 (line -> print .)
    QUEUE_TYPE      reduce using rule 81 (line -> print .)
    STRING_TYPE     reduce using rule 81 (line -> print .)
    ENUM_TYPE       reduce using rule 81 (line -> print .)
    VAR             reduce using rule 81 (line -> print .)
    LIST_TYPE       reduce using rule 81 (line -> print .)
    MAP_TYPE        reduce using rule 81 (line -> print .)
    SET_TYPE        reduce using rule 81 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 81 (line -> print .)
    VOID            reduce using rule 81 (line -> print .)
    RBRACE          reduce using rule 81 (line -> print .)
    $end            reduce using rule 81 (line -> print .)


state 54

    (82) line -> assignment .

    LINE_BREAK      reduce using rule 82 (line -> assignment .)
    PRINT           reduce using rule 82 (line -> assignment .)
    IF              reduce using rule 82 (line -> assignment .)
    LATE            reduce using rule 82 (line -> assignment .)
    FINAL           reduce using rule 82 (line -> assignment .)
    CONST           reduce using rule 82 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 82 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 82 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 82 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 82 (line -> assignment .)
    STRING_TYPE     reduce using rule 82 (line -> assignment .)
    ENUM_TYPE       reduce using rule 82 (line -> assignment .)
    VAR             reduce using rule 82 (line -> assignment .)
    LIST_TYPE       reduce using rule 82 (line -> assignment .)
    MAP_TYPE        reduce using rule 82 (line -> assignment .)
    SET_TYPE        reduce using rule 82 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 82 (line -> assignment .)
    VOID            reduce using rule 82 (line -> assignment .)
    RBRACE          reduce using rule 82 (line -> assignment .)
    $end            reduce using rule 82 (line -> assignment .)


state 55

    (83) line -> function .

    LINE_BREAK      reduce using rule 83 (line -> function .)
    PRINT           reduce using rule 83 (line -> function .)
    IF              reduce using rule 83 (line -> function .)
    LATE            reduce using rule 83 (line -> function .)
    FINAL           reduce using rule 83 (line -> function .)
    CONST           reduce using rule 83 (line -> function .)
    INTEGER_TYPE    reduce using rule 83 (line -> function .)
    DOUBLE_TYPE     reduce using rule 83 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 83 (line -> function .)
    QUEUE_TYPE      reduce using rule 83 (line -> function .)
    STRING_TYPE     reduce using rule 83 (line -> function .)
    ENUM_TYPE       reduce using rule 83 (line -> function .)
    VAR             reduce using rule 83 (line -> function .)
    LIST_TYPE       reduce using rule 83 (line -> function .)
    MAP_TYPE        reduce using rule 83 (line -> function .)
    SET_TYPE        reduce using rule 83 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 83 (line -> function .)
    VOID            reduce using rule 83 (line -> function .)
    RBRACE          reduce using rule 83 (line -> function .)
    $end            reduce using rule 83 (line -> function .)


state 56

    (84) line -> if_statement .
    (22) if_statement -> if_statement . ELSE if_statement
    (23) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 84 (line -> if_statement .)
    PRINT           reduce using rule 84 (line -> if_statement .)
    IF              reduce using rule 84 (line -> if_statement .)
    LATE            reduce using rule 84 (line -> if_statement .)
    FINAL           reduce using rule 84 (line -> if_statement .)
    CONST           reduce using rule 84 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 84 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 84 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 84 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 84 (line -> if_statement .)
    STRING_TYPE     reduce using rule 84 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 84 (line -> if_statement .)
    VAR             reduce using rule 84 (line -> if_statement .)
    LIST_TYPE       reduce using rule 84 (line -> if_statement .)
    MAP_TYPE        reduce using rule 84 (line -> if_statement .)
    SET_TYPE        reduce using rule 84 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 84 (line -> if_statement .)
    VOID            reduce using rule 84 (line -> if_statement .)
    RBRACE          reduce using rule 84 (line -> if_statement .)
    $end            reduce using rule 84 (line -> if_statement .)
    ELSE            shift and go to state 51


state 57

    (41) arithmetic -> arithmetic arith_op . arithmetic
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 98
    IDENTIFIER      shift and go to state 74
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    arithmetic                     shift and go to state 96
    value                          shift and go to state 97
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 58

    (53) arith_op -> PLUS .

    LPAREN          reduce using rule 53 (arith_op -> PLUS .)
    IDENTIFIER      reduce using rule 53 (arith_op -> PLUS .)
    INTEGER         reduce using rule 53 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 53 (arith_op -> PLUS .)
    STRING          reduce using rule 53 (arith_op -> PLUS .)
    LSQUARE         reduce using rule 53 (arith_op -> PLUS .)


state 59

    (54) arith_op -> MINUS .

    LPAREN          reduce using rule 54 (arith_op -> MINUS .)
    IDENTIFIER      reduce using rule 54 (arith_op -> MINUS .)
    INTEGER         reduce using rule 54 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 54 (arith_op -> MINUS .)
    STRING          reduce using rule 54 (arith_op -> MINUS .)
    LSQUARE         reduce using rule 54 (arith_op -> MINUS .)


state 60

    (55) arith_op -> TIMES .

    LPAREN          reduce using rule 55 (arith_op -> TIMES .)
    IDENTIFIER      reduce using rule 55 (arith_op -> TIMES .)
    INTEGER         reduce using rule 55 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 55 (arith_op -> TIMES .)
    STRING          reduce using rule 55 (arith_op -> TIMES .)
    LSQUARE         reduce using rule 55 (arith_op -> TIMES .)


state 61

    (56) arith_op -> DIVIDE .

    LPAREN          reduce using rule 56 (arith_op -> DIVIDE .)
    IDENTIFIER      reduce using rule 56 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 56 (arith_op -> DIVIDE .)
    DOUBLE          reduce using rule 56 (arith_op -> DIVIDE .)
    STRING          reduce using rule 56 (arith_op -> DIVIDE .)
    LSQUARE         reduce using rule 56 (arith_op -> DIVIDE .)


state 62

    (48) logic -> logic logic_op . logic
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    logic                          shift and go to state 99
    comparison                     shift and go to state 24
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 63

    (51) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 51 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 51 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 51 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 51 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 51 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 51 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 51 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 51 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 51 (logic_op -> LOGICAL_AND .)


state 64

    (52) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 52 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 52 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 52 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 52 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 52 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 52 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 52 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 52 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 52 (logic_op -> LOGICAL_OR .)


state 65

    (11) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (15) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 101
    QUESTION_MARK   shift and go to state 68

    nullable                       shift and go to state 100

state 66

    (12) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 102


state 67

    (14) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (76) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 103
    LPAREN          shift and go to state 104


state 68

    (15) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 15 (nullable -> QUESTION_MARK .)


state 69

    (24) function_call -> IDENTIFIER LPAREN . parameters RPAREN SEMICOLON
    (85) parameters -> . VOID
    (86) parameters -> . parameter
    (87) parameters -> . parameter COMMA parameters
    (88) parameters -> .
    (89) parameter -> . type IDENTIFIER
    (90) parameter -> . IDENTIFIER
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    VOID            shift and go to state 107
    RPAREN          reduce using rule 88 (parameters -> .)
    IDENTIFIER      shift and go to state 105
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39

    parameters                     shift and go to state 106
    parameter                      shift and go to state 108
    type                           shift and go to state 109

state 70

    (19) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (20) print -> PRINT LPAREN . RPAREN SEMICOLON
    (37) expression -> . arithmetic
    (38) expression -> . logic
    (39) expression -> . function_call
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (24) function_call -> . IDENTIFIER LPAREN parameters RPAREN SEMICOLON
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE

    RPAREN          shift and go to state 111
    LPAREN          shift and go to state 18
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 110
    arithmetic                     shift and go to state 11
    logic                          shift and go to state 12
    function_call                  shift and go to state 13
    value                          shift and go to state 23
    comparison                     shift and go to state 24
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43
    boolean                        shift and go to state 44

state 71

    (42) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (41) arithmetic -> arithmetic . arith_op arithmetic
    (53) arith_op -> . PLUS
    (54) arith_op -> . MINUS
    (55) arith_op -> . TIMES
    (56) arith_op -> . DIVIDE

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61

    arith_op                       shift and go to state 112

state 72

    (49) logic -> LPAREN logic . logic_op logic RPAREN
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

    logic_op                       shift and go to state 113

state 73

    (46) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (47) logic -> comparison .
    (45) comparison -> comparison . comp_op comparison
    (57) comp_op -> . EQUAL
    (58) comp_op -> . NOT_EQUAL
    (59) comp_op -> . LESS
    (60) comp_op -> . LESS_EQUAL
    (61) comp_op -> . GREATER
    (62) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 47 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 47 (logic -> comparison .)
    EQUAL           shift and go to state 81
    NOT_EQUAL       shift and go to state 82
    LESS            shift and go to state 83
    LESS_EQUAL      shift and go to state 84
    GREATER         shift and go to state 85
    GREATER_EQUAL   shift and go to state 86

    comp_op                        shift and go to state 114

state 74

    (65) value -> IDENTIFIER .

    PLUS            reduce using rule 65 (value -> IDENTIFIER .)
    MINUS           reduce using rule 65 (value -> IDENTIFIER .)
    TIMES           reduce using rule 65 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 65 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 65 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 65 (value -> IDENTIFIER .)
    LESS            reduce using rule 65 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 65 (value -> IDENTIFIER .)
    GREATER         reduce using rule 65 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 65 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 65 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 65 (value -> IDENTIFIER .)
    $end            reduce using rule 65 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 65 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 65 (value -> IDENTIFIER .)
    COMMA           reduce using rule 65 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 65 (value -> IDENTIFIER .)


state 75

    (21) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    logic                          shift and go to state 115
    comparison                     shift and go to state 24
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 76

    (100) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    logic                          shift and go to state 116
    comparison                     shift and go to state 24
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 77

    (101) for_statement -> FOR LPAREN . assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines RBRACE
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    assignment                     shift and go to state 117
    modifier                       shift and go to state 14
    type                           shift and go to state 118

state 78

    (77) lines -> line LINE_BREAK . lines
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    $end            reduce using rule 80 (lines -> .)
    RBRACE          reduce using rule 80 (lines -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    line                           shift and go to state 22
    lines                          shift and go to state 119
    print                          shift and go to state 53
    assignment                     shift and go to state 54
    function                       shift and go to state 55
    if_statement                   shift and go to state 56
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 79

    (78) lines -> line lines .

    $end            reduce using rule 78 (lines -> line lines .)
    RBRACE          reduce using rule 78 (lines -> line lines .)


state 80

    (45) comparison -> comparison comp_op . comparison
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 121
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    comparison                     shift and go to state 120
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 81

    (57) comp_op -> EQUAL .

    LPAREN          reduce using rule 57 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 57 (comp_op -> EQUAL .)
    TRUE            reduce using rule 57 (comp_op -> EQUAL .)
    FALSE           reduce using rule 57 (comp_op -> EQUAL .)
    INTEGER         reduce using rule 57 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 57 (comp_op -> EQUAL .)
    STRING          reduce using rule 57 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 57 (comp_op -> EQUAL .)


state 82

    (58) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 58 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 58 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 58 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 58 (comp_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 58 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 58 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 58 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 58 (comp_op -> NOT_EQUAL .)


state 83

    (59) comp_op -> LESS .

    LPAREN          reduce using rule 59 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 59 (comp_op -> LESS .)
    TRUE            reduce using rule 59 (comp_op -> LESS .)
    FALSE           reduce using rule 59 (comp_op -> LESS .)
    INTEGER         reduce using rule 59 (comp_op -> LESS .)
    DOUBLE          reduce using rule 59 (comp_op -> LESS .)
    STRING          reduce using rule 59 (comp_op -> LESS .)
    LSQUARE         reduce using rule 59 (comp_op -> LESS .)


state 84

    (60) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 60 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 60 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 60 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 60 (comp_op -> LESS_EQUAL .)
    INTEGER         reduce using rule 60 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 60 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 60 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 60 (comp_op -> LESS_EQUAL .)


state 85

    (61) comp_op -> GREATER .

    LPAREN          reduce using rule 61 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 61 (comp_op -> GREATER .)
    TRUE            reduce using rule 61 (comp_op -> GREATER .)
    FALSE           reduce using rule 61 (comp_op -> GREATER .)
    INTEGER         reduce using rule 61 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 61 (comp_op -> GREATER .)
    STRING          reduce using rule 61 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 61 (comp_op -> GREATER .)


state 86

    (62) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 62 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 62 (comp_op -> GREATER_EQUAL .)


state 87

    (50) logic -> LOGICAL_NOT logic .
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 50 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 50 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 50 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

  ! LOGICAL_AND     [ reduce using rule 50 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 50 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 62

state 88

    (49) logic -> LPAREN . logic logic_op logic RPAREN
    (46) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    logic                          shift and go to state 72
    comparison                     shift and go to state 73
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 89

    (43) comparison -> value .

    EQUAL           reduce using rule 43 (comparison -> value .)
    NOT_EQUAL       reduce using rule 43 (comparison -> value .)
    LESS            reduce using rule 43 (comparison -> value .)
    LESS_EQUAL      reduce using rule 43 (comparison -> value .)
    GREATER         reduce using rule 43 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 43 (comparison -> value .)
    LOGICAL_AND     reduce using rule 43 (comparison -> value .)
    LOGICAL_OR      reduce using rule 43 (comparison -> value .)
    $end            reduce using rule 43 (comparison -> value .)
    RPAREN          reduce using rule 43 (comparison -> value .)
    SEMICOLON       reduce using rule 43 (comparison -> value .)


state 90

    (74) list -> LSQUARE RSQUARE .

    PLUS            reduce using rule 74 (list -> LSQUARE RSQUARE .)
    MINUS           reduce using rule 74 (list -> LSQUARE RSQUARE .)
    TIMES           reduce using rule 74 (list -> LSQUARE RSQUARE .)
    DIVIDE          reduce using rule 74 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 74 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 74 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 74 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 74 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 74 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 74 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 74 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 74 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 74 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 74 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 74 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 74 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 74 (list -> LSQUARE RSQUARE .)


state 91

    (75) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 122


state 92

    (63) values -> value .
    (64) values -> value . COMMA values

    RSQUARE         reduce using rule 63 (values -> value .)
    COMMA           shift and go to state 123


state 93

    (22) if_statement -> if_statement ELSE if_statement .
    (22) if_statement -> if_statement . ELSE if_statement
    (23) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    LATE            reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 22 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 51

  ! ELSE            [ reduce using rule 22 (if_statement -> if_statement ELSE if_statement .) ]


state 94

    (23) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    RBRACE          reduce using rule 80 (lines -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    if_statement                   shift and go to state 56
    lines                          shift and go to state 124
    line                           shift and go to state 22
    print                          shift and go to state 53
    assignment                     shift and go to state 54
    function                       shift and go to state 55
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 95

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 96

    (41) arithmetic -> arithmetic arith_op arithmetic .
    (41) arithmetic -> arithmetic . arith_op arithmetic
    (53) arith_op -> . PLUS
    (54) arith_op -> . MINUS
    (55) arith_op -> . TIMES
    (56) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    $end            reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61

  ! PLUS            [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 57

state 97

    (40) arithmetic -> value .

    PLUS            reduce using rule 40 (arithmetic -> value .)
    MINUS           reduce using rule 40 (arithmetic -> value .)
    TIMES           reduce using rule 40 (arithmetic -> value .)
    DIVIDE          reduce using rule 40 (arithmetic -> value .)
    $end            reduce using rule 40 (arithmetic -> value .)
    RPAREN          reduce using rule 40 (arithmetic -> value .)
    SEMICOLON       reduce using rule 40 (arithmetic -> value .)


state 98

    (42) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 98
    IDENTIFIER      shift and go to state 74
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    arithmetic                     shift and go to state 71
    value                          shift and go to state 97
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 99

    (48) logic -> logic logic_op logic .
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 48 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 48 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 48 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

  ! LOGICAL_AND     [ reduce using rule 48 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 48 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 62

state 100

    (11) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 125


state 101

    (13) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 126


state 102

    (12) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 127


state 103

    (14) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (37) expression -> . arithmetic
    (38) expression -> . logic
    (39) expression -> . function_call
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (24) function_call -> . IDENTIFIER LPAREN parameters RPAREN SEMICOLON
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE

    LPAREN          shift and go to state 18
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 128
    arithmetic                     shift and go to state 11
    logic                          shift and go to state 12
    function_call                  shift and go to state 13
    value                          shift and go to state 23
    comparison                     shift and go to state 24
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43
    boolean                        shift and go to state 44

state 104

    (76) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (85) parameters -> . VOID
    (86) parameters -> . parameter
    (87) parameters -> . parameter COMMA parameters
    (88) parameters -> .
    (89) parameter -> . type IDENTIFIER
    (90) parameter -> . IDENTIFIER
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    VOID            shift and go to state 107
    RPAREN          reduce using rule 88 (parameters -> .)
    IDENTIFIER      shift and go to state 105
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39

    type                           shift and go to state 109
    parameters                     shift and go to state 129
    parameter                      shift and go to state 108

state 105

    (90) parameter -> IDENTIFIER .

    COMMA           reduce using rule 90 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 90 (parameter -> IDENTIFIER .)


state 106

    (24) function_call -> IDENTIFIER LPAREN parameters . RPAREN SEMICOLON

    RPAREN          shift and go to state 130


state 107

    (85) parameters -> VOID .
    (36) type -> VOID .

    RPAREN          reduce using rule 85 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 36 (type -> VOID .)


state 108

    (86) parameters -> parameter .
    (87) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 86 (parameters -> parameter .)
    COMMA           shift and go to state 131


state 109

    (89) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 132


state 110

    (19) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 133


state 111

    (20) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 134


state 112

    (42) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (41) arithmetic -> arithmetic arith_op . arithmetic
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 98
    IDENTIFIER      shift and go to state 74
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    arithmetic                     shift and go to state 135
    value                          shift and go to state 97
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 113

    (49) logic -> LPAREN logic logic_op . logic RPAREN
    (48) logic -> logic logic_op . logic
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    logic                          shift and go to state 136
    comparison                     shift and go to state 24
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 114

    (46) comparison -> LPAREN comparison comp_op . comparison RPAREN
    (45) comparison -> comparison comp_op . comparison
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 121
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    comparison                     shift and go to state 137
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 115

    (21) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 138
    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

    logic_op                       shift and go to state 62

state 116

    (100) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 139
    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

    logic_op                       shift and go to state 62

state 117

    (101) for_statement -> FOR LPAREN assignment . SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines RBRACE

    SEMICOLON       shift and go to state 140


state 118

    (12) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (15) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 141
    QUESTION_MARK   shift and go to state 68

    nullable                       shift and go to state 66

state 119

    (77) lines -> line LINE_BREAK lines .

    $end            reduce using rule 77 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 77 (lines -> line LINE_BREAK lines .)


state 120

    (45) comparison -> comparison comp_op comparison .
    (45) comparison -> comparison . comp_op comparison
    (57) comp_op -> . EQUAL
    (58) comp_op -> . NOT_EQUAL
    (59) comp_op -> . LESS
    (60) comp_op -> . LESS_EQUAL
    (61) comp_op -> . GREATER
    (62) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 45 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 45 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 45 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 45 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 45 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 81
    NOT_EQUAL       shift and go to state 82
    LESS            shift and go to state 83
    LESS_EQUAL      shift and go to state 84
    GREATER         shift and go to state 85
    GREATER_EQUAL   shift and go to state 86

  ! EQUAL           [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 80

state 121

    (46) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 121
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    comparison                     shift and go to state 142
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 122

    (75) list -> LSQUARE values RSQUARE .

    PLUS            reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    MINUS           reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    TIMES           reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    DIVIDE          reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 75 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 75 (list -> LSQUARE values RSQUARE .)


state 123

    (64) values -> value COMMA . values
    (63) values -> . value
    (64) values -> . value COMMA values
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 74
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    value                          shift and go to state 92
    values                         shift and go to state 143
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 124

    (23) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 144


state 125

    (11) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 145


state 126

    (13) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (37) expression -> . arithmetic
    (38) expression -> . logic
    (39) expression -> . function_call
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (24) function_call -> . IDENTIFIER LPAREN parameters RPAREN SEMICOLON
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE

    LPAREN          shift and go to state 18
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 146
    arithmetic                     shift and go to state 11
    logic                          shift and go to state 12
    function_call                  shift and go to state 13
    value                          shift and go to state 23
    comparison                     shift and go to state 24
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43
    boolean                        shift and go to state 44

state 127

    (12) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (37) expression -> . arithmetic
    (38) expression -> . logic
    (39) expression -> . function_call
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (24) function_call -> . IDENTIFIER LPAREN parameters RPAREN SEMICOLON
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE

    LPAREN          shift and go to state 18
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 147
    arithmetic                     shift and go to state 11
    logic                          shift and go to state 12
    function_call                  shift and go to state 13
    value                          shift and go to state 23
    comparison                     shift and go to state 24
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43
    boolean                        shift and go to state 44

state 128

    (14) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 148


state 129

    (76) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 149


state 130

    (24) function_call -> IDENTIFIER LPAREN parameters RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 150


state 131

    (87) parameters -> parameter COMMA . parameters
    (85) parameters -> . VOID
    (86) parameters -> . parameter
    (87) parameters -> . parameter COMMA parameters
    (88) parameters -> .
    (89) parameter -> . type IDENTIFIER
    (90) parameter -> . IDENTIFIER
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    VOID            shift and go to state 107
    RPAREN          reduce using rule 88 (parameters -> .)
    IDENTIFIER      shift and go to state 105
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39

    parameter                      shift and go to state 108
    parameters                     shift and go to state 151
    type                           shift and go to state 109

state 132

    (89) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 89 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 89 (parameter -> type IDENTIFIER .)


state 133

    (19) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 152


state 134

    (20) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LATE            reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 20 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 135

    (42) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (41) arithmetic -> arithmetic arith_op arithmetic .
    (41) arithmetic -> arithmetic . arith_op arithmetic
    (53) arith_op -> . PLUS
    (54) arith_op -> . MINUS
    (55) arith_op -> . TIMES
    (56) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    RPAREN          shift and go to state 153
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61

  ! PLUS            [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 41 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 57

state 136

    (49) logic -> LPAREN logic logic_op logic . RPAREN
    (48) logic -> logic logic_op logic .
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 154
    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

  ! LOGICAL_AND     [ reduce using rule 48 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 48 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 62

state 137

    (46) comparison -> LPAREN comparison comp_op comparison . RPAREN
    (45) comparison -> comparison comp_op comparison .
    (45) comparison -> comparison . comp_op comparison
    (57) comp_op -> . EQUAL
    (58) comp_op -> . NOT_EQUAL
    (59) comp_op -> . LESS
    (60) comp_op -> . LESS_EQUAL
    (61) comp_op -> . GREATER
    (62) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    RPAREN          shift and go to state 155
    LOGICAL_AND     reduce using rule 45 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 45 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 81
    NOT_EQUAL       shift and go to state 82
    LESS            shift and go to state 83
    LESS_EQUAL      shift and go to state 84
    GREATER         shift and go to state 85
    GREATER_EQUAL   shift and go to state 86

  ! EQUAL           [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 45 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 80

state 138

    (21) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 156


state 139

    (100) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 157


state 140

    (101) for_statement -> FOR LPAREN assignment SEMICOLON . logic SEMICOLON assignment RPAREN LBRACE lines RBRACE
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 74
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48

    logic                          shift and go to state 158
    comparison                     shift and go to state 24
    value                          shift and go to state 89
    boolean                        shift and go to state 44
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43

state 141

    (14) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 103


state 142

    (46) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (45) comparison -> comparison . comp_op comparison
    (57) comp_op -> . EQUAL
    (58) comp_op -> . NOT_EQUAL
    (59) comp_op -> . LESS
    (60) comp_op -> . LESS_EQUAL
    (61) comp_op -> . GREATER
    (62) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 81
    NOT_EQUAL       shift and go to state 82
    LESS            shift and go to state 83
    LESS_EQUAL      shift and go to state 84
    GREATER         shift and go to state 85
    GREATER_EQUAL   shift and go to state 86

    comp_op                        shift and go to state 114

state 143

    (64) values -> value COMMA values .

    RSQUARE         reduce using rule 64 (values -> value COMMA values .)


state 144

    (23) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LATE            reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 23 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 145

    (11) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (37) expression -> . arithmetic
    (38) expression -> . logic
    (39) expression -> . function_call
    (40) arithmetic -> . value
    (41) arithmetic -> . arithmetic arith_op arithmetic
    (42) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (47) logic -> . comparison
    (48) logic -> . logic logic_op logic
    (49) logic -> . LPAREN logic logic_op logic RPAREN
    (50) logic -> . LOGICAL_NOT logic
    (24) function_call -> . IDENTIFIER LPAREN parameters RPAREN SEMICOLON
    (65) value -> . IDENTIFIER
    (66) value -> . number
    (67) value -> . string
    (68) value -> . list
    (43) comparison -> . value
    (44) comparison -> . boolean
    (45) comparison -> . comparison comp_op comparison
    (46) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (69) number -> . INTEGER
    (70) number -> . DOUBLE
    (71) string -> . STRING
    (74) list -> . LSQUARE RSQUARE
    (75) list -> . LSQUARE values RSQUARE
    (72) boolean -> . TRUE
    (73) boolean -> . FALSE

    LPAREN          shift and go to state 18
    LOGICAL_NOT     shift and go to state 25
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 45
    DOUBLE          shift and go to state 46
    STRING          shift and go to state 47
    LSQUARE         shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 159
    arithmetic                     shift and go to state 11
    logic                          shift and go to state 12
    function_call                  shift and go to state 13
    value                          shift and go to state 23
    comparison                     shift and go to state 24
    number                         shift and go to state 41
    string                         shift and go to state 42
    list                           shift and go to state 43
    boolean                        shift and go to state 44

state 146

    (13) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 160


state 147

    (12) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 161


state 148

    (14) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 14 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 149

    (76) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 162


state 150

    (24) function_call -> IDENTIFIER LPAREN parameters RPAREN SEMICOLON .

    $end            reduce using rule 24 (function_call -> IDENTIFIER LPAREN parameters RPAREN SEMICOLON .)
    RPAREN          reduce using rule 24 (function_call -> IDENTIFIER LPAREN parameters RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 24 (function_call -> IDENTIFIER LPAREN parameters RPAREN SEMICOLON .)


state 151

    (87) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 87 (parameters -> parameter COMMA parameters .)


state 152

    (19) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LATE            reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 19 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 153

    (42) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 42 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 42 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 42 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DIVIDE          reduce using rule 42 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 42 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 42 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 42 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 154

    (49) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 49 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 49 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 49 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 49 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 49 (logic -> LPAREN logic logic_op logic RPAREN .)


state 155

    (46) comparison -> LPAREN comparison comp_op comparison RPAREN .

    EQUAL           reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    NOT_EQUAL       reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS            reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS_EQUAL      reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER         reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER_EQUAL   reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_AND     reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_OR      reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    $end            reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RPAREN          reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SEMICOLON       reduce using rule 46 (comparison -> LPAREN comparison comp_op comparison RPAREN .)


state 156

    (21) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    RBRACE          reduce using rule 80 (lines -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    lines                          shift and go to state 163
    line                           shift and go to state 22
    print                          shift and go to state 53
    assignment                     shift and go to state 54
    function                       shift and go to state 55
    if_statement                   shift and go to state 56
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 157

    (100) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    RBRACE          reduce using rule 80 (lines -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    lines                          shift and go to state 164
    line                           shift and go to state 22
    print                          shift and go to state 53
    assignment                     shift and go to state 54
    function                       shift and go to state 55
    if_statement                   shift and go to state 56
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 158

    (101) for_statement -> FOR LPAREN assignment SEMICOLON logic . SEMICOLON assignment RPAREN LBRACE lines RBRACE
    (48) logic -> logic . logic_op logic
    (51) logic_op -> . LOGICAL_AND
    (52) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 165
    LOGICAL_AND     shift and go to state 63
    LOGICAL_OR      shift and go to state 64

    logic_op                       shift and go to state 62

state 159

    (11) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 166


state 160

    (13) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 13 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 161

    (12) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 12 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 162

    (76) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    RBRACE          reduce using rule 80 (lines -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    type                           shift and go to state 15
    lines                          shift and go to state 167
    line                           shift and go to state 22
    print                          shift and go to state 53
    assignment                     shift and go to state 54
    function                       shift and go to state 55
    if_statement                   shift and go to state 56
    modifier                       shift and go to state 14

state 163

    (21) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 168


state 164

    (100) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 169


state 165

    (101) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON . assignment RPAREN LBRACE lines RBRACE
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    assignment                     shift and go to state 170
    modifier                       shift and go to state 14
    type                           shift and go to state 118

state 166

    (11) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 11 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 167

    (76) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 171


state 168

    (21) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 21 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 169

    (100) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 100 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 170

    (101) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 172


state 171

    (76) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 76 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 172

    (101) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 173


state 173

    (101) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE . lines RBRACE
    (77) lines -> . line LINE_BREAK lines
    (78) lines -> . line lines
    (79) lines -> . line
    (80) lines -> .
    (81) line -> . print
    (82) line -> . assignment
    (83) line -> . function
    (84) line -> . if_statement
    (19) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (20) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (12) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (76) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (22) if_statement -> . if_statement ELSE if_statement
    (23) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (16) modifier -> . LATE
    (17) modifier -> . FINAL
    (18) modifier -> . CONST
    (25) type -> . INTEGER_TYPE
    (26) type -> . DOUBLE_TYPE
    (27) type -> . BOOLEAN_TYPE
    (28) type -> . QUEUE_TYPE
    (29) type -> . STRING_TYPE
    (30) type -> . ENUM_TYPE
    (31) type -> . VAR
    (32) type -> . LIST_TYPE
    (33) type -> . MAP_TYPE
    (34) type -> . SET_TYPE
    (35) type -> . DYNAMIC_TYPE
    (36) type -> . VOID

    RBRACE          reduce using rule 80 (lines -> .)
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    LATE            shift and go to state 26
    FINAL           shift and go to state 27
    CONST           shift and go to state 28
    INTEGER_TYPE    shift and go to state 29
    DOUBLE_TYPE     shift and go to state 30
    BOOLEAN_TYPE    shift and go to state 31
    QUEUE_TYPE      shift and go to state 32
    STRING_TYPE     shift and go to state 33
    ENUM_TYPE       shift and go to state 34
    VAR             shift and go to state 35
    LIST_TYPE       shift and go to state 36
    MAP_TYPE        shift and go to state 37
    SET_TYPE        shift and go to state 38
    DYNAMIC_TYPE    shift and go to state 39
    VOID            shift and go to state 40

    assignment                     shift and go to state 54
    lines                          shift and go to state 174
    line                           shift and go to state 22
    print                          shift and go to state 53
    function                       shift and go to state 55
    if_statement                   shift and go to state 56
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 174

    (101) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 175


state 175

    (101) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 101 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON assignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 87 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 87 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 93 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 96 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 96 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 96 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 99 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 99 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 135 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 135 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 136 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 136 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 137 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 137 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 137 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 137 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 22 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 22
WARNING: reduce/reduce conflict in state 23 resolved using rule (arithmetic -> value)
WARNING: rejected rule (comparison -> value) in state 23
