Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOT
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FINALLY
    FOR
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    IN
    INTERFACE
    IS
    KEYWORD
    LIBRARY
    NULL
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WHILE
    WITH
    YIELD

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> lines
Rule 7     statement -> <empty>
Rule 8     assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 9     assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 10    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 11    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 12    nullable -> QUESTION_MARK
Rule 13    modifier -> LATE
Rule 14    modifier -> FINAL
Rule 15    modifier -> CONST
Rule 16    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 17    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 18    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 19    if_statement -> if_statement ELSE if_statement
Rule 20    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 21    function_call -> IDENTIFIER LPAREN parameters RPAREN
Rule 22    type -> INTEGER_TYPE
Rule 23    type -> DOUBLE_TYPE
Rule 24    type -> BOOLEAN_TYPE
Rule 25    type -> QUEUE_TYPE
Rule 26    type -> STRING_TYPE
Rule 27    type -> ENUM_TYPE
Rule 28    type -> VAR
Rule 29    type -> LIST_TYPE
Rule 30    type -> MAP_TYPE
Rule 31    type -> SET_TYPE
Rule 32    type -> DYNAMIC_TYPE
Rule 33    expression -> arithmetic
Rule 34    expression -> logic
Rule 35    expression -> function_call
Rule 36    arithmetic -> value
Rule 37    arithmetic -> arithmetic arith_op arithmetic
Rule 38    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 39    comparison -> value
Rule 40    comparison -> boolean
Rule 41    comparison -> comparison comp_op comparison
Rule 42    comparison -> LPAREN comparison comp_op comparison RPAREN
Rule 43    logic -> comparison
Rule 44    logic -> logic logic_op logic
Rule 45    logic -> LPAREN logic logic_op logic RPAREN
Rule 46    logic -> LOGICAL_NOT logic
Rule 47    logic_op -> LOGICAL_AND
Rule 48    logic_op -> LOGICAL_OR
Rule 49    arith_op -> PLUS
Rule 50    arith_op -> MINUS
Rule 51    arith_op -> TIMES
Rule 52    arith_op -> DIVIDE
Rule 53    comp_op -> EQUAL
Rule 54    comp_op -> NOT_EQUAL
Rule 55    comp_op -> LESS
Rule 56    comp_op -> LESS_EQUAL
Rule 57    comp_op -> GREATER
Rule 58    comp_op -> GREATER_EQUAL
Rule 59    values -> value
Rule 60    values -> value COMMA values
Rule 61    value -> IDENTIFIER
Rule 62    value -> number
Rule 63    value -> string
Rule 64    value -> list
Rule 65    number -> INTEGER
Rule 66    number -> DOUBLE
Rule 67    string -> STRING
Rule 68    boolean -> TRUE
Rule 69    boolean -> FALSE
Rule 70    list -> LSQUARE RSQUARE
Rule 71    list -> LSQUARE values RSQUARE
Rule 72    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 73    lines -> line LINE_BREAK
Rule 74    lines -> line
Rule 75    lines -> <empty>
Rule 76    line -> print
Rule 77    line -> assignment
Rule 78    line -> function
Rule 79    line -> if_statement
Rule 80    parameters -> VOID
Rule 81    parameters -> parameter
Rule 82    parameters -> parameter COMMA parameters
Rule 83    parameters -> <empty>
Rule 84    parameter -> type IDENTIFIER

Terminals, with rules where they appear

ABSTRACT             : 
AS                   : 
ASSERT               : 
ASSIGN               : 8 9 10 11
ASYNC                : 
AWAIT                : 
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 24
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 60 82
COMMENT              : 
CONST                : 15
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 52
DO                   : 
DOT                  : 
DOUBLE               : 66
DOUBLE_TYPE          : 23
DYNAMIC_TYPE         : 32
ELSE                 : 19 20
ENUM                 : 
ENUM_TYPE            : 27
EQUAL                : 53
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FALSE                : 69
FINAL                : 14
FINALLY              : 
FOR                  : 
GET                  : 
GREATER              : 57
GREATER_EQUAL        : 58
HIDE                 : 
IDENTIFIER           : 8 9 10 11 21 61 72 84
IF                   : 18
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INTEGER              : 65
INTEGER_TYPE         : 22
INTERFACE            : 
IS                   : 
KEYWORD              : 
LATE                 : 13
LBRACE               : 18 20 72
LESS                 : 55
LESS_EQUAL           : 56
LIBRARY              : 
LINE_BREAK           : 73
LIST_TYPE            : 29
LOGICAL_AND          : 47
LOGICAL_NOT          : 46
LOGICAL_OR           : 48
LPAREN               : 16 17 18 21 38 42 45 72
LSQUARE              : 70 71
MAP_TYPE             : 30
MINUS                : 50
NOT_EQUAL            : 54
NULL                 : 
ON                   : 
OPERATOR             : 
PART                 : 
PLUS                 : 49
PRINT                : 16 17
QUESTION_MARK        : 12
QUEUE_TYPE           : 25
RBRACE               : 18 20 72
RETHROW              : 
RETURN               : 
RPAREN               : 16 17 18 21 38 42 45 72
RSQUARE              : 70 71
SEMICOLON            : 8 9 10 11 16 17
SET                  : 
SET_TYPE             : 31
SHOW                 : 
STATIC               : 
STRING               : 67
STRING_TYPE          : 26
SUPER                : 
SWITCH               : 
SYNC                 : 
THROW                : 
TIMES                : 51
TRUE                 : 68
TRY                  : 
TYPEDEF              : 
VAR                  : 28
VOID                 : 80
WHILE                : 
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 37 38
arithmetic           : 33 37 37 38 38
assignment           : 2 77
boolean              : 40
comp_op              : 41 42
comparison           : 41 41 42 42 43
expression           : 1 8 9 10 11 16
function             : 4 78
function_call        : 35
if_statement         : 5 19 19 20 79
line                 : 73 74
lines                : 6 18 20 72
list                 : 64
logic                : 18 34 44 44 45 45 46
logic_op             : 44 45
modifier             : 8 10
nullable             : 8 9
number               : 62
parameter            : 81 82
parameters           : 21 72 82
print                : 3 76
statement            : 0
string               : 63
type                 : 8 9 10 11 72 84
value                : 36 39 59 60
values               : 60 71

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . lines
    (7) statement -> .
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (73) lines -> . line LINE_BREAK
    (74) lines -> . line
    (75) lines -> .
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE
    (76) line -> . print
    (77) line -> . assignment
    (78) line -> . function
    (79) line -> . if_statement
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> .)
    $end            reduce using rule 7 (statement -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

  ! $end            [ reduce using rule 75 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    lines                          shift and go to state 7
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    modifier                       shift and go to state 11
    type                           shift and go to state 12
    line                           shift and go to state 17
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (77) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 77 (line -> assignment .)

  ! $end            [ reduce using rule 77 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (76) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 76 (line -> print .)

  ! $end            [ reduce using rule 76 (line -> print .) ]


state 5

    (4) statement -> function .
    (78) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 78 (line -> function .)

  ! $end            [ reduce using rule 78 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (79) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 45
    LINE_BREAK      reduce using rule 79 (line -> if_statement .)

  ! $end            [ reduce using rule 79 (line -> if_statement .) ]


state 7

    (6) statement -> lines .

    $end            reduce using rule 6 (statement -> lines .)


state 8

    (33) expression -> arithmetic .
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

    $end            reduce using rule 33 (expression -> arithmetic .)
    RPAREN          reduce using rule 33 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 33 (expression -> arithmetic .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

    arith_op                       shift and go to state 46

state 9

    (34) expression -> logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

    $end            reduce using rule 34 (expression -> logic .)
    RPAREN          reduce using rule 34 (expression -> logic .)
    SEMICOLON       reduce using rule 34 (expression -> logic .)
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

    logic_op                       shift and go to state 51

state 10

    (35) expression -> function_call .

    $end            reduce using rule 35 (expression -> function_call .)
    RPAREN          reduce using rule 35 (expression -> function_call .)
    SEMICOLON       reduce using rule 35 (expression -> function_call .)


state 11

    (8) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    type                           shift and go to state 54

state 12

    (9) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (12) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 56
    QUESTION_MARK   shift and go to state 57

    nullable                       shift and go to state 55

state 13

    (21) function_call -> IDENTIFIER . LPAREN parameters RPAREN
    (61) value -> IDENTIFIER .

    LPAREN          shift and go to state 58
    PLUS            reduce using rule 61 (value -> IDENTIFIER .)
    MINUS           reduce using rule 61 (value -> IDENTIFIER .)
    TIMES           reduce using rule 61 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (value -> IDENTIFIER .)
    $end            reduce using rule 61 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 61 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 61 (value -> IDENTIFIER .)
    LESS            reduce using rule 61 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 61 (value -> IDENTIFIER .)
    GREATER         reduce using rule 61 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 61 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (value -> IDENTIFIER .)


state 14

    (16) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (17) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 59


state 15

    (38) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (45) logic -> LPAREN . logic logic_op logic RPAREN
    (42) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 60
    logic                          shift and go to state 61
    comparison                     shift and go to state 62
    value                          shift and go to state 18
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 16

    (18) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 64


state 17

    (73) lines -> line . LINE_BREAK
    (74) lines -> line .

    LINE_BREAK      shift and go to state 65
    $end            reduce using rule 74 (lines -> line .)
    RBRACE          reduce using rule 74 (lines -> line .)


state 18

    (36) arithmetic -> value .
    (39) comparison -> value .

  ! reduce/reduce conflict for $end resolved using rule 36 (arithmetic -> value .)
  ! reduce/reduce conflict for RPAREN resolved using rule 36 (arithmetic -> value .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (arithmetic -> value .)
    PLUS            reduce using rule 36 (arithmetic -> value .)
    MINUS           reduce using rule 36 (arithmetic -> value .)
    TIMES           reduce using rule 36 (arithmetic -> value .)
    DIVIDE          reduce using rule 36 (arithmetic -> value .)
    $end            reduce using rule 36 (arithmetic -> value .)
    RPAREN          reduce using rule 36 (arithmetic -> value .)
    SEMICOLON       reduce using rule 36 (arithmetic -> value .)
    EQUAL           reduce using rule 39 (comparison -> value .)
    NOT_EQUAL       reduce using rule 39 (comparison -> value .)
    LESS            reduce using rule 39 (comparison -> value .)
    LESS_EQUAL      reduce using rule 39 (comparison -> value .)
    GREATER         reduce using rule 39 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 39 (comparison -> value .)
    LOGICAL_AND     reduce using rule 39 (comparison -> value .)
    LOGICAL_OR      reduce using rule 39 (comparison -> value .)

  ! $end            [ reduce using rule 39 (comparison -> value .) ]
  ! RPAREN          [ reduce using rule 39 (comparison -> value .) ]
  ! SEMICOLON       [ reduce using rule 39 (comparison -> value .) ]


state 19

    (43) logic -> comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 43 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 43 (logic -> comparison .)
    $end            reduce using rule 43 (logic -> comparison .)
    RPAREN          reduce using rule 43 (logic -> comparison .)
    SEMICOLON       reduce using rule 43 (logic -> comparison .)
    EQUAL           shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    LESS            shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER         shift and go to state 71
    GREATER_EQUAL   shift and go to state 72

    comp_op                        shift and go to state 66

state 20

    (46) logic -> LOGICAL_NOT . logic
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 74
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 73
    comparison                     shift and go to state 19
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 21

    (13) modifier -> LATE .

    INTEGER_TYPE    reduce using rule 13 (modifier -> LATE .)
    DOUBLE_TYPE     reduce using rule 13 (modifier -> LATE .)
    BOOLEAN_TYPE    reduce using rule 13 (modifier -> LATE .)
    QUEUE_TYPE      reduce using rule 13 (modifier -> LATE .)
    STRING_TYPE     reduce using rule 13 (modifier -> LATE .)
    ENUM_TYPE       reduce using rule 13 (modifier -> LATE .)
    VAR             reduce using rule 13 (modifier -> LATE .)
    LIST_TYPE       reduce using rule 13 (modifier -> LATE .)
    MAP_TYPE        reduce using rule 13 (modifier -> LATE .)
    SET_TYPE        reduce using rule 13 (modifier -> LATE .)
    DYNAMIC_TYPE    reduce using rule 13 (modifier -> LATE .)


state 22

    (14) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 14 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 14 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 14 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 14 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 14 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 14 (modifier -> FINAL .)
    VAR             reduce using rule 14 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 14 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 14 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 14 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 14 (modifier -> FINAL .)


state 23

    (15) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 15 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 15 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 15 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 15 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 15 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 15 (modifier -> CONST .)
    VAR             reduce using rule 15 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 15 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 15 (modifier -> CONST .)
    SET_TYPE        reduce using rule 15 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 15 (modifier -> CONST .)


state 24

    (22) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 22 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 22 (type -> INTEGER_TYPE .)


state 25

    (23) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 23 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 23 (type -> DOUBLE_TYPE .)


state 26

    (24) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 24 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 24 (type -> BOOLEAN_TYPE .)


state 27

    (25) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 25 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 25 (type -> QUEUE_TYPE .)


state 28

    (26) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 26 (type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 26 (type -> STRING_TYPE .)


state 29

    (27) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 27 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 27 (type -> ENUM_TYPE .)


state 30

    (28) type -> VAR .

    IDENTIFIER      reduce using rule 28 (type -> VAR .)
    QUESTION_MARK   reduce using rule 28 (type -> VAR .)


state 31

    (29) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 29 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 29 (type -> LIST_TYPE .)


state 32

    (30) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 30 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 30 (type -> MAP_TYPE .)


state 33

    (31) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 31 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 31 (type -> SET_TYPE .)


state 34

    (32) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 32 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 32 (type -> DYNAMIC_TYPE .)


state 35

    (62) value -> number .

    PLUS            reduce using rule 62 (value -> number .)
    MINUS           reduce using rule 62 (value -> number .)
    TIMES           reduce using rule 62 (value -> number .)
    DIVIDE          reduce using rule 62 (value -> number .)
    $end            reduce using rule 62 (value -> number .)
    EQUAL           reduce using rule 62 (value -> number .)
    NOT_EQUAL       reduce using rule 62 (value -> number .)
    LESS            reduce using rule 62 (value -> number .)
    LESS_EQUAL      reduce using rule 62 (value -> number .)
    GREATER         reduce using rule 62 (value -> number .)
    GREATER_EQUAL   reduce using rule 62 (value -> number .)
    LOGICAL_AND     reduce using rule 62 (value -> number .)
    LOGICAL_OR      reduce using rule 62 (value -> number .)
    RPAREN          reduce using rule 62 (value -> number .)
    SEMICOLON       reduce using rule 62 (value -> number .)
    COMMA           reduce using rule 62 (value -> number .)
    RSQUARE         reduce using rule 62 (value -> number .)


state 36

    (63) value -> string .

    PLUS            reduce using rule 63 (value -> string .)
    MINUS           reduce using rule 63 (value -> string .)
    TIMES           reduce using rule 63 (value -> string .)
    DIVIDE          reduce using rule 63 (value -> string .)
    $end            reduce using rule 63 (value -> string .)
    EQUAL           reduce using rule 63 (value -> string .)
    NOT_EQUAL       reduce using rule 63 (value -> string .)
    LESS            reduce using rule 63 (value -> string .)
    LESS_EQUAL      reduce using rule 63 (value -> string .)
    GREATER         reduce using rule 63 (value -> string .)
    GREATER_EQUAL   reduce using rule 63 (value -> string .)
    LOGICAL_AND     reduce using rule 63 (value -> string .)
    LOGICAL_OR      reduce using rule 63 (value -> string .)
    RPAREN          reduce using rule 63 (value -> string .)
    SEMICOLON       reduce using rule 63 (value -> string .)
    COMMA           reduce using rule 63 (value -> string .)
    RSQUARE         reduce using rule 63 (value -> string .)


state 37

    (64) value -> list .

    PLUS            reduce using rule 64 (value -> list .)
    MINUS           reduce using rule 64 (value -> list .)
    TIMES           reduce using rule 64 (value -> list .)
    DIVIDE          reduce using rule 64 (value -> list .)
    $end            reduce using rule 64 (value -> list .)
    EQUAL           reduce using rule 64 (value -> list .)
    NOT_EQUAL       reduce using rule 64 (value -> list .)
    LESS            reduce using rule 64 (value -> list .)
    LESS_EQUAL      reduce using rule 64 (value -> list .)
    GREATER         reduce using rule 64 (value -> list .)
    GREATER_EQUAL   reduce using rule 64 (value -> list .)
    LOGICAL_AND     reduce using rule 64 (value -> list .)
    LOGICAL_OR      reduce using rule 64 (value -> list .)
    RPAREN          reduce using rule 64 (value -> list .)
    SEMICOLON       reduce using rule 64 (value -> list .)
    COMMA           reduce using rule 64 (value -> list .)
    RSQUARE         reduce using rule 64 (value -> list .)


state 38

    (40) comparison -> boolean .

    EQUAL           reduce using rule 40 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 40 (comparison -> boolean .)
    LESS            reduce using rule 40 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 40 (comparison -> boolean .)
    GREATER         reduce using rule 40 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 40 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 40 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 40 (comparison -> boolean .)
    $end            reduce using rule 40 (comparison -> boolean .)
    RPAREN          reduce using rule 40 (comparison -> boolean .)
    SEMICOLON       reduce using rule 40 (comparison -> boolean .)


state 39

    (65) number -> INTEGER .

    PLUS            reduce using rule 65 (number -> INTEGER .)
    MINUS           reduce using rule 65 (number -> INTEGER .)
    TIMES           reduce using rule 65 (number -> INTEGER .)
    DIVIDE          reduce using rule 65 (number -> INTEGER .)
    $end            reduce using rule 65 (number -> INTEGER .)
    EQUAL           reduce using rule 65 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 65 (number -> INTEGER .)
    LESS            reduce using rule 65 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 65 (number -> INTEGER .)
    GREATER         reduce using rule 65 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 65 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 65 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 65 (number -> INTEGER .)
    RPAREN          reduce using rule 65 (number -> INTEGER .)
    SEMICOLON       reduce using rule 65 (number -> INTEGER .)
    COMMA           reduce using rule 65 (number -> INTEGER .)
    RSQUARE         reduce using rule 65 (number -> INTEGER .)


state 40

    (66) number -> DOUBLE .

    PLUS            reduce using rule 66 (number -> DOUBLE .)
    MINUS           reduce using rule 66 (number -> DOUBLE .)
    TIMES           reduce using rule 66 (number -> DOUBLE .)
    DIVIDE          reduce using rule 66 (number -> DOUBLE .)
    $end            reduce using rule 66 (number -> DOUBLE .)
    EQUAL           reduce using rule 66 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 66 (number -> DOUBLE .)
    LESS            reduce using rule 66 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 66 (number -> DOUBLE .)
    GREATER         reduce using rule 66 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 66 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 66 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 66 (number -> DOUBLE .)
    RPAREN          reduce using rule 66 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 66 (number -> DOUBLE .)
    COMMA           reduce using rule 66 (number -> DOUBLE .)
    RSQUARE         reduce using rule 66 (number -> DOUBLE .)


state 41

    (67) string -> STRING .

    PLUS            reduce using rule 67 (string -> STRING .)
    MINUS           reduce using rule 67 (string -> STRING .)
    TIMES           reduce using rule 67 (string -> STRING .)
    DIVIDE          reduce using rule 67 (string -> STRING .)
    $end            reduce using rule 67 (string -> STRING .)
    EQUAL           reduce using rule 67 (string -> STRING .)
    NOT_EQUAL       reduce using rule 67 (string -> STRING .)
    LESS            reduce using rule 67 (string -> STRING .)
    LESS_EQUAL      reduce using rule 67 (string -> STRING .)
    GREATER         reduce using rule 67 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 67 (string -> STRING .)
    LOGICAL_AND     reduce using rule 67 (string -> STRING .)
    LOGICAL_OR      reduce using rule 67 (string -> STRING .)
    RPAREN          reduce using rule 67 (string -> STRING .)
    SEMICOLON       reduce using rule 67 (string -> STRING .)
    COMMA           reduce using rule 67 (string -> STRING .)
    RSQUARE         reduce using rule 67 (string -> STRING .)


state 42

    (70) list -> LSQUARE . RSQUARE
    (71) list -> LSQUARE . values RSQUARE
    (59) values -> . value
    (60) values -> . value COMMA values
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 76
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    values                         shift and go to state 77
    value                          shift and go to state 78
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 43

    (68) boolean -> TRUE .

    EQUAL           reduce using rule 68 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 68 (boolean -> TRUE .)
    LESS            reduce using rule 68 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 68 (boolean -> TRUE .)
    GREATER         reduce using rule 68 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 68 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 68 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 68 (boolean -> TRUE .)
    $end            reduce using rule 68 (boolean -> TRUE .)
    RPAREN          reduce using rule 68 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 68 (boolean -> TRUE .)


state 44

    (69) boolean -> FALSE .

    EQUAL           reduce using rule 69 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 69 (boolean -> FALSE .)
    LESS            reduce using rule 69 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 69 (boolean -> FALSE .)
    GREATER         reduce using rule 69 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 69 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 69 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 69 (boolean -> FALSE .)
    $end            reduce using rule 69 (boolean -> FALSE .)
    RPAREN          reduce using rule 69 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 69 (boolean -> FALSE .)


state 45

    (19) if_statement -> if_statement ELSE . if_statement
    (20) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 80
    IF              shift and go to state 16

    if_statement                   shift and go to state 79

state 46

    (37) arithmetic -> arithmetic arith_op . arithmetic
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 83
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 81
    value                          shift and go to state 82
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 47

    (49) arith_op -> PLUS .

    LPAREN          reduce using rule 49 (arith_op -> PLUS .)
    IDENTIFIER      reduce using rule 49 (arith_op -> PLUS .)
    INTEGER         reduce using rule 49 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 49 (arith_op -> PLUS .)
    STRING          reduce using rule 49 (arith_op -> PLUS .)
    LSQUARE         reduce using rule 49 (arith_op -> PLUS .)


state 48

    (50) arith_op -> MINUS .

    LPAREN          reduce using rule 50 (arith_op -> MINUS .)
    IDENTIFIER      reduce using rule 50 (arith_op -> MINUS .)
    INTEGER         reduce using rule 50 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 50 (arith_op -> MINUS .)
    STRING          reduce using rule 50 (arith_op -> MINUS .)
    LSQUARE         reduce using rule 50 (arith_op -> MINUS .)


state 49

    (51) arith_op -> TIMES .

    LPAREN          reduce using rule 51 (arith_op -> TIMES .)
    IDENTIFIER      reduce using rule 51 (arith_op -> TIMES .)
    INTEGER         reduce using rule 51 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 51 (arith_op -> TIMES .)
    STRING          reduce using rule 51 (arith_op -> TIMES .)
    LSQUARE         reduce using rule 51 (arith_op -> TIMES .)


state 50

    (52) arith_op -> DIVIDE .

    LPAREN          reduce using rule 52 (arith_op -> DIVIDE .)
    IDENTIFIER      reduce using rule 52 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 52 (arith_op -> DIVIDE .)
    DOUBLE          reduce using rule 52 (arith_op -> DIVIDE .)
    STRING          reduce using rule 52 (arith_op -> DIVIDE .)
    LSQUARE         reduce using rule 52 (arith_op -> DIVIDE .)


state 51

    (44) logic -> logic logic_op . logic
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 74
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 84
    comparison                     shift and go to state 19
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 52

    (47) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 47 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 47 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 47 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 47 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 47 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 47 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 47 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 47 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 47 (logic_op -> LOGICAL_AND .)


state 53

    (48) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 48 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 48 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 48 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 48 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 48 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 48 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 48 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 48 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 48 (logic_op -> LOGICAL_OR .)


state 54

    (8) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (12) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 86
    QUESTION_MARK   shift and go to state 57

    nullable                       shift and go to state 85

state 55

    (9) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 87


state 56

    (11) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (72) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 88
    LPAREN          shift and go to state 89


state 57

    (12) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 12 (nullable -> QUESTION_MARK .)


state 58

    (21) function_call -> IDENTIFIER LPAREN . parameters RPAREN
    (80) parameters -> . VOID
    (81) parameters -> . parameter
    (82) parameters -> . parameter COMMA parameters
    (83) parameters -> .
    (84) parameter -> . type IDENTIFIER
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 91
    RPAREN          reduce using rule 83 (parameters -> .)
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    parameters                     shift and go to state 90
    parameter                      shift and go to state 92
    type                           shift and go to state 93

state 59

    (16) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (17) print -> PRINT LPAREN . RPAREN SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    RPAREN          shift and go to state 95
    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 94
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 60

    (38) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

    arith_op                       shift and go to state 96

state 61

    (45) logic -> LPAREN logic . logic_op logic RPAREN
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

    logic_op                       shift and go to state 97

state 62

    (42) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (43) logic -> comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 43 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 43 (logic -> comparison .)
    EQUAL           shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    LESS            shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER         shift and go to state 71
    GREATER_EQUAL   shift and go to state 72

    comp_op                        shift and go to state 98

state 63

    (61) value -> IDENTIFIER .

    PLUS            reduce using rule 61 (value -> IDENTIFIER .)
    MINUS           reduce using rule 61 (value -> IDENTIFIER .)
    TIMES           reduce using rule 61 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 61 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 61 (value -> IDENTIFIER .)
    LESS            reduce using rule 61 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 61 (value -> IDENTIFIER .)
    GREATER         reduce using rule 61 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 61 (value -> IDENTIFIER .)
    $end            reduce using rule 61 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (value -> IDENTIFIER .)
    COMMA           reduce using rule 61 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 61 (value -> IDENTIFIER .)


state 64

    (18) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 74
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 99
    comparison                     shift and go to state 19
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 65

    (73) lines -> line LINE_BREAK .

    $end            reduce using rule 73 (lines -> line LINE_BREAK .)
    RBRACE          reduce using rule 73 (lines -> line LINE_BREAK .)


state 66

    (41) comparison -> comparison comp_op . comparison
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 101
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    comparison                     shift and go to state 100
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 67

    (53) comp_op -> EQUAL .

    LPAREN          reduce using rule 53 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 53 (comp_op -> EQUAL .)
    TRUE            reduce using rule 53 (comp_op -> EQUAL .)
    FALSE           reduce using rule 53 (comp_op -> EQUAL .)
    INTEGER         reduce using rule 53 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 53 (comp_op -> EQUAL .)
    STRING          reduce using rule 53 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 53 (comp_op -> EQUAL .)


state 68

    (54) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 54 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 54 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 54 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 54 (comp_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 54 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 54 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 54 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 54 (comp_op -> NOT_EQUAL .)


state 69

    (55) comp_op -> LESS .

    LPAREN          reduce using rule 55 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 55 (comp_op -> LESS .)
    TRUE            reduce using rule 55 (comp_op -> LESS .)
    FALSE           reduce using rule 55 (comp_op -> LESS .)
    INTEGER         reduce using rule 55 (comp_op -> LESS .)
    DOUBLE          reduce using rule 55 (comp_op -> LESS .)
    STRING          reduce using rule 55 (comp_op -> LESS .)
    LSQUARE         reduce using rule 55 (comp_op -> LESS .)


state 70

    (56) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 56 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 56 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 56 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 56 (comp_op -> LESS_EQUAL .)
    INTEGER         reduce using rule 56 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 56 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 56 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 56 (comp_op -> LESS_EQUAL .)


state 71

    (57) comp_op -> GREATER .

    LPAREN          reduce using rule 57 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 57 (comp_op -> GREATER .)
    TRUE            reduce using rule 57 (comp_op -> GREATER .)
    FALSE           reduce using rule 57 (comp_op -> GREATER .)
    INTEGER         reduce using rule 57 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 57 (comp_op -> GREATER .)
    STRING          reduce using rule 57 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 57 (comp_op -> GREATER .)


state 72

    (58) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 58 (comp_op -> GREATER_EQUAL .)


state 73

    (46) logic -> LOGICAL_NOT logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 46 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 46 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 46 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

  ! LOGICAL_AND     [ reduce using rule 46 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 46 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 51

state 74

    (45) logic -> LPAREN . logic logic_op logic RPAREN
    (42) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 74
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 61
    comparison                     shift and go to state 62
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 75

    (39) comparison -> value .

    EQUAL           reduce using rule 39 (comparison -> value .)
    NOT_EQUAL       reduce using rule 39 (comparison -> value .)
    LESS            reduce using rule 39 (comparison -> value .)
    LESS_EQUAL      reduce using rule 39 (comparison -> value .)
    GREATER         reduce using rule 39 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 39 (comparison -> value .)
    LOGICAL_AND     reduce using rule 39 (comparison -> value .)
    LOGICAL_OR      reduce using rule 39 (comparison -> value .)
    $end            reduce using rule 39 (comparison -> value .)
    RPAREN          reduce using rule 39 (comparison -> value .)
    SEMICOLON       reduce using rule 39 (comparison -> value .)


state 76

    (70) list -> LSQUARE RSQUARE .

    PLUS            reduce using rule 70 (list -> LSQUARE RSQUARE .)
    MINUS           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    TIMES           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    DIVIDE          reduce using rule 70 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 70 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 70 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 70 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 70 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 70 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 70 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 70 (list -> LSQUARE RSQUARE .)


state 77

    (71) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 102


state 78

    (59) values -> value .
    (60) values -> value . COMMA values

    RSQUARE         reduce using rule 59 (values -> value .)
    COMMA           shift and go to state 103


state 79

    (19) if_statement -> if_statement ELSE if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 45

  ! ELSE            [ reduce using rule 19 (if_statement -> if_statement ELSE if_statement .) ]


state 80

    (20) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (73) lines -> . line LINE_BREAK
    (74) lines -> . line
    (75) lines -> .
    (76) line -> . print
    (77) line -> . assignment
    (78) line -> . function
    (79) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    RBRACE          reduce using rule 75 (lines -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    if_statement                   shift and go to state 104
    lines                          shift and go to state 105
    line                           shift and go to state 17
    print                          shift and go to state 106
    assignment                     shift and go to state 107
    function                       shift and go to state 108
    modifier                       shift and go to state 11
    type                           shift and go to state 12

state 81

    (37) arithmetic -> arithmetic arith_op arithmetic .
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    $end            reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

  ! PLUS            [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 46

state 82

    (36) arithmetic -> value .

    PLUS            reduce using rule 36 (arithmetic -> value .)
    MINUS           reduce using rule 36 (arithmetic -> value .)
    TIMES           reduce using rule 36 (arithmetic -> value .)
    DIVIDE          reduce using rule 36 (arithmetic -> value .)
    $end            reduce using rule 36 (arithmetic -> value .)
    RPAREN          reduce using rule 36 (arithmetic -> value .)
    SEMICOLON       reduce using rule 36 (arithmetic -> value .)


state 83

    (38) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 83
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 60
    value                          shift and go to state 82
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 84

    (44) logic -> logic logic_op logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 44 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 44 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 44 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

  ! LOGICAL_AND     [ reduce using rule 44 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 44 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 51

state 85

    (8) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 109


state 86

    (10) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 110


state 87

    (9) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 111


state 88

    (11) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 112
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 89

    (72) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (80) parameters -> . VOID
    (81) parameters -> . parameter
    (82) parameters -> . parameter COMMA parameters
    (83) parameters -> .
    (84) parameter -> . type IDENTIFIER
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 91
    RPAREN          reduce using rule 83 (parameters -> .)
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    type                           shift and go to state 93
    parameters                     shift and go to state 113
    parameter                      shift and go to state 92

state 90

    (21) function_call -> IDENTIFIER LPAREN parameters . RPAREN

    RPAREN          shift and go to state 114


state 91

    (80) parameters -> VOID .

    RPAREN          reduce using rule 80 (parameters -> VOID .)


state 92

    (81) parameters -> parameter .
    (82) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 81 (parameters -> parameter .)
    COMMA           shift and go to state 115


state 93

    (84) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 116


state 94

    (16) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 117


state 95

    (17) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 118


state 96

    (38) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (37) arithmetic -> arithmetic arith_op . arithmetic
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 83
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 119
    value                          shift and go to state 82
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 97

    (45) logic -> LPAREN logic logic_op . logic RPAREN
    (44) logic -> logic logic_op . logic
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 74
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 120
    comparison                     shift and go to state 19
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 98

    (42) comparison -> LPAREN comparison comp_op . comparison RPAREN
    (41) comparison -> comparison comp_op . comparison
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 101
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    comparison                     shift and go to state 121
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 99

    (18) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 122
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

    logic_op                       shift and go to state 51

state 100

    (41) comparison -> comparison comp_op comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 41 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 41 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 41 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 41 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 41 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    LESS            shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER         shift and go to state 71
    GREATER_EQUAL   shift and go to state 72

  ! EQUAL           [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 66

state 101

    (42) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 101
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    comparison                     shift and go to state 123
    value                          shift and go to state 75
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 102

    (71) list -> LSQUARE values RSQUARE .

    PLUS            reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    MINUS           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    TIMES           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    DIVIDE          reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 71 (list -> LSQUARE values RSQUARE .)


state 103

    (60) values -> value COMMA . values
    (59) values -> . value
    (60) values -> . value COMMA values
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    value                          shift and go to state 78
    values                         shift and go to state 124
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 104

    (79) line -> if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 79 (line -> if_statement .)
    RBRACE          reduce using rule 79 (line -> if_statement .)
    ELSE            shift and go to state 45


state 105

    (20) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 125


state 106

    (76) line -> print .

    LINE_BREAK      reduce using rule 76 (line -> print .)
    RBRACE          reduce using rule 76 (line -> print .)


state 107

    (77) line -> assignment .

    LINE_BREAK      reduce using rule 77 (line -> assignment .)
    RBRACE          reduce using rule 77 (line -> assignment .)


state 108

    (78) line -> function .

    LINE_BREAK      reduce using rule 78 (line -> function .)
    RBRACE          reduce using rule 78 (line -> function .)


state 109

    (8) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 126


state 110

    (10) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 127
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 111

    (9) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 128
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 112

    (11) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 129


state 113

    (72) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 130


state 114

    (21) function_call -> IDENTIFIER LPAREN parameters RPAREN .

    $end            reduce using rule 21 (function_call -> IDENTIFIER LPAREN parameters RPAREN .)
    RPAREN          reduce using rule 21 (function_call -> IDENTIFIER LPAREN parameters RPAREN .)
    SEMICOLON       reduce using rule 21 (function_call -> IDENTIFIER LPAREN parameters RPAREN .)


state 115

    (82) parameters -> parameter COMMA . parameters
    (80) parameters -> . VOID
    (81) parameters -> . parameter
    (82) parameters -> . parameter COMMA parameters
    (83) parameters -> .
    (84) parameter -> . type IDENTIFIER
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 91
    RPAREN          reduce using rule 83 (parameters -> .)
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    parameter                      shift and go to state 92
    parameters                     shift and go to state 131
    type                           shift and go to state 93

state 116

    (84) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 84 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 84 (parameter -> type IDENTIFIER .)


state 117

    (16) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 132


state 118

    (17) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 119

    (38) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (37) arithmetic -> arithmetic arith_op arithmetic .
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    RPAREN          shift and go to state 133
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

  ! PLUS            [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 46

state 120

    (45) logic -> LPAREN logic logic_op logic . RPAREN
    (44) logic -> logic logic_op logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 134
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

  ! LOGICAL_AND     [ reduce using rule 44 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 44 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 51

state 121

    (42) comparison -> LPAREN comparison comp_op comparison . RPAREN
    (41) comparison -> comparison comp_op comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    RPAREN          shift and go to state 135
    LOGICAL_AND     reduce using rule 41 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 41 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    LESS            shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER         shift and go to state 71
    GREATER_EQUAL   shift and go to state 72

  ! EQUAL           [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 66

state 122

    (18) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 136


state 123

    (42) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    LESS            shift and go to state 69
    LESS_EQUAL      shift and go to state 70
    GREATER         shift and go to state 71
    GREATER_EQUAL   shift and go to state 72

    comp_op                        shift and go to state 98

state 124

    (60) values -> value COMMA values .

    RSQUARE         reduce using rule 60 (values -> value COMMA values .)


state 125

    (20) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 126

    (8) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 137
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 127

    (10) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 138


state 128

    (9) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 139


state 129

    (11) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 130

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 140


state 131

    (82) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 82 (parameters -> parameter COMMA parameters .)


state 132

    (16) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 133

    (38) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DIVIDE          reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 134

    (45) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)


state 135

    (42) comparison -> LPAREN comparison comp_op comparison RPAREN .

    EQUAL           reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    NOT_EQUAL       reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS            reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS_EQUAL      reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER         reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER_EQUAL   reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_AND     reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_OR      reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    $end            reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RPAREN          reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SEMICOLON       reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)


state 136

    (18) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (73) lines -> . line LINE_BREAK
    (74) lines -> . line
    (75) lines -> .
    (76) line -> . print
    (77) line -> . assignment
    (78) line -> . function
    (79) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    RBRACE          reduce using rule 75 (lines -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    lines                          shift and go to state 141
    line                           shift and go to state 17
    print                          shift and go to state 106
    assignment                     shift and go to state 107
    function                       shift and go to state 108
    if_statement                   shift and go to state 104
    modifier                       shift and go to state 11
    type                           shift and go to state 12

state 137

    (8) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 142


state 138

    (10) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 139

    (9) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 140

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (73) lines -> . line LINE_BREAK
    (74) lines -> . line
    (75) lines -> .
    (76) line -> . print
    (77) line -> . assignment
    (78) line -> . function
    (79) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    RBRACE          reduce using rule 75 (lines -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    type                           shift and go to state 12
    lines                          shift and go to state 143
    line                           shift and go to state 17
    print                          shift and go to state 106
    assignment                     shift and go to state 107
    function                       shift and go to state 108
    if_statement                   shift and go to state 104
    modifier                       shift and go to state 11

state 141

    (18) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 144


state 142

    (8) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 143

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 145


state 144

    (18) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 145

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 73 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 73 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 84 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 84 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 100 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 100 resolved as shift
WARNING: shift/reduce conflict for LESS in state 100 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 100 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 100 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 100 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 120 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 121 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 18 resolved using rule (arithmetic -> value)
WARNING: rejected rule (comparison -> value) in state 18
