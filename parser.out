Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COMMENT
    CONTINUE
    DEFAULT
    DO
    DOT
    ENUM
    EXTENDS
    FINALLY
    GET
    IMPLEMENTS
    IN
    RETURN
    SWITCH
    THROW
    TRY
    TYPEDEF
    ZERO

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> reassignment
Rule 11    statement -> <empty>
Rule 12    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 16    assignment -> type IDENTIFIER ASSIGN expression
Rule 17    assignment -> string_assignment
Rule 18    assignment -> list_assigment
Rule 19    assignment -> map_assigment
Rule 20    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 21    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic
Rule 22    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 23    int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 24    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 25    int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 26    int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 27    string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON
Rule 28    string_assignment -> type_string IDENTIFIER ASSIGN concate
Rule 29    string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 30    string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 31    string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 32    string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 33    string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
Rule 34    number_type -> INTEGER_TYPE
Rule 35    number_type -> VAR
Rule 36    number_type -> DOUBLE_TYPE
Rule 37    type_string -> STRING_TYPE
Rule 38    type_string -> VAR
Rule 39    reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 40    reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 41    reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 42    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 43    reassignment -> IDENTIFIER INLINE_ARITH
Rule 44    nullable -> QUESTION_MARK
Rule 45    modifier -> FINAL
Rule 46    modifier -> CONST
Rule 47    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 48    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 49    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 50    if_statement -> if_statement ELSE if_statement
Rule 51    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 52    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 53    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 54    function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON
Rule 55    function_call -> IDENTIFIER LPAREN RPAREN
Rule 56    type -> INTEGER_TYPE
Rule 57    type -> DOUBLE_TYPE
Rule 58    type -> BOOLEAN_TYPE
Rule 59    type -> QUEUE_TYPE
Rule 60    type -> STRING_TYPE
Rule 61    type -> ENUM_TYPE
Rule 62    type -> VAR
Rule 63    type -> LIST_TYPE
Rule 64    type -> MAP_TYPE
Rule 65    type -> SET_TYPE
Rule 66    type -> DYNAMIC_TYPE
Rule 67    type -> VOID
Rule 68    expression -> arithmetic
Rule 69    expression -> concate
Rule 70    expression -> logic
Rule 71    expression -> function_call
Rule 72    expression -> division
Rule 73    arithmetic -> number
Rule 74    arithmetic -> arithmetic arith_op arithmetic
Rule 75    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 76    division -> number DIVIDE number
Rule 77    concate -> string
Rule 78    concate -> concate PLUS concate
Rule 79    concate -> LPAREN concate PLUS concate RPAREN
Rule 80    comparison -> values
Rule 81    comparison -> boolean
Rule 82    comparison -> comparison comp_op comparison
Rule 83    comparison -> LPAREN comparison comp_op number comparison
Rule 84    comparison -> int_comparison
Rule 85    comparison -> string_comparison
Rule 86    int_comparison -> boolean
Rule 87    int_comparison -> number comp_op number
Rule 88    int_comparison -> LPAREN number comp_op number RPAREN
Rule 89    string_comparison -> boolean
Rule 90    string_comparison -> string comp_op string
Rule 91    string_comparison -> LPAREN string comp_op string RPAREN
Rule 92    logic -> comparison
Rule 93    logic -> logic logic_op logic
Rule 94    logic -> LPAREN logic logic_op logic RPAREN
Rule 95    logic -> LOGICAL_NOT logic
Rule 96    logic_op -> LOGICAL_AND
Rule 97    logic_op -> LOGICAL_OR
Rule 98    arith_op -> PLUS
Rule 99    arith_op -> MINUS
Rule 100   arith_op -> TIMES
Rule 101   comp_op -> EQUAL
Rule 102   comp_op -> NOT_EQUAL
Rule 103   comp_op -> LESS
Rule 104   comp_op -> LESS_EQUAL
Rule 105   comp_op -> GREATER
Rule 106   comp_op -> GREATER_EQUAL
Rule 107   values -> value
Rule 108   values -> value COMMA values
Rule 109   value -> IDENTIFIER
Rule 110   value -> number
Rule 111   value -> string
Rule 112   value -> list
Rule 113   number -> INTEGER
Rule 114   number -> DOUBLE
Rule 115   string -> STRING
Rule 116   boolean -> TRUE
Rule 117   boolean -> FALSE
Rule 118   list -> LSQUARE RSQUARE
Rule 119   list -> LSQUARE values RSQUARE
Rule 120   list_assigment -> IDENTIFIER ASSIGN list SEMICOLON
Rule 121   list_assigment -> type ASSIGN list SEMICOLON
Rule 122   function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 123   lines -> line LINE_BREAK lines
Rule 124   lines -> line lines
Rule 125   lines -> line
Rule 126   lines -> LINE_BREAK
Rule 127   lines -> <empty>
Rule 128   line -> print
Rule 129   line -> assignment
Rule 130   line -> function
Rule 131   line -> if_statement
Rule 132   line -> while_statement
Rule 133   line -> for_statement
Rule 134   line -> function_call
Rule 135   line -> reassignment
Rule 136   parameters -> VOID
Rule 137   parameters -> parameter
Rule 138   parameters -> parameter COMMA parameters
Rule 139   parameters -> <empty>
Rule 140   parameter -> type IDENTIFIER
Rule 141   parameter -> IDENTIFIER
Rule 142   map -> MAP_TYPE LESS type COMMA type GREATER
Rule 143   map -> MAP_TYPE
Rule 144   map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
Rule 145   map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
Rule 146   map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
Rule 147   map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
Rule 148   map_values -> type COLON type
Rule 149   map_values -> type COLON type COMMA map_values
Rule 150   set -> SET_TYPE LESS type GREATER
Rule 151   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 152   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 153   queue -> QUEUE_TYPE LESS type GREATER
Rule 154   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 155   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 156   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 157   for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
ASSIGN               : 12 13 14 15 16 20 21 22 23 24 25 26 27 28 29 30 31 32 33 39 120 121 144 145 146 147
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 58
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 148 149
COMMA                : 108 138 142 149
COMMENT              : 
CONST                : 46
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 76
DO                   : 
DOT                  : 
DOUBLE               : 114
DOUBLE_TYPE          : 36 57
DYNAMIC_TYPE         : 66
ELSE                 : 50 51
ENUM                 : 
ENUM_TYPE            : 61
EQUAL                : 101
EXTENDS              : 
FALSE                : 117
FINAL                : 45
FINALLY              : 
FOR                  : 157
GET                  : 
GREATER              : 105 142 150 151 152 153 154 155
GREATER_EQUAL        : 106
IDENTIFIER           : 12 13 14 15 16 20 21 22 23 24 25 26 27 28 29 30 31 32 33 39 40 41 42 43 52 53 54 55 109 120 122 140 141 144 145 146 146 147
IF                   : 49
IMPLEMENTS           : 
IN                   : 
INLINE_ARITH         : 40 41 42 43
INTEGER              : 113
INTEGER_TYPE         : 34 56
LBRACE               : 9 49 51 122 144 145 146 147 156 157
LESS                 : 103 142 150 151 152 153 154 155
LESS_EQUAL           : 104
LINE_BREAK           : 123 126
LIST_TYPE            : 63
LOGICAL_AND          : 96
LOGICAL_NOT          : 95
LOGICAL_OR           : 97
LPAREN               : 47 48 49 52 53 54 55 75 79 83 88 91 94 122 156 157
LSQUARE              : 118 119 151 152 154 155
MAP_TYPE             : 64 142 143
MINUS                : 99
NOT_EQUAL            : 102
NULL                 : 22 23 29 30
PLUS                 : 78 79 98
PRINT                : 47 48
QUESTION_MARK        : 44
QUEUE_TYPE           : 59 153 154 155
RBRACE               : 9 49 51 122 144 145 146 147 156 157
RETURN               : 
RPAREN               : 47 48 49 52 53 54 55 75 79 88 91 94 122 156 157
RSQUARE              : 118 119 151 152 154 155
SEMICOLON            : 12 13 14 15 20 22 23 24 25 26 27 29 30 31 32 33 39 40 41 47 48 52 54 120 121 144 145 146 147 157
SET_TYPE             : 65 150 151 152
STRING               : 115
STRING_TYPE          : 37 60
SWITCH               : 
THROW                : 
TIMES                : 100
TRUE                 : 116
TRY                  : 
TYPEDEF              : 
VAR                  : 35 38 62
VOID                 : 67 136
WHILE                : 156
ZERO                 : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 74 75
arithmetic           : 20 21 24 25 26 68 74 74 75 75
assignment           : 2 129 157
boolean              : 81 86 89
comp_op              : 82 83 87 88 90 91
comparison           : 82 82 83 83 92
concate              : 27 28 31 32 33 69 78 78 79 79
division             : 72
expression           : 1 12 13 14 15 16 39 47
for_statement        : 7 133
function             : 4 130
function_call        : 71 134
if_statement         : 5 50 50 51 131
int_assignment       : 
int_comparison       : 84
line                 : 123 124 125
lines                : 8 9 49 51 122 123 124 156 157
list                 : 112 120 121
list_assigment       : 18
logic                : 49 70 93 93 94 94 95 156 157
logic_op             : 93 94
map                  : 144 145
map_assigment        : 19
map_values           : 145 146 149
modifier             : 12 14 22 24 26 29 31 33
nullable             : 12 13 22 23 24 25 29 30 31 32
number               : 40 42 73 76 76 83 87 87 88 88 110
number_type          : 20 21 22 23 24 25 26
parameter            : 137 138
parameters           : 122 138
print                : 3 128
queue                : 
reassignment         : 10 135 157
set                  : 
statement            : 0
string               : 77 90 90 91 91 111
string_assignment    : 17
string_comparison    : 85
type                 : 12 13 14 15 16 121 122 140 142 142 148 148 149 149 150 151 152 153 154 155
type_string          : 27 28 29 30 31 32 33
value                : 107 108
values               : 52 53 80 108 119 151 154
while_statement      : 6 132

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> . reassignment
    (11) statement -> .
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
    LBRACE          shift and go to state 10
    $end            reduce using rule 11 (statement -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    LINE_BREAK      shift and go to state 29
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    LSQUARE         shift and go to state 61

  ! $end            [ reduce using rule 127 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    reassignment                   shift and go to state 11
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 15
    division                       shift and go to state 16
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    line                           shift and go to state 28
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    type_string                    shift and go to state 49
    list                           shift and go to state 50
    map                            shift and go to state 51
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (129) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 129 (line -> assignment .)
    PRINT           reduce using rule 129 (line -> assignment .)
    IF              reduce using rule 129 (line -> assignment .)
    WHILE           reduce using rule 129 (line -> assignment .)
    FOR             reduce using rule 129 (line -> assignment .)
    IDENTIFIER      reduce using rule 129 (line -> assignment .)
    FINAL           reduce using rule 129 (line -> assignment .)
    CONST           reduce using rule 129 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 129 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 129 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 129 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 129 (line -> assignment .)
    STRING_TYPE     reduce using rule 129 (line -> assignment .)
    ENUM_TYPE       reduce using rule 129 (line -> assignment .)
    VAR             reduce using rule 129 (line -> assignment .)
    LIST_TYPE       reduce using rule 129 (line -> assignment .)
    MAP_TYPE        reduce using rule 129 (line -> assignment .)
    SET_TYPE        reduce using rule 129 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 129 (line -> assignment .)
    VOID            reduce using rule 129 (line -> assignment .)

  ! $end            [ reduce using rule 129 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (128) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 128 (line -> print .)
    PRINT           reduce using rule 128 (line -> print .)
    IF              reduce using rule 128 (line -> print .)
    WHILE           reduce using rule 128 (line -> print .)
    FOR             reduce using rule 128 (line -> print .)
    IDENTIFIER      reduce using rule 128 (line -> print .)
    FINAL           reduce using rule 128 (line -> print .)
    CONST           reduce using rule 128 (line -> print .)
    INTEGER_TYPE    reduce using rule 128 (line -> print .)
    DOUBLE_TYPE     reduce using rule 128 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 128 (line -> print .)
    QUEUE_TYPE      reduce using rule 128 (line -> print .)
    STRING_TYPE     reduce using rule 128 (line -> print .)
    ENUM_TYPE       reduce using rule 128 (line -> print .)
    VAR             reduce using rule 128 (line -> print .)
    LIST_TYPE       reduce using rule 128 (line -> print .)
    MAP_TYPE        reduce using rule 128 (line -> print .)
    SET_TYPE        reduce using rule 128 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 128 (line -> print .)
    VOID            reduce using rule 128 (line -> print .)

  ! $end            [ reduce using rule 128 (line -> print .) ]


state 5

    (4) statement -> function .
    (130) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 130 (line -> function .)
    PRINT           reduce using rule 130 (line -> function .)
    IF              reduce using rule 130 (line -> function .)
    WHILE           reduce using rule 130 (line -> function .)
    FOR             reduce using rule 130 (line -> function .)
    IDENTIFIER      reduce using rule 130 (line -> function .)
    FINAL           reduce using rule 130 (line -> function .)
    CONST           reduce using rule 130 (line -> function .)
    INTEGER_TYPE    reduce using rule 130 (line -> function .)
    DOUBLE_TYPE     reduce using rule 130 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 130 (line -> function .)
    QUEUE_TYPE      reduce using rule 130 (line -> function .)
    STRING_TYPE     reduce using rule 130 (line -> function .)
    ENUM_TYPE       reduce using rule 130 (line -> function .)
    VAR             reduce using rule 130 (line -> function .)
    LIST_TYPE       reduce using rule 130 (line -> function .)
    MAP_TYPE        reduce using rule 130 (line -> function .)
    SET_TYPE        reduce using rule 130 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 130 (line -> function .)
    VOID            reduce using rule 130 (line -> function .)

  ! $end            [ reduce using rule 130 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (50) if_statement -> if_statement . ELSE if_statement
    (51) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (131) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 62
    LINE_BREAK      reduce using rule 131 (line -> if_statement .)
    PRINT           reduce using rule 131 (line -> if_statement .)
    IF              reduce using rule 131 (line -> if_statement .)
    WHILE           reduce using rule 131 (line -> if_statement .)
    FOR             reduce using rule 131 (line -> if_statement .)
    IDENTIFIER      reduce using rule 131 (line -> if_statement .)
    FINAL           reduce using rule 131 (line -> if_statement .)
    CONST           reduce using rule 131 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 131 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 131 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 131 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 131 (line -> if_statement .)
    STRING_TYPE     reduce using rule 131 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 131 (line -> if_statement .)
    VAR             reduce using rule 131 (line -> if_statement .)
    LIST_TYPE       reduce using rule 131 (line -> if_statement .)
    MAP_TYPE        reduce using rule 131 (line -> if_statement .)
    SET_TYPE        reduce using rule 131 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 131 (line -> if_statement .)
    VOID            reduce using rule 131 (line -> if_statement .)

  ! $end            [ reduce using rule 131 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .
    (132) line -> while_statement .

  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> while_statement .)
    $end            reduce using rule 6 (statement -> while_statement .)
    LINE_BREAK      reduce using rule 132 (line -> while_statement .)
    PRINT           reduce using rule 132 (line -> while_statement .)
    IF              reduce using rule 132 (line -> while_statement .)
    WHILE           reduce using rule 132 (line -> while_statement .)
    FOR             reduce using rule 132 (line -> while_statement .)
    IDENTIFIER      reduce using rule 132 (line -> while_statement .)
    FINAL           reduce using rule 132 (line -> while_statement .)
    CONST           reduce using rule 132 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 132 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 132 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 132 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 132 (line -> while_statement .)
    STRING_TYPE     reduce using rule 132 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 132 (line -> while_statement .)
    VAR             reduce using rule 132 (line -> while_statement .)
    LIST_TYPE       reduce using rule 132 (line -> while_statement .)
    MAP_TYPE        reduce using rule 132 (line -> while_statement .)
    SET_TYPE        reduce using rule 132 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 132 (line -> while_statement .)
    VOID            reduce using rule 132 (line -> while_statement .)

  ! $end            [ reduce using rule 132 (line -> while_statement .) ]


state 8

    (7) statement -> for_statement .
    (133) line -> for_statement .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    LINE_BREAK      reduce using rule 133 (line -> for_statement .)
    PRINT           reduce using rule 133 (line -> for_statement .)
    IF              reduce using rule 133 (line -> for_statement .)
    WHILE           reduce using rule 133 (line -> for_statement .)
    FOR             reduce using rule 133 (line -> for_statement .)
    IDENTIFIER      reduce using rule 133 (line -> for_statement .)
    FINAL           reduce using rule 133 (line -> for_statement .)
    CONST           reduce using rule 133 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 133 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 133 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 133 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 133 (line -> for_statement .)
    STRING_TYPE     reduce using rule 133 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 133 (line -> for_statement .)
    VAR             reduce using rule 133 (line -> for_statement .)
    LIST_TYPE       reduce using rule 133 (line -> for_statement .)
    MAP_TYPE        reduce using rule 133 (line -> for_statement .)
    SET_TYPE        reduce using rule 133 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 133 (line -> for_statement .)
    VOID            reduce using rule 133 (line -> for_statement .)

  ! $end            [ reduce using rule 133 (line -> for_statement .) ]


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 29
    RBRACE          reduce using rule 127 (lines -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    lines                          shift and go to state 63
    line                           shift and go to state 28
    print                          shift and go to state 64
    assignment                     shift and go to state 65
    function                       shift and go to state 66
    if_statement                   shift and go to state 67
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    reassignment                   shift and go to state 71
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 11

    (10) statement -> reassignment .
    (135) line -> reassignment .

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> reassignment .)
    $end            reduce using rule 10 (statement -> reassignment .)
    LINE_BREAK      reduce using rule 135 (line -> reassignment .)
    PRINT           reduce using rule 135 (line -> reassignment .)
    IF              reduce using rule 135 (line -> reassignment .)
    WHILE           reduce using rule 135 (line -> reassignment .)
    FOR             reduce using rule 135 (line -> reassignment .)
    IDENTIFIER      reduce using rule 135 (line -> reassignment .)
    FINAL           reduce using rule 135 (line -> reassignment .)
    CONST           reduce using rule 135 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 135 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 135 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 135 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 135 (line -> reassignment .)
    STRING_TYPE     reduce using rule 135 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 135 (line -> reassignment .)
    VAR             reduce using rule 135 (line -> reassignment .)
    LIST_TYPE       reduce using rule 135 (line -> reassignment .)
    MAP_TYPE        reduce using rule 135 (line -> reassignment .)
    SET_TYPE        reduce using rule 135 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 135 (line -> reassignment .)
    VOID            reduce using rule 135 (line -> reassignment .)

  ! $end            [ reduce using rule 135 (line -> reassignment .) ]


state 12

    (68) expression -> arithmetic .
    (74) arithmetic -> arithmetic . arith_op arithmetic
    (98) arith_op -> . PLUS
    (99) arith_op -> . MINUS
    (100) arith_op -> . TIMES

    $end            reduce using rule 68 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 68 (expression -> arithmetic .)
    RPAREN          reduce using rule 68 (expression -> arithmetic .)
    LINE_BREAK      reduce using rule 68 (expression -> arithmetic .)
    PRINT           reduce using rule 68 (expression -> arithmetic .)
    IF              reduce using rule 68 (expression -> arithmetic .)
    WHILE           reduce using rule 68 (expression -> arithmetic .)
    FOR             reduce using rule 68 (expression -> arithmetic .)
    IDENTIFIER      reduce using rule 68 (expression -> arithmetic .)
    FINAL           reduce using rule 68 (expression -> arithmetic .)
    CONST           reduce using rule 68 (expression -> arithmetic .)
    INTEGER_TYPE    reduce using rule 68 (expression -> arithmetic .)
    DOUBLE_TYPE     reduce using rule 68 (expression -> arithmetic .)
    BOOLEAN_TYPE    reduce using rule 68 (expression -> arithmetic .)
    QUEUE_TYPE      reduce using rule 68 (expression -> arithmetic .)
    STRING_TYPE     reduce using rule 68 (expression -> arithmetic .)
    ENUM_TYPE       reduce using rule 68 (expression -> arithmetic .)
    VAR             reduce using rule 68 (expression -> arithmetic .)
    LIST_TYPE       reduce using rule 68 (expression -> arithmetic .)
    MAP_TYPE        reduce using rule 68 (expression -> arithmetic .)
    SET_TYPE        reduce using rule 68 (expression -> arithmetic .)
    DYNAMIC_TYPE    reduce using rule 68 (expression -> arithmetic .)
    VOID            reduce using rule 68 (expression -> arithmetic .)
    RBRACE          reduce using rule 68 (expression -> arithmetic .)
    LPAREN          reduce using rule 68 (expression -> arithmetic .)
    LOGICAL_NOT     reduce using rule 68 (expression -> arithmetic .)
    TRUE            reduce using rule 68 (expression -> arithmetic .)
    FALSE           reduce using rule 68 (expression -> arithmetic .)
    INTEGER         reduce using rule 68 (expression -> arithmetic .)
    DOUBLE          reduce using rule 68 (expression -> arithmetic .)
    STRING          reduce using rule 68 (expression -> arithmetic .)
    LSQUARE         reduce using rule 68 (expression -> arithmetic .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76

    arith_op                       shift and go to state 73

state 13

    (69) expression -> concate .
    (78) concate -> concate . PLUS concate

    $end            reduce using rule 69 (expression -> concate .)
    SEMICOLON       reduce using rule 69 (expression -> concate .)
    RPAREN          reduce using rule 69 (expression -> concate .)
    LINE_BREAK      reduce using rule 69 (expression -> concate .)
    PRINT           reduce using rule 69 (expression -> concate .)
    IF              reduce using rule 69 (expression -> concate .)
    WHILE           reduce using rule 69 (expression -> concate .)
    FOR             reduce using rule 69 (expression -> concate .)
    IDENTIFIER      reduce using rule 69 (expression -> concate .)
    FINAL           reduce using rule 69 (expression -> concate .)
    CONST           reduce using rule 69 (expression -> concate .)
    INTEGER_TYPE    reduce using rule 69 (expression -> concate .)
    DOUBLE_TYPE     reduce using rule 69 (expression -> concate .)
    BOOLEAN_TYPE    reduce using rule 69 (expression -> concate .)
    QUEUE_TYPE      reduce using rule 69 (expression -> concate .)
    STRING_TYPE     reduce using rule 69 (expression -> concate .)
    ENUM_TYPE       reduce using rule 69 (expression -> concate .)
    VAR             reduce using rule 69 (expression -> concate .)
    LIST_TYPE       reduce using rule 69 (expression -> concate .)
    MAP_TYPE        reduce using rule 69 (expression -> concate .)
    SET_TYPE        reduce using rule 69 (expression -> concate .)
    DYNAMIC_TYPE    reduce using rule 69 (expression -> concate .)
    VOID            reduce using rule 69 (expression -> concate .)
    RBRACE          reduce using rule 69 (expression -> concate .)
    LPAREN          reduce using rule 69 (expression -> concate .)
    LOGICAL_NOT     reduce using rule 69 (expression -> concate .)
    TRUE            reduce using rule 69 (expression -> concate .)
    FALSE           reduce using rule 69 (expression -> concate .)
    INTEGER         reduce using rule 69 (expression -> concate .)
    DOUBLE          reduce using rule 69 (expression -> concate .)
    STRING          reduce using rule 69 (expression -> concate .)
    LSQUARE         reduce using rule 69 (expression -> concate .)
    PLUS            shift and go to state 77


state 14

    (70) expression -> logic .
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

    $end            reduce using rule 70 (expression -> logic .)
    SEMICOLON       reduce using rule 70 (expression -> logic .)
    RPAREN          reduce using rule 70 (expression -> logic .)
    LINE_BREAK      reduce using rule 70 (expression -> logic .)
    PRINT           reduce using rule 70 (expression -> logic .)
    IF              reduce using rule 70 (expression -> logic .)
    WHILE           reduce using rule 70 (expression -> logic .)
    FOR             reduce using rule 70 (expression -> logic .)
    IDENTIFIER      reduce using rule 70 (expression -> logic .)
    FINAL           reduce using rule 70 (expression -> logic .)
    CONST           reduce using rule 70 (expression -> logic .)
    INTEGER_TYPE    reduce using rule 70 (expression -> logic .)
    DOUBLE_TYPE     reduce using rule 70 (expression -> logic .)
    BOOLEAN_TYPE    reduce using rule 70 (expression -> logic .)
    QUEUE_TYPE      reduce using rule 70 (expression -> logic .)
    STRING_TYPE     reduce using rule 70 (expression -> logic .)
    ENUM_TYPE       reduce using rule 70 (expression -> logic .)
    VAR             reduce using rule 70 (expression -> logic .)
    LIST_TYPE       reduce using rule 70 (expression -> logic .)
    MAP_TYPE        reduce using rule 70 (expression -> logic .)
    SET_TYPE        reduce using rule 70 (expression -> logic .)
    DYNAMIC_TYPE    reduce using rule 70 (expression -> logic .)
    VOID            reduce using rule 70 (expression -> logic .)
    RBRACE          reduce using rule 70 (expression -> logic .)
    LPAREN          reduce using rule 70 (expression -> logic .)
    LOGICAL_NOT     reduce using rule 70 (expression -> logic .)
    TRUE            reduce using rule 70 (expression -> logic .)
    FALSE           reduce using rule 70 (expression -> logic .)
    INTEGER         reduce using rule 70 (expression -> logic .)
    DOUBLE          reduce using rule 70 (expression -> logic .)
    STRING          reduce using rule 70 (expression -> logic .)
    LSQUARE         reduce using rule 70 (expression -> logic .)
    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

    logic_op                       shift and go to state 78

state 15

    (71) expression -> function_call .
    (134) line -> function_call .

  ! reduce/reduce conflict for $end resolved using rule 71 (expression -> function_call .)
    $end            reduce using rule 71 (expression -> function_call .)
    LINE_BREAK      reduce using rule 134 (line -> function_call .)
    PRINT           reduce using rule 134 (line -> function_call .)
    IF              reduce using rule 134 (line -> function_call .)
    WHILE           reduce using rule 134 (line -> function_call .)
    FOR             reduce using rule 134 (line -> function_call .)
    IDENTIFIER      reduce using rule 134 (line -> function_call .)
    FINAL           reduce using rule 134 (line -> function_call .)
    CONST           reduce using rule 134 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 134 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 134 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 134 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 134 (line -> function_call .)
    STRING_TYPE     reduce using rule 134 (line -> function_call .)
    ENUM_TYPE       reduce using rule 134 (line -> function_call .)
    VAR             reduce using rule 134 (line -> function_call .)
    LIST_TYPE       reduce using rule 134 (line -> function_call .)
    MAP_TYPE        reduce using rule 134 (line -> function_call .)
    SET_TYPE        reduce using rule 134 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 134 (line -> function_call .)
    VOID            reduce using rule 134 (line -> function_call .)

  ! $end            [ reduce using rule 134 (line -> function_call .) ]


state 16

    (72) expression -> division .

    $end            reduce using rule 72 (expression -> division .)
    SEMICOLON       reduce using rule 72 (expression -> division .)
    RPAREN          reduce using rule 72 (expression -> division .)
    LINE_BREAK      reduce using rule 72 (expression -> division .)
    PRINT           reduce using rule 72 (expression -> division .)
    IF              reduce using rule 72 (expression -> division .)
    WHILE           reduce using rule 72 (expression -> division .)
    FOR             reduce using rule 72 (expression -> division .)
    IDENTIFIER      reduce using rule 72 (expression -> division .)
    FINAL           reduce using rule 72 (expression -> division .)
    CONST           reduce using rule 72 (expression -> division .)
    INTEGER_TYPE    reduce using rule 72 (expression -> division .)
    DOUBLE_TYPE     reduce using rule 72 (expression -> division .)
    BOOLEAN_TYPE    reduce using rule 72 (expression -> division .)
    QUEUE_TYPE      reduce using rule 72 (expression -> division .)
    STRING_TYPE     reduce using rule 72 (expression -> division .)
    ENUM_TYPE       reduce using rule 72 (expression -> division .)
    VAR             reduce using rule 72 (expression -> division .)
    LIST_TYPE       reduce using rule 72 (expression -> division .)
    MAP_TYPE        reduce using rule 72 (expression -> division .)
    SET_TYPE        reduce using rule 72 (expression -> division .)
    DYNAMIC_TYPE    reduce using rule 72 (expression -> division .)
    VOID            reduce using rule 72 (expression -> division .)
    RBRACE          reduce using rule 72 (expression -> division .)
    LPAREN          reduce using rule 72 (expression -> division .)
    LOGICAL_NOT     reduce using rule 72 (expression -> division .)
    TRUE            reduce using rule 72 (expression -> division .)
    FALSE           reduce using rule 72 (expression -> division .)
    INTEGER         reduce using rule 72 (expression -> division .)
    DOUBLE          reduce using rule 72 (expression -> division .)
    STRING          reduce using rule 72 (expression -> division .)
    LSQUARE         reduce using rule 72 (expression -> division .)


state 17

    (12) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (29) string_assignment -> modifier . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> modifier . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> modifier . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR

    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 81
    type_string                    shift and go to state 82

state 18

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (122) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (121) list_assigment -> type . ASSIGN list SEMICOLON
    (44) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 85
    ASSIGN          shift and go to state 86
    QUESTION_MARK   shift and go to state 87

    nullable                       shift and go to state 84

state 19

    (39) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (40) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH number
    (43) reassignment -> IDENTIFIER . INLINE_ARITH
    (52) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (53) function_call -> IDENTIFIER . LPAREN values RPAREN
    (54) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (55) function_call -> IDENTIFIER . LPAREN RPAREN
    (120) list_assigment -> IDENTIFIER . ASSIGN list SEMICOLON
    (146) map_assigment -> IDENTIFIER . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON
    (109) value -> IDENTIFIER .

    ASSIGN          shift and go to state 89
    INLINE_ARITH    shift and go to state 90
    LPAREN          shift and go to state 91
    IDENTIFIER      shift and go to state 88
    COMMA           reduce using rule 109 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 109 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 109 (value -> IDENTIFIER .)
    LESS            reduce using rule 109 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 109 (value -> IDENTIFIER .)
    GREATER         reduce using rule 109 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 109 (value -> IDENTIFIER .)
    $end            reduce using rule 109 (value -> IDENTIFIER .)


state 20

    (17) assignment -> string_assignment .

    $end            reduce using rule 17 (assignment -> string_assignment .)
    LINE_BREAK      reduce using rule 17 (assignment -> string_assignment .)
    PRINT           reduce using rule 17 (assignment -> string_assignment .)
    IF              reduce using rule 17 (assignment -> string_assignment .)
    WHILE           reduce using rule 17 (assignment -> string_assignment .)
    FOR             reduce using rule 17 (assignment -> string_assignment .)
    IDENTIFIER      reduce using rule 17 (assignment -> string_assignment .)
    FINAL           reduce using rule 17 (assignment -> string_assignment .)
    CONST           reduce using rule 17 (assignment -> string_assignment .)
    INTEGER_TYPE    reduce using rule 17 (assignment -> string_assignment .)
    DOUBLE_TYPE     reduce using rule 17 (assignment -> string_assignment .)
    BOOLEAN_TYPE    reduce using rule 17 (assignment -> string_assignment .)
    QUEUE_TYPE      reduce using rule 17 (assignment -> string_assignment .)
    STRING_TYPE     reduce using rule 17 (assignment -> string_assignment .)
    ENUM_TYPE       reduce using rule 17 (assignment -> string_assignment .)
    VAR             reduce using rule 17 (assignment -> string_assignment .)
    LIST_TYPE       reduce using rule 17 (assignment -> string_assignment .)
    MAP_TYPE        reduce using rule 17 (assignment -> string_assignment .)
    SET_TYPE        reduce using rule 17 (assignment -> string_assignment .)
    DYNAMIC_TYPE    reduce using rule 17 (assignment -> string_assignment .)
    VOID            reduce using rule 17 (assignment -> string_assignment .)
    RBRACE          reduce using rule 17 (assignment -> string_assignment .)
    LPAREN          reduce using rule 17 (assignment -> string_assignment .)
    LOGICAL_NOT     reduce using rule 17 (assignment -> string_assignment .)
    TRUE            reduce using rule 17 (assignment -> string_assignment .)
    FALSE           reduce using rule 17 (assignment -> string_assignment .)
    INTEGER         reduce using rule 17 (assignment -> string_assignment .)
    DOUBLE          reduce using rule 17 (assignment -> string_assignment .)
    STRING          reduce using rule 17 (assignment -> string_assignment .)
    LSQUARE         reduce using rule 17 (assignment -> string_assignment .)


state 21

    (18) assignment -> list_assigment .

    $end            reduce using rule 18 (assignment -> list_assigment .)
    LINE_BREAK      reduce using rule 18 (assignment -> list_assigment .)
    PRINT           reduce using rule 18 (assignment -> list_assigment .)
    IF              reduce using rule 18 (assignment -> list_assigment .)
    WHILE           reduce using rule 18 (assignment -> list_assigment .)
    FOR             reduce using rule 18 (assignment -> list_assigment .)
    IDENTIFIER      reduce using rule 18 (assignment -> list_assigment .)
    FINAL           reduce using rule 18 (assignment -> list_assigment .)
    CONST           reduce using rule 18 (assignment -> list_assigment .)
    INTEGER_TYPE    reduce using rule 18 (assignment -> list_assigment .)
    DOUBLE_TYPE     reduce using rule 18 (assignment -> list_assigment .)
    BOOLEAN_TYPE    reduce using rule 18 (assignment -> list_assigment .)
    QUEUE_TYPE      reduce using rule 18 (assignment -> list_assigment .)
    STRING_TYPE     reduce using rule 18 (assignment -> list_assigment .)
    ENUM_TYPE       reduce using rule 18 (assignment -> list_assigment .)
    VAR             reduce using rule 18 (assignment -> list_assigment .)
    LIST_TYPE       reduce using rule 18 (assignment -> list_assigment .)
    MAP_TYPE        reduce using rule 18 (assignment -> list_assigment .)
    SET_TYPE        reduce using rule 18 (assignment -> list_assigment .)
    DYNAMIC_TYPE    reduce using rule 18 (assignment -> list_assigment .)
    VOID            reduce using rule 18 (assignment -> list_assigment .)
    RBRACE          reduce using rule 18 (assignment -> list_assigment .)
    LPAREN          reduce using rule 18 (assignment -> list_assigment .)
    LOGICAL_NOT     reduce using rule 18 (assignment -> list_assigment .)
    TRUE            reduce using rule 18 (assignment -> list_assigment .)
    FALSE           reduce using rule 18 (assignment -> list_assigment .)
    INTEGER         reduce using rule 18 (assignment -> list_assigment .)
    DOUBLE          reduce using rule 18 (assignment -> list_assigment .)
    STRING          reduce using rule 18 (assignment -> list_assigment .)
    LSQUARE         reduce using rule 18 (assignment -> list_assigment .)


state 22

    (19) assignment -> map_assigment .

    $end            reduce using rule 19 (assignment -> map_assigment .)
    LINE_BREAK      reduce using rule 19 (assignment -> map_assigment .)
    PRINT           reduce using rule 19 (assignment -> map_assigment .)
    IF              reduce using rule 19 (assignment -> map_assigment .)
    WHILE           reduce using rule 19 (assignment -> map_assigment .)
    FOR             reduce using rule 19 (assignment -> map_assigment .)
    IDENTIFIER      reduce using rule 19 (assignment -> map_assigment .)
    FINAL           reduce using rule 19 (assignment -> map_assigment .)
    CONST           reduce using rule 19 (assignment -> map_assigment .)
    INTEGER_TYPE    reduce using rule 19 (assignment -> map_assigment .)
    DOUBLE_TYPE     reduce using rule 19 (assignment -> map_assigment .)
    BOOLEAN_TYPE    reduce using rule 19 (assignment -> map_assigment .)
    QUEUE_TYPE      reduce using rule 19 (assignment -> map_assigment .)
    STRING_TYPE     reduce using rule 19 (assignment -> map_assigment .)
    ENUM_TYPE       reduce using rule 19 (assignment -> map_assigment .)
    VAR             reduce using rule 19 (assignment -> map_assigment .)
    LIST_TYPE       reduce using rule 19 (assignment -> map_assigment .)
    MAP_TYPE        reduce using rule 19 (assignment -> map_assigment .)
    SET_TYPE        reduce using rule 19 (assignment -> map_assigment .)
    DYNAMIC_TYPE    reduce using rule 19 (assignment -> map_assigment .)
    VOID            reduce using rule 19 (assignment -> map_assigment .)
    RBRACE          reduce using rule 19 (assignment -> map_assigment .)
    LPAREN          reduce using rule 19 (assignment -> map_assigment .)
    LOGICAL_NOT     reduce using rule 19 (assignment -> map_assigment .)
    TRUE            reduce using rule 19 (assignment -> map_assigment .)
    FALSE           reduce using rule 19 (assignment -> map_assigment .)
    INTEGER         reduce using rule 19 (assignment -> map_assigment .)
    DOUBLE          reduce using rule 19 (assignment -> map_assigment .)
    STRING          reduce using rule 19 (assignment -> map_assigment .)
    LSQUARE         reduce using rule 19 (assignment -> map_assigment .)


state 23

    (47) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (48) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 92


state 24

    (75) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (79) concate -> LPAREN . concate PLUS concate RPAREN
    (94) logic -> LPAREN . logic logic_op logic RPAREN
    (83) comparison -> LPAREN . comparison comp_op number comparison
    (88) int_comparison -> LPAREN . number comp_op number RPAREN
    (91) string_comparison -> LPAREN . string comp_op string RPAREN
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    LSQUARE         shift and go to state 61

    arithmetic                     shift and go to state 93
    concate                        shift and go to state 94
    logic                          shift and go to state 95
    comparison                     shift and go to state 96
    number                         shift and go to state 97
    string                         shift and go to state 98
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 25

    (49) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 100


state 26

    (156) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 101


state 27

    (157) for_statement -> FOR . LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 102


state 28

    (123) lines -> line . LINE_BREAK lines
    (124) lines -> line . lines
    (125) lines -> line .
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

  ! reduce/reduce conflict for $end resolved using rule 125 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 125 (lines -> line .)
    LINE_BREAK      shift and go to state 103
    $end            reduce using rule 125 (lines -> line .)
    RBRACE          reduce using rule 125 (lines -> line .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

  ! $end            [ reduce using rule 127 (lines -> .) ]
  ! RBRACE          [ reduce using rule 127 (lines -> .) ]

    line                           shift and go to state 28
    lines                          shift and go to state 104
    print                          shift and go to state 64
    assignment                     shift and go to state 65
    function                       shift and go to state 66
    if_statement                   shift and go to state 67
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    reassignment                   shift and go to state 71
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 29

    (126) lines -> LINE_BREAK .

    $end            reduce using rule 126 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 126 (lines -> LINE_BREAK .)


state 30

    (73) arithmetic -> number .
    (76) division -> number . DIVIDE number
    (87) int_comparison -> number . comp_op number
    (110) value -> number .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for RPAREN resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for PRINT resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for IF resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for WHILE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for FOR resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for FINAL resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for CONST resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for VAR resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for VOID resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for RBRACE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for LPAREN resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for LOGICAL_NOT resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for TRUE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for FALSE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for INTEGER resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for STRING resolved using rule 73 (arithmetic -> number .)
  ! reduce/reduce conflict for LSQUARE resolved using rule 73 (arithmetic -> number .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    PLUS            reduce using rule 73 (arithmetic -> number .)
    MINUS           reduce using rule 73 (arithmetic -> number .)
    TIMES           reduce using rule 73 (arithmetic -> number .)
    $end            reduce using rule 73 (arithmetic -> number .)
    SEMICOLON       reduce using rule 73 (arithmetic -> number .)
    RPAREN          reduce using rule 73 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 73 (arithmetic -> number .)
    PRINT           reduce using rule 73 (arithmetic -> number .)
    IF              reduce using rule 73 (arithmetic -> number .)
    WHILE           reduce using rule 73 (arithmetic -> number .)
    FOR             reduce using rule 73 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 73 (arithmetic -> number .)
    FINAL           reduce using rule 73 (arithmetic -> number .)
    CONST           reduce using rule 73 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 73 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 73 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 73 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 73 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 73 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 73 (arithmetic -> number .)
    VAR             reduce using rule 73 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 73 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 73 (arithmetic -> number .)
    SET_TYPE        reduce using rule 73 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 73 (arithmetic -> number .)
    VOID            reduce using rule 73 (arithmetic -> number .)
    RBRACE          reduce using rule 73 (arithmetic -> number .)
    LPAREN          reduce using rule 73 (arithmetic -> number .)
    LOGICAL_NOT     reduce using rule 73 (arithmetic -> number .)
    TRUE            reduce using rule 73 (arithmetic -> number .)
    FALSE           reduce using rule 73 (arithmetic -> number .)
    INTEGER         reduce using rule 73 (arithmetic -> number .)
    DOUBLE          reduce using rule 73 (arithmetic -> number .)
    STRING          reduce using rule 73 (arithmetic -> number .)
    LSQUARE         reduce using rule 73 (arithmetic -> number .)
    DIVIDE          shift and go to state 105
    COMMA           reduce using rule 110 (value -> number .)
    LOGICAL_AND     reduce using rule 110 (value -> number .)
    LOGICAL_OR      reduce using rule 110 (value -> number .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 110 (value -> number .) ]
  ! NOT_EQUAL       [ reduce using rule 110 (value -> number .) ]
  ! LESS            [ reduce using rule 110 (value -> number .) ]
  ! LESS_EQUAL      [ reduce using rule 110 (value -> number .) ]
  ! GREATER         [ reduce using rule 110 (value -> number .) ]
  ! GREATER_EQUAL   [ reduce using rule 110 (value -> number .) ]
  ! $end            [ reduce using rule 110 (value -> number .) ]
  ! SEMICOLON       [ reduce using rule 110 (value -> number .) ]
  ! RPAREN          [ reduce using rule 110 (value -> number .) ]
  ! LINE_BREAK      [ reduce using rule 110 (value -> number .) ]
  ! PRINT           [ reduce using rule 110 (value -> number .) ]
  ! IF              [ reduce using rule 110 (value -> number .) ]
  ! WHILE           [ reduce using rule 110 (value -> number .) ]
  ! FOR             [ reduce using rule 110 (value -> number .) ]
  ! IDENTIFIER      [ reduce using rule 110 (value -> number .) ]
  ! FINAL           [ reduce using rule 110 (value -> number .) ]
  ! CONST           [ reduce using rule 110 (value -> number .) ]
  ! INTEGER_TYPE    [ reduce using rule 110 (value -> number .) ]
  ! DOUBLE_TYPE     [ reduce using rule 110 (value -> number .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 110 (value -> number .) ]
  ! QUEUE_TYPE      [ reduce using rule 110 (value -> number .) ]
  ! STRING_TYPE     [ reduce using rule 110 (value -> number .) ]
  ! ENUM_TYPE       [ reduce using rule 110 (value -> number .) ]
  ! VAR             [ reduce using rule 110 (value -> number .) ]
  ! LIST_TYPE       [ reduce using rule 110 (value -> number .) ]
  ! MAP_TYPE        [ reduce using rule 110 (value -> number .) ]
  ! SET_TYPE        [ reduce using rule 110 (value -> number .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 110 (value -> number .) ]
  ! VOID            [ reduce using rule 110 (value -> number .) ]
  ! RBRACE          [ reduce using rule 110 (value -> number .) ]
  ! LPAREN          [ reduce using rule 110 (value -> number .) ]
  ! LOGICAL_NOT     [ reduce using rule 110 (value -> number .) ]
  ! TRUE            [ reduce using rule 110 (value -> number .) ]
  ! FALSE           [ reduce using rule 110 (value -> number .) ]
  ! INTEGER         [ reduce using rule 110 (value -> number .) ]
  ! DOUBLE          [ reduce using rule 110 (value -> number .) ]
  ! STRING          [ reduce using rule 110 (value -> number .) ]
  ! LSQUARE         [ reduce using rule 110 (value -> number .) ]

    comp_op                        shift and go to state 106

state 31

    (77) concate -> string .
    (90) string_comparison -> string . comp_op string
    (111) value -> string .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for RPAREN resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for PRINT resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for IF resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for WHILE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for FOR resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for FINAL resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for CONST resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for VAR resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for VOID resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for RBRACE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for LPAREN resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for LOGICAL_NOT resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for TRUE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for FALSE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for INTEGER resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for STRING resolved using rule 77 (concate -> string .)
  ! reduce/reduce conflict for LSQUARE resolved using rule 77 (concate -> string .)
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    PLUS            reduce using rule 77 (concate -> string .)
    $end            reduce using rule 77 (concate -> string .)
    SEMICOLON       reduce using rule 77 (concate -> string .)
    RPAREN          reduce using rule 77 (concate -> string .)
    LINE_BREAK      reduce using rule 77 (concate -> string .)
    PRINT           reduce using rule 77 (concate -> string .)
    IF              reduce using rule 77 (concate -> string .)
    WHILE           reduce using rule 77 (concate -> string .)
    FOR             reduce using rule 77 (concate -> string .)
    IDENTIFIER      reduce using rule 77 (concate -> string .)
    FINAL           reduce using rule 77 (concate -> string .)
    CONST           reduce using rule 77 (concate -> string .)
    INTEGER_TYPE    reduce using rule 77 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 77 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 77 (concate -> string .)
    QUEUE_TYPE      reduce using rule 77 (concate -> string .)
    STRING_TYPE     reduce using rule 77 (concate -> string .)
    ENUM_TYPE       reduce using rule 77 (concate -> string .)
    VAR             reduce using rule 77 (concate -> string .)
    LIST_TYPE       reduce using rule 77 (concate -> string .)
    MAP_TYPE        reduce using rule 77 (concate -> string .)
    SET_TYPE        reduce using rule 77 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 77 (concate -> string .)
    VOID            reduce using rule 77 (concate -> string .)
    RBRACE          reduce using rule 77 (concate -> string .)
    LPAREN          reduce using rule 77 (concate -> string .)
    LOGICAL_NOT     reduce using rule 77 (concate -> string .)
    TRUE            reduce using rule 77 (concate -> string .)
    FALSE           reduce using rule 77 (concate -> string .)
    INTEGER         reduce using rule 77 (concate -> string .)
    DOUBLE          reduce using rule 77 (concate -> string .)
    STRING          reduce using rule 77 (concate -> string .)
    LSQUARE         reduce using rule 77 (concate -> string .)
    COMMA           reduce using rule 111 (value -> string .)
    LOGICAL_AND     reduce using rule 111 (value -> string .)
    LOGICAL_OR      reduce using rule 111 (value -> string .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 111 (value -> string .) ]
  ! NOT_EQUAL       [ reduce using rule 111 (value -> string .) ]
  ! LESS            [ reduce using rule 111 (value -> string .) ]
  ! LESS_EQUAL      [ reduce using rule 111 (value -> string .) ]
  ! GREATER         [ reduce using rule 111 (value -> string .) ]
  ! GREATER_EQUAL   [ reduce using rule 111 (value -> string .) ]
  ! $end            [ reduce using rule 111 (value -> string .) ]
  ! SEMICOLON       [ reduce using rule 111 (value -> string .) ]
  ! RPAREN          [ reduce using rule 111 (value -> string .) ]
  ! LINE_BREAK      [ reduce using rule 111 (value -> string .) ]
  ! PRINT           [ reduce using rule 111 (value -> string .) ]
  ! IF              [ reduce using rule 111 (value -> string .) ]
  ! WHILE           [ reduce using rule 111 (value -> string .) ]
  ! FOR             [ reduce using rule 111 (value -> string .) ]
  ! IDENTIFIER      [ reduce using rule 111 (value -> string .) ]
  ! FINAL           [ reduce using rule 111 (value -> string .) ]
  ! CONST           [ reduce using rule 111 (value -> string .) ]
  ! INTEGER_TYPE    [ reduce using rule 111 (value -> string .) ]
  ! DOUBLE_TYPE     [ reduce using rule 111 (value -> string .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 111 (value -> string .) ]
  ! QUEUE_TYPE      [ reduce using rule 111 (value -> string .) ]
  ! STRING_TYPE     [ reduce using rule 111 (value -> string .) ]
  ! ENUM_TYPE       [ reduce using rule 111 (value -> string .) ]
  ! VAR             [ reduce using rule 111 (value -> string .) ]
  ! LIST_TYPE       [ reduce using rule 111 (value -> string .) ]
  ! MAP_TYPE        [ reduce using rule 111 (value -> string .) ]
  ! SET_TYPE        [ reduce using rule 111 (value -> string .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 111 (value -> string .) ]
  ! VOID            [ reduce using rule 111 (value -> string .) ]
  ! RBRACE          [ reduce using rule 111 (value -> string .) ]
  ! LPAREN          [ reduce using rule 111 (value -> string .) ]
  ! LOGICAL_NOT     [ reduce using rule 111 (value -> string .) ]
  ! TRUE            [ reduce using rule 111 (value -> string .) ]
  ! FALSE           [ reduce using rule 111 (value -> string .) ]
  ! INTEGER         [ reduce using rule 111 (value -> string .) ]
  ! DOUBLE          [ reduce using rule 111 (value -> string .) ]
  ! STRING          [ reduce using rule 111 (value -> string .) ]
  ! LSQUARE         [ reduce using rule 111 (value -> string .) ]

    comp_op                        shift and go to state 113

state 32

    (92) logic -> comparison .
    (82) comparison -> comparison . comp_op comparison
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 92 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 92 (logic -> comparison .)
    $end            reduce using rule 92 (logic -> comparison .)
    SEMICOLON       reduce using rule 92 (logic -> comparison .)
    RPAREN          reduce using rule 92 (logic -> comparison .)
    LINE_BREAK      reduce using rule 92 (logic -> comparison .)
    PRINT           reduce using rule 92 (logic -> comparison .)
    IF              reduce using rule 92 (logic -> comparison .)
    WHILE           reduce using rule 92 (logic -> comparison .)
    FOR             reduce using rule 92 (logic -> comparison .)
    IDENTIFIER      reduce using rule 92 (logic -> comparison .)
    FINAL           reduce using rule 92 (logic -> comparison .)
    CONST           reduce using rule 92 (logic -> comparison .)
    INTEGER_TYPE    reduce using rule 92 (logic -> comparison .)
    DOUBLE_TYPE     reduce using rule 92 (logic -> comparison .)
    BOOLEAN_TYPE    reduce using rule 92 (logic -> comparison .)
    QUEUE_TYPE      reduce using rule 92 (logic -> comparison .)
    STRING_TYPE     reduce using rule 92 (logic -> comparison .)
    ENUM_TYPE       reduce using rule 92 (logic -> comparison .)
    VAR             reduce using rule 92 (logic -> comparison .)
    LIST_TYPE       reduce using rule 92 (logic -> comparison .)
    MAP_TYPE        reduce using rule 92 (logic -> comparison .)
    SET_TYPE        reduce using rule 92 (logic -> comparison .)
    DYNAMIC_TYPE    reduce using rule 92 (logic -> comparison .)
    VOID            reduce using rule 92 (logic -> comparison .)
    RBRACE          reduce using rule 92 (logic -> comparison .)
    LPAREN          reduce using rule 92 (logic -> comparison .)
    LOGICAL_NOT     reduce using rule 92 (logic -> comparison .)
    TRUE            reduce using rule 92 (logic -> comparison .)
    FALSE           reduce using rule 92 (logic -> comparison .)
    INTEGER         reduce using rule 92 (logic -> comparison .)
    DOUBLE          reduce using rule 92 (logic -> comparison .)
    STRING          reduce using rule 92 (logic -> comparison .)
    LSQUARE         reduce using rule 92 (logic -> comparison .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

    comp_op                        shift and go to state 114

state 33

    (95) logic -> LOGICAL_NOT . logic
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 116
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    logic                          shift and go to state 115
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    number                         shift and go to state 117
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 34

    (80) comparison -> values .

    EQUAL           reduce using rule 80 (comparison -> values .)
    NOT_EQUAL       reduce using rule 80 (comparison -> values .)
    LESS            reduce using rule 80 (comparison -> values .)
    LESS_EQUAL      reduce using rule 80 (comparison -> values .)
    GREATER         reduce using rule 80 (comparison -> values .)
    GREATER_EQUAL   reduce using rule 80 (comparison -> values .)
    LOGICAL_AND     reduce using rule 80 (comparison -> values .)
    LOGICAL_OR      reduce using rule 80 (comparison -> values .)
    $end            reduce using rule 80 (comparison -> values .)
    SEMICOLON       reduce using rule 80 (comparison -> values .)
    RPAREN          reduce using rule 80 (comparison -> values .)
    LINE_BREAK      reduce using rule 80 (comparison -> values .)
    PRINT           reduce using rule 80 (comparison -> values .)
    IF              reduce using rule 80 (comparison -> values .)
    WHILE           reduce using rule 80 (comparison -> values .)
    FOR             reduce using rule 80 (comparison -> values .)
    IDENTIFIER      reduce using rule 80 (comparison -> values .)
    FINAL           reduce using rule 80 (comparison -> values .)
    CONST           reduce using rule 80 (comparison -> values .)
    INTEGER_TYPE    reduce using rule 80 (comparison -> values .)
    DOUBLE_TYPE     reduce using rule 80 (comparison -> values .)
    BOOLEAN_TYPE    reduce using rule 80 (comparison -> values .)
    QUEUE_TYPE      reduce using rule 80 (comparison -> values .)
    STRING_TYPE     reduce using rule 80 (comparison -> values .)
    ENUM_TYPE       reduce using rule 80 (comparison -> values .)
    VAR             reduce using rule 80 (comparison -> values .)
    LIST_TYPE       reduce using rule 80 (comparison -> values .)
    MAP_TYPE        reduce using rule 80 (comparison -> values .)
    SET_TYPE        reduce using rule 80 (comparison -> values .)
    DYNAMIC_TYPE    reduce using rule 80 (comparison -> values .)
    VOID            reduce using rule 80 (comparison -> values .)
    RBRACE          reduce using rule 80 (comparison -> values .)
    LPAREN          reduce using rule 80 (comparison -> values .)
    LOGICAL_NOT     reduce using rule 80 (comparison -> values .)
    TRUE            reduce using rule 80 (comparison -> values .)
    FALSE           reduce using rule 80 (comparison -> values .)
    INTEGER         reduce using rule 80 (comparison -> values .)
    DOUBLE          reduce using rule 80 (comparison -> values .)
    STRING          reduce using rule 80 (comparison -> values .)
    LSQUARE         reduce using rule 80 (comparison -> values .)


state 35

    (45) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 45 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 45 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 45 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 45 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 45 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 45 (modifier -> FINAL .)
    VAR             reduce using rule 45 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 45 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 45 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 45 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 45 (modifier -> FINAL .)
    VOID            reduce using rule 45 (modifier -> FINAL .)


state 36

    (46) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 46 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 46 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 46 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 46 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 46 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 46 (modifier -> CONST .)
    VAR             reduce using rule 46 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 46 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 46 (modifier -> CONST .)
    SET_TYPE        reduce using rule 46 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 46 (modifier -> CONST .)
    VOID            reduce using rule 46 (modifier -> CONST .)


state 37

    (56) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 56 (type -> INTEGER_TYPE .)
    ASSIGN          reduce using rule 56 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 56 (type -> INTEGER_TYPE .)
    COMMA           reduce using rule 56 (type -> INTEGER_TYPE .)
    COLON           reduce using rule 56 (type -> INTEGER_TYPE .)
    GREATER         reduce using rule 56 (type -> INTEGER_TYPE .)
    RBRACE          reduce using rule 56 (type -> INTEGER_TYPE .)


state 38

    (57) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 57 (type -> DOUBLE_TYPE .)
    ASSIGN          reduce using rule 57 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 57 (type -> DOUBLE_TYPE .)
    COMMA           reduce using rule 57 (type -> DOUBLE_TYPE .)
    COLON           reduce using rule 57 (type -> DOUBLE_TYPE .)
    GREATER         reduce using rule 57 (type -> DOUBLE_TYPE .)
    RBRACE          reduce using rule 57 (type -> DOUBLE_TYPE .)


state 39

    (58) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 58 (type -> BOOLEAN_TYPE .)
    ASSIGN          reduce using rule 58 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 58 (type -> BOOLEAN_TYPE .)
    COMMA           reduce using rule 58 (type -> BOOLEAN_TYPE .)
    COLON           reduce using rule 58 (type -> BOOLEAN_TYPE .)
    GREATER         reduce using rule 58 (type -> BOOLEAN_TYPE .)
    RBRACE          reduce using rule 58 (type -> BOOLEAN_TYPE .)


state 40

    (59) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 59 (type -> QUEUE_TYPE .)
    ASSIGN          reduce using rule 59 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 59 (type -> QUEUE_TYPE .)
    COMMA           reduce using rule 59 (type -> QUEUE_TYPE .)
    COLON           reduce using rule 59 (type -> QUEUE_TYPE .)
    GREATER         reduce using rule 59 (type -> QUEUE_TYPE .)
    RBRACE          reduce using rule 59 (type -> QUEUE_TYPE .)


state 41

    (60) type -> STRING_TYPE .
    (37) type_string -> STRING_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 37 (type_string -> STRING_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 37 (type_string -> STRING_TYPE .)
    ASSIGN          reduce using rule 60 (type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 37 (type_string -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 37 (type_string -> STRING_TYPE .)

  ! IDENTIFIER      [ reduce using rule 60 (type -> STRING_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 60 (type -> STRING_TYPE .) ]


state 42

    (61) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 61 (type -> ENUM_TYPE .)
    ASSIGN          reduce using rule 61 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 61 (type -> ENUM_TYPE .)
    COMMA           reduce using rule 61 (type -> ENUM_TYPE .)
    COLON           reduce using rule 61 (type -> ENUM_TYPE .)
    GREATER         reduce using rule 61 (type -> ENUM_TYPE .)
    RBRACE          reduce using rule 61 (type -> ENUM_TYPE .)


state 43

    (62) type -> VAR .
    (38) type_string -> VAR .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 38 (type_string -> VAR .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 38 (type_string -> VAR .)
    ASSIGN          reduce using rule 62 (type -> VAR .)
    IDENTIFIER      reduce using rule 38 (type_string -> VAR .)
    QUESTION_MARK   reduce using rule 38 (type_string -> VAR .)

  ! IDENTIFIER      [ reduce using rule 62 (type -> VAR .) ]
  ! QUESTION_MARK   [ reduce using rule 62 (type -> VAR .) ]


state 44

    (63) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 63 (type -> LIST_TYPE .)
    ASSIGN          reduce using rule 63 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 63 (type -> LIST_TYPE .)
    COMMA           reduce using rule 63 (type -> LIST_TYPE .)
    COLON           reduce using rule 63 (type -> LIST_TYPE .)
    GREATER         reduce using rule 63 (type -> LIST_TYPE .)
    RBRACE          reduce using rule 63 (type -> LIST_TYPE .)


state 45

    (64) type -> MAP_TYPE .
    (142) map -> MAP_TYPE . LESS type COMMA type GREATER
    (143) map -> MAP_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 64 (type -> MAP_TYPE .)
    IDENTIFIER      reduce using rule 64 (type -> MAP_TYPE .)
    ASSIGN          reduce using rule 64 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 64 (type -> MAP_TYPE .)
    LESS            shift and go to state 119

  ! IDENTIFIER      [ reduce using rule 143 (map -> MAP_TYPE .) ]


state 46

    (65) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 65 (type -> SET_TYPE .)
    ASSIGN          reduce using rule 65 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 65 (type -> SET_TYPE .)
    COMMA           reduce using rule 65 (type -> SET_TYPE .)
    COLON           reduce using rule 65 (type -> SET_TYPE .)
    GREATER         reduce using rule 65 (type -> SET_TYPE .)
    RBRACE          reduce using rule 65 (type -> SET_TYPE .)


state 47

    (66) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 66 (type -> DYNAMIC_TYPE .)
    ASSIGN          reduce using rule 66 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 66 (type -> DYNAMIC_TYPE .)
    COMMA           reduce using rule 66 (type -> DYNAMIC_TYPE .)
    COLON           reduce using rule 66 (type -> DYNAMIC_TYPE .)
    GREATER         reduce using rule 66 (type -> DYNAMIC_TYPE .)
    RBRACE          reduce using rule 66 (type -> DYNAMIC_TYPE .)


state 48

    (67) type -> VOID .

    IDENTIFIER      reduce using rule 67 (type -> VOID .)
    ASSIGN          reduce using rule 67 (type -> VOID .)
    QUESTION_MARK   reduce using rule 67 (type -> VOID .)
    COMMA           reduce using rule 67 (type -> VOID .)
    COLON           reduce using rule 67 (type -> VOID .)
    GREATER         reduce using rule 67 (type -> VOID .)
    RBRACE          reduce using rule 67 (type -> VOID .)


state 49

    (27) string_assignment -> type_string . IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> type_string . IDENTIFIER ASSIGN concate
    (30) string_assignment -> type_string . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> type_string . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (44) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 120
    QUESTION_MARK   shift and go to state 87

    nullable                       shift and go to state 121

state 50

    (112) value -> list .

    COMMA           reduce using rule 112 (value -> list .)
    EQUAL           reduce using rule 112 (value -> list .)
    NOT_EQUAL       reduce using rule 112 (value -> list .)
    LESS            reduce using rule 112 (value -> list .)
    LESS_EQUAL      reduce using rule 112 (value -> list .)
    GREATER         reduce using rule 112 (value -> list .)
    GREATER_EQUAL   reduce using rule 112 (value -> list .)
    LOGICAL_AND     reduce using rule 112 (value -> list .)
    LOGICAL_OR      reduce using rule 112 (value -> list .)
    $end            reduce using rule 112 (value -> list .)
    SEMICOLON       reduce using rule 112 (value -> list .)
    RPAREN          reduce using rule 112 (value -> list .)
    LINE_BREAK      reduce using rule 112 (value -> list .)
    PRINT           reduce using rule 112 (value -> list .)
    IF              reduce using rule 112 (value -> list .)
    WHILE           reduce using rule 112 (value -> list .)
    FOR             reduce using rule 112 (value -> list .)
    IDENTIFIER      reduce using rule 112 (value -> list .)
    FINAL           reduce using rule 112 (value -> list .)
    CONST           reduce using rule 112 (value -> list .)
    INTEGER_TYPE    reduce using rule 112 (value -> list .)
    DOUBLE_TYPE     reduce using rule 112 (value -> list .)
    BOOLEAN_TYPE    reduce using rule 112 (value -> list .)
    QUEUE_TYPE      reduce using rule 112 (value -> list .)
    STRING_TYPE     reduce using rule 112 (value -> list .)
    ENUM_TYPE       reduce using rule 112 (value -> list .)
    VAR             reduce using rule 112 (value -> list .)
    LIST_TYPE       reduce using rule 112 (value -> list .)
    MAP_TYPE        reduce using rule 112 (value -> list .)
    SET_TYPE        reduce using rule 112 (value -> list .)
    DYNAMIC_TYPE    reduce using rule 112 (value -> list .)
    VOID            reduce using rule 112 (value -> list .)
    RBRACE          reduce using rule 112 (value -> list .)
    LPAREN          reduce using rule 112 (value -> list .)
    LOGICAL_NOT     reduce using rule 112 (value -> list .)
    TRUE            reduce using rule 112 (value -> list .)
    FALSE           reduce using rule 112 (value -> list .)
    INTEGER         reduce using rule 112 (value -> list .)
    DOUBLE          reduce using rule 112 (value -> list .)
    STRING          reduce using rule 112 (value -> list .)
    LSQUARE         reduce using rule 112 (value -> list .)
    RSQUARE         reduce using rule 112 (value -> list .)


state 51

    (144) map_assigment -> map . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> map . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON

    IDENTIFIER      shift and go to state 122


state 52

    (113) number -> INTEGER .

    DIVIDE          reduce using rule 113 (number -> INTEGER .)
    EQUAL           reduce using rule 113 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 113 (number -> INTEGER .)
    LESS            reduce using rule 113 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 113 (number -> INTEGER .)
    GREATER         reduce using rule 113 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 113 (number -> INTEGER .)
    PLUS            reduce using rule 113 (number -> INTEGER .)
    MINUS           reduce using rule 113 (number -> INTEGER .)
    TIMES           reduce using rule 113 (number -> INTEGER .)
    $end            reduce using rule 113 (number -> INTEGER .)
    COMMA           reduce using rule 113 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 113 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 113 (number -> INTEGER .)
    SEMICOLON       reduce using rule 113 (number -> INTEGER .)
    RPAREN          reduce using rule 113 (number -> INTEGER .)
    LINE_BREAK      reduce using rule 113 (number -> INTEGER .)
    PRINT           reduce using rule 113 (number -> INTEGER .)
    IF              reduce using rule 113 (number -> INTEGER .)
    WHILE           reduce using rule 113 (number -> INTEGER .)
    FOR             reduce using rule 113 (number -> INTEGER .)
    IDENTIFIER      reduce using rule 113 (number -> INTEGER .)
    FINAL           reduce using rule 113 (number -> INTEGER .)
    CONST           reduce using rule 113 (number -> INTEGER .)
    INTEGER_TYPE    reduce using rule 113 (number -> INTEGER .)
    DOUBLE_TYPE     reduce using rule 113 (number -> INTEGER .)
    BOOLEAN_TYPE    reduce using rule 113 (number -> INTEGER .)
    QUEUE_TYPE      reduce using rule 113 (number -> INTEGER .)
    STRING_TYPE     reduce using rule 113 (number -> INTEGER .)
    ENUM_TYPE       reduce using rule 113 (number -> INTEGER .)
    VAR             reduce using rule 113 (number -> INTEGER .)
    LIST_TYPE       reduce using rule 113 (number -> INTEGER .)
    MAP_TYPE        reduce using rule 113 (number -> INTEGER .)
    SET_TYPE        reduce using rule 113 (number -> INTEGER .)
    DYNAMIC_TYPE    reduce using rule 113 (number -> INTEGER .)
    VOID            reduce using rule 113 (number -> INTEGER .)
    RBRACE          reduce using rule 113 (number -> INTEGER .)
    LPAREN          reduce using rule 113 (number -> INTEGER .)
    LOGICAL_NOT     reduce using rule 113 (number -> INTEGER .)
    TRUE            reduce using rule 113 (number -> INTEGER .)
    FALSE           reduce using rule 113 (number -> INTEGER .)
    INTEGER         reduce using rule 113 (number -> INTEGER .)
    DOUBLE          reduce using rule 113 (number -> INTEGER .)
    STRING          reduce using rule 113 (number -> INTEGER .)
    LSQUARE         reduce using rule 113 (number -> INTEGER .)
    RSQUARE         reduce using rule 113 (number -> INTEGER .)


state 53

    (114) number -> DOUBLE .

    DIVIDE          reduce using rule 114 (number -> DOUBLE .)
    EQUAL           reduce using rule 114 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 114 (number -> DOUBLE .)
    LESS            reduce using rule 114 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 114 (number -> DOUBLE .)
    GREATER         reduce using rule 114 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 114 (number -> DOUBLE .)
    PLUS            reduce using rule 114 (number -> DOUBLE .)
    MINUS           reduce using rule 114 (number -> DOUBLE .)
    TIMES           reduce using rule 114 (number -> DOUBLE .)
    $end            reduce using rule 114 (number -> DOUBLE .)
    COMMA           reduce using rule 114 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 114 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 114 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 114 (number -> DOUBLE .)
    RPAREN          reduce using rule 114 (number -> DOUBLE .)
    LINE_BREAK      reduce using rule 114 (number -> DOUBLE .)
    PRINT           reduce using rule 114 (number -> DOUBLE .)
    IF              reduce using rule 114 (number -> DOUBLE .)
    WHILE           reduce using rule 114 (number -> DOUBLE .)
    FOR             reduce using rule 114 (number -> DOUBLE .)
    IDENTIFIER      reduce using rule 114 (number -> DOUBLE .)
    FINAL           reduce using rule 114 (number -> DOUBLE .)
    CONST           reduce using rule 114 (number -> DOUBLE .)
    INTEGER_TYPE    reduce using rule 114 (number -> DOUBLE .)
    DOUBLE_TYPE     reduce using rule 114 (number -> DOUBLE .)
    BOOLEAN_TYPE    reduce using rule 114 (number -> DOUBLE .)
    QUEUE_TYPE      reduce using rule 114 (number -> DOUBLE .)
    STRING_TYPE     reduce using rule 114 (number -> DOUBLE .)
    ENUM_TYPE       reduce using rule 114 (number -> DOUBLE .)
    VAR             reduce using rule 114 (number -> DOUBLE .)
    LIST_TYPE       reduce using rule 114 (number -> DOUBLE .)
    MAP_TYPE        reduce using rule 114 (number -> DOUBLE .)
    SET_TYPE        reduce using rule 114 (number -> DOUBLE .)
    DYNAMIC_TYPE    reduce using rule 114 (number -> DOUBLE .)
    VOID            reduce using rule 114 (number -> DOUBLE .)
    RBRACE          reduce using rule 114 (number -> DOUBLE .)
    LPAREN          reduce using rule 114 (number -> DOUBLE .)
    LOGICAL_NOT     reduce using rule 114 (number -> DOUBLE .)
    TRUE            reduce using rule 114 (number -> DOUBLE .)
    FALSE           reduce using rule 114 (number -> DOUBLE .)
    INTEGER         reduce using rule 114 (number -> DOUBLE .)
    DOUBLE          reduce using rule 114 (number -> DOUBLE .)
    STRING          reduce using rule 114 (number -> DOUBLE .)
    LSQUARE         reduce using rule 114 (number -> DOUBLE .)
    RSQUARE         reduce using rule 114 (number -> DOUBLE .)


state 54

    (115) string -> STRING .

    EQUAL           reduce using rule 115 (string -> STRING .)
    NOT_EQUAL       reduce using rule 115 (string -> STRING .)
    LESS            reduce using rule 115 (string -> STRING .)
    LESS_EQUAL      reduce using rule 115 (string -> STRING .)
    GREATER         reduce using rule 115 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 115 (string -> STRING .)
    PLUS            reduce using rule 115 (string -> STRING .)
    $end            reduce using rule 115 (string -> STRING .)
    COMMA           reduce using rule 115 (string -> STRING .)
    LOGICAL_AND     reduce using rule 115 (string -> STRING .)
    LOGICAL_OR      reduce using rule 115 (string -> STRING .)
    SEMICOLON       reduce using rule 115 (string -> STRING .)
    RPAREN          reduce using rule 115 (string -> STRING .)
    LINE_BREAK      reduce using rule 115 (string -> STRING .)
    PRINT           reduce using rule 115 (string -> STRING .)
    IF              reduce using rule 115 (string -> STRING .)
    WHILE           reduce using rule 115 (string -> STRING .)
    FOR             reduce using rule 115 (string -> STRING .)
    IDENTIFIER      reduce using rule 115 (string -> STRING .)
    FINAL           reduce using rule 115 (string -> STRING .)
    CONST           reduce using rule 115 (string -> STRING .)
    INTEGER_TYPE    reduce using rule 115 (string -> STRING .)
    DOUBLE_TYPE     reduce using rule 115 (string -> STRING .)
    BOOLEAN_TYPE    reduce using rule 115 (string -> STRING .)
    QUEUE_TYPE      reduce using rule 115 (string -> STRING .)
    STRING_TYPE     reduce using rule 115 (string -> STRING .)
    ENUM_TYPE       reduce using rule 115 (string -> STRING .)
    VAR             reduce using rule 115 (string -> STRING .)
    LIST_TYPE       reduce using rule 115 (string -> STRING .)
    MAP_TYPE        reduce using rule 115 (string -> STRING .)
    SET_TYPE        reduce using rule 115 (string -> STRING .)
    DYNAMIC_TYPE    reduce using rule 115 (string -> STRING .)
    VOID            reduce using rule 115 (string -> STRING .)
    RBRACE          reduce using rule 115 (string -> STRING .)
    LPAREN          reduce using rule 115 (string -> STRING .)
    LOGICAL_NOT     reduce using rule 115 (string -> STRING .)
    TRUE            reduce using rule 115 (string -> STRING .)
    FALSE           reduce using rule 115 (string -> STRING .)
    INTEGER         reduce using rule 115 (string -> STRING .)
    DOUBLE          reduce using rule 115 (string -> STRING .)
    STRING          reduce using rule 115 (string -> STRING .)
    LSQUARE         reduce using rule 115 (string -> STRING .)
    RSQUARE         reduce using rule 115 (string -> STRING .)


state 55

    (81) comparison -> boolean .
    (86) int_comparison -> boolean .
    (89) string_comparison -> boolean .

  ! reduce/reduce conflict for EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LESS resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for GREATER resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for $end resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for RPAREN resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for PRINT resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for IF resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for WHILE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for FOR resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for FINAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for CONST resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for VAR resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for VOID resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for RBRACE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LPAREN resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_NOT resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for TRUE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for FALSE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for INTEGER resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for STRING resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LSQUARE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LESS resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for GREATER resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for $end resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for RPAREN resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for PRINT resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for IF resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for WHILE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for FOR resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for FINAL resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for CONST resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for VAR resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for VOID resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for RBRACE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LPAREN resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_NOT resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for TRUE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for FALSE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for INTEGER resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for STRING resolved using rule 81 (comparison -> boolean .)
  ! reduce/reduce conflict for LSQUARE resolved using rule 81 (comparison -> boolean .)
    EQUAL           reduce using rule 81 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 81 (comparison -> boolean .)
    LESS            reduce using rule 81 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 81 (comparison -> boolean .)
    GREATER         reduce using rule 81 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 81 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 81 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 81 (comparison -> boolean .)
    $end            reduce using rule 81 (comparison -> boolean .)
    SEMICOLON       reduce using rule 81 (comparison -> boolean .)
    RPAREN          reduce using rule 81 (comparison -> boolean .)
    LINE_BREAK      reduce using rule 81 (comparison -> boolean .)
    PRINT           reduce using rule 81 (comparison -> boolean .)
    IF              reduce using rule 81 (comparison -> boolean .)
    WHILE           reduce using rule 81 (comparison -> boolean .)
    FOR             reduce using rule 81 (comparison -> boolean .)
    IDENTIFIER      reduce using rule 81 (comparison -> boolean .)
    FINAL           reduce using rule 81 (comparison -> boolean .)
    CONST           reduce using rule 81 (comparison -> boolean .)
    INTEGER_TYPE    reduce using rule 81 (comparison -> boolean .)
    DOUBLE_TYPE     reduce using rule 81 (comparison -> boolean .)
    BOOLEAN_TYPE    reduce using rule 81 (comparison -> boolean .)
    QUEUE_TYPE      reduce using rule 81 (comparison -> boolean .)
    STRING_TYPE     reduce using rule 81 (comparison -> boolean .)
    ENUM_TYPE       reduce using rule 81 (comparison -> boolean .)
    VAR             reduce using rule 81 (comparison -> boolean .)
    LIST_TYPE       reduce using rule 81 (comparison -> boolean .)
    MAP_TYPE        reduce using rule 81 (comparison -> boolean .)
    SET_TYPE        reduce using rule 81 (comparison -> boolean .)
    DYNAMIC_TYPE    reduce using rule 81 (comparison -> boolean .)
    VOID            reduce using rule 81 (comparison -> boolean .)
    RBRACE          reduce using rule 81 (comparison -> boolean .)
    LPAREN          reduce using rule 81 (comparison -> boolean .)
    LOGICAL_NOT     reduce using rule 81 (comparison -> boolean .)
    TRUE            reduce using rule 81 (comparison -> boolean .)
    FALSE           reduce using rule 81 (comparison -> boolean .)
    INTEGER         reduce using rule 81 (comparison -> boolean .)
    DOUBLE          reduce using rule 81 (comparison -> boolean .)
    STRING          reduce using rule 81 (comparison -> boolean .)
    LSQUARE         reduce using rule 81 (comparison -> boolean .)

  ! EQUAL           [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! NOT_EQUAL       [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LESS            [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LESS_EQUAL      [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! GREATER         [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! GREATER_EQUAL   [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LOGICAL_AND     [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LOGICAL_OR      [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! $end            [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! SEMICOLON       [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! RPAREN          [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LINE_BREAK      [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! PRINT           [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! IF              [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! WHILE           [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! FOR             [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! IDENTIFIER      [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! FINAL           [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! CONST           [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! INTEGER_TYPE    [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! DOUBLE_TYPE     [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! QUEUE_TYPE      [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! STRING_TYPE     [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! ENUM_TYPE       [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! VAR             [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LIST_TYPE       [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! MAP_TYPE        [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! SET_TYPE        [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! VOID            [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! RBRACE          [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LPAREN          [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LOGICAL_NOT     [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! TRUE            [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! FALSE           [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! INTEGER         [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! DOUBLE          [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! STRING          [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! LSQUARE         [ reduce using rule 86 (int_comparison -> boolean .) ]
  ! EQUAL           [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! NOT_EQUAL       [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LESS            [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LESS_EQUAL      [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! GREATER         [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! GREATER_EQUAL   [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LOGICAL_AND     [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LOGICAL_OR      [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! $end            [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! SEMICOLON       [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! RPAREN          [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LINE_BREAK      [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! PRINT           [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! IF              [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! WHILE           [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! FOR             [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! IDENTIFIER      [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! FINAL           [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! CONST           [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! INTEGER_TYPE    [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! DOUBLE_TYPE     [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! QUEUE_TYPE      [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! STRING_TYPE     [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! ENUM_TYPE       [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! VAR             [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LIST_TYPE       [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! MAP_TYPE        [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! SET_TYPE        [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! VOID            [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! RBRACE          [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LPAREN          [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LOGICAL_NOT     [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! TRUE            [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! FALSE           [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! INTEGER         [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! DOUBLE          [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! STRING          [ reduce using rule 89 (string_comparison -> boolean .) ]
  ! LSQUARE         [ reduce using rule 89 (string_comparison -> boolean .) ]


state 56

    (84) comparison -> int_comparison .

    EQUAL           reduce using rule 84 (comparison -> int_comparison .)
    NOT_EQUAL       reduce using rule 84 (comparison -> int_comparison .)
    LESS            reduce using rule 84 (comparison -> int_comparison .)
    LESS_EQUAL      reduce using rule 84 (comparison -> int_comparison .)
    GREATER         reduce using rule 84 (comparison -> int_comparison .)
    GREATER_EQUAL   reduce using rule 84 (comparison -> int_comparison .)
    LOGICAL_AND     reduce using rule 84 (comparison -> int_comparison .)
    LOGICAL_OR      reduce using rule 84 (comparison -> int_comparison .)
    $end            reduce using rule 84 (comparison -> int_comparison .)
    SEMICOLON       reduce using rule 84 (comparison -> int_comparison .)
    RPAREN          reduce using rule 84 (comparison -> int_comparison .)
    LINE_BREAK      reduce using rule 84 (comparison -> int_comparison .)
    PRINT           reduce using rule 84 (comparison -> int_comparison .)
    IF              reduce using rule 84 (comparison -> int_comparison .)
    WHILE           reduce using rule 84 (comparison -> int_comparison .)
    FOR             reduce using rule 84 (comparison -> int_comparison .)
    IDENTIFIER      reduce using rule 84 (comparison -> int_comparison .)
    FINAL           reduce using rule 84 (comparison -> int_comparison .)
    CONST           reduce using rule 84 (comparison -> int_comparison .)
    INTEGER_TYPE    reduce using rule 84 (comparison -> int_comparison .)
    DOUBLE_TYPE     reduce using rule 84 (comparison -> int_comparison .)
    BOOLEAN_TYPE    reduce using rule 84 (comparison -> int_comparison .)
    QUEUE_TYPE      reduce using rule 84 (comparison -> int_comparison .)
    STRING_TYPE     reduce using rule 84 (comparison -> int_comparison .)
    ENUM_TYPE       reduce using rule 84 (comparison -> int_comparison .)
    VAR             reduce using rule 84 (comparison -> int_comparison .)
    LIST_TYPE       reduce using rule 84 (comparison -> int_comparison .)
    MAP_TYPE        reduce using rule 84 (comparison -> int_comparison .)
    SET_TYPE        reduce using rule 84 (comparison -> int_comparison .)
    DYNAMIC_TYPE    reduce using rule 84 (comparison -> int_comparison .)
    VOID            reduce using rule 84 (comparison -> int_comparison .)
    RBRACE          reduce using rule 84 (comparison -> int_comparison .)
    LPAREN          reduce using rule 84 (comparison -> int_comparison .)
    LOGICAL_NOT     reduce using rule 84 (comparison -> int_comparison .)
    TRUE            reduce using rule 84 (comparison -> int_comparison .)
    FALSE           reduce using rule 84 (comparison -> int_comparison .)
    INTEGER         reduce using rule 84 (comparison -> int_comparison .)
    DOUBLE          reduce using rule 84 (comparison -> int_comparison .)
    STRING          reduce using rule 84 (comparison -> int_comparison .)
    LSQUARE         reduce using rule 84 (comparison -> int_comparison .)


state 57

    (85) comparison -> string_comparison .

    EQUAL           reduce using rule 85 (comparison -> string_comparison .)
    NOT_EQUAL       reduce using rule 85 (comparison -> string_comparison .)
    LESS            reduce using rule 85 (comparison -> string_comparison .)
    LESS_EQUAL      reduce using rule 85 (comparison -> string_comparison .)
    GREATER         reduce using rule 85 (comparison -> string_comparison .)
    GREATER_EQUAL   reduce using rule 85 (comparison -> string_comparison .)
    LOGICAL_AND     reduce using rule 85 (comparison -> string_comparison .)
    LOGICAL_OR      reduce using rule 85 (comparison -> string_comparison .)
    $end            reduce using rule 85 (comparison -> string_comparison .)
    SEMICOLON       reduce using rule 85 (comparison -> string_comparison .)
    RPAREN          reduce using rule 85 (comparison -> string_comparison .)
    LINE_BREAK      reduce using rule 85 (comparison -> string_comparison .)
    PRINT           reduce using rule 85 (comparison -> string_comparison .)
    IF              reduce using rule 85 (comparison -> string_comparison .)
    WHILE           reduce using rule 85 (comparison -> string_comparison .)
    FOR             reduce using rule 85 (comparison -> string_comparison .)
    IDENTIFIER      reduce using rule 85 (comparison -> string_comparison .)
    FINAL           reduce using rule 85 (comparison -> string_comparison .)
    CONST           reduce using rule 85 (comparison -> string_comparison .)
    INTEGER_TYPE    reduce using rule 85 (comparison -> string_comparison .)
    DOUBLE_TYPE     reduce using rule 85 (comparison -> string_comparison .)
    BOOLEAN_TYPE    reduce using rule 85 (comparison -> string_comparison .)
    QUEUE_TYPE      reduce using rule 85 (comparison -> string_comparison .)
    STRING_TYPE     reduce using rule 85 (comparison -> string_comparison .)
    ENUM_TYPE       reduce using rule 85 (comparison -> string_comparison .)
    VAR             reduce using rule 85 (comparison -> string_comparison .)
    LIST_TYPE       reduce using rule 85 (comparison -> string_comparison .)
    MAP_TYPE        reduce using rule 85 (comparison -> string_comparison .)
    SET_TYPE        reduce using rule 85 (comparison -> string_comparison .)
    DYNAMIC_TYPE    reduce using rule 85 (comparison -> string_comparison .)
    VOID            reduce using rule 85 (comparison -> string_comparison .)
    RBRACE          reduce using rule 85 (comparison -> string_comparison .)
    LPAREN          reduce using rule 85 (comparison -> string_comparison .)
    LOGICAL_NOT     reduce using rule 85 (comparison -> string_comparison .)
    TRUE            reduce using rule 85 (comparison -> string_comparison .)
    FALSE           reduce using rule 85 (comparison -> string_comparison .)
    INTEGER         reduce using rule 85 (comparison -> string_comparison .)
    DOUBLE          reduce using rule 85 (comparison -> string_comparison .)
    STRING          reduce using rule 85 (comparison -> string_comparison .)
    LSQUARE         reduce using rule 85 (comparison -> string_comparison .)


state 58

    (107) values -> value .
    (108) values -> value . COMMA values

    EQUAL           reduce using rule 107 (values -> value .)
    NOT_EQUAL       reduce using rule 107 (values -> value .)
    LESS            reduce using rule 107 (values -> value .)
    LESS_EQUAL      reduce using rule 107 (values -> value .)
    GREATER         reduce using rule 107 (values -> value .)
    GREATER_EQUAL   reduce using rule 107 (values -> value .)
    LOGICAL_AND     reduce using rule 107 (values -> value .)
    LOGICAL_OR      reduce using rule 107 (values -> value .)
    $end            reduce using rule 107 (values -> value .)
    SEMICOLON       reduce using rule 107 (values -> value .)
    RPAREN          reduce using rule 107 (values -> value .)
    LINE_BREAK      reduce using rule 107 (values -> value .)
    PRINT           reduce using rule 107 (values -> value .)
    IF              reduce using rule 107 (values -> value .)
    WHILE           reduce using rule 107 (values -> value .)
    FOR             reduce using rule 107 (values -> value .)
    IDENTIFIER      reduce using rule 107 (values -> value .)
    FINAL           reduce using rule 107 (values -> value .)
    CONST           reduce using rule 107 (values -> value .)
    INTEGER_TYPE    reduce using rule 107 (values -> value .)
    DOUBLE_TYPE     reduce using rule 107 (values -> value .)
    BOOLEAN_TYPE    reduce using rule 107 (values -> value .)
    QUEUE_TYPE      reduce using rule 107 (values -> value .)
    STRING_TYPE     reduce using rule 107 (values -> value .)
    ENUM_TYPE       reduce using rule 107 (values -> value .)
    VAR             reduce using rule 107 (values -> value .)
    LIST_TYPE       reduce using rule 107 (values -> value .)
    MAP_TYPE        reduce using rule 107 (values -> value .)
    SET_TYPE        reduce using rule 107 (values -> value .)
    DYNAMIC_TYPE    reduce using rule 107 (values -> value .)
    VOID            reduce using rule 107 (values -> value .)
    RBRACE          reduce using rule 107 (values -> value .)
    LPAREN          reduce using rule 107 (values -> value .)
    LOGICAL_NOT     reduce using rule 107 (values -> value .)
    TRUE            reduce using rule 107 (values -> value .)
    FALSE           reduce using rule 107 (values -> value .)
    INTEGER         reduce using rule 107 (values -> value .)
    DOUBLE          reduce using rule 107 (values -> value .)
    STRING          reduce using rule 107 (values -> value .)
    LSQUARE         reduce using rule 107 (values -> value .)
    RSQUARE         reduce using rule 107 (values -> value .)
    COMMA           shift and go to state 123


state 59

    (116) boolean -> TRUE .

    EQUAL           reduce using rule 116 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 116 (boolean -> TRUE .)
    LESS            reduce using rule 116 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 116 (boolean -> TRUE .)
    GREATER         reduce using rule 116 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 116 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 116 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 116 (boolean -> TRUE .)
    $end            reduce using rule 116 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 116 (boolean -> TRUE .)
    RPAREN          reduce using rule 116 (boolean -> TRUE .)
    LINE_BREAK      reduce using rule 116 (boolean -> TRUE .)
    PRINT           reduce using rule 116 (boolean -> TRUE .)
    IF              reduce using rule 116 (boolean -> TRUE .)
    WHILE           reduce using rule 116 (boolean -> TRUE .)
    FOR             reduce using rule 116 (boolean -> TRUE .)
    IDENTIFIER      reduce using rule 116 (boolean -> TRUE .)
    FINAL           reduce using rule 116 (boolean -> TRUE .)
    CONST           reduce using rule 116 (boolean -> TRUE .)
    INTEGER_TYPE    reduce using rule 116 (boolean -> TRUE .)
    DOUBLE_TYPE     reduce using rule 116 (boolean -> TRUE .)
    BOOLEAN_TYPE    reduce using rule 116 (boolean -> TRUE .)
    QUEUE_TYPE      reduce using rule 116 (boolean -> TRUE .)
    STRING_TYPE     reduce using rule 116 (boolean -> TRUE .)
    ENUM_TYPE       reduce using rule 116 (boolean -> TRUE .)
    VAR             reduce using rule 116 (boolean -> TRUE .)
    LIST_TYPE       reduce using rule 116 (boolean -> TRUE .)
    MAP_TYPE        reduce using rule 116 (boolean -> TRUE .)
    SET_TYPE        reduce using rule 116 (boolean -> TRUE .)
    DYNAMIC_TYPE    reduce using rule 116 (boolean -> TRUE .)
    VOID            reduce using rule 116 (boolean -> TRUE .)
    RBRACE          reduce using rule 116 (boolean -> TRUE .)
    LPAREN          reduce using rule 116 (boolean -> TRUE .)
    LOGICAL_NOT     reduce using rule 116 (boolean -> TRUE .)
    TRUE            reduce using rule 116 (boolean -> TRUE .)
    FALSE           reduce using rule 116 (boolean -> TRUE .)
    INTEGER         reduce using rule 116 (boolean -> TRUE .)
    DOUBLE          reduce using rule 116 (boolean -> TRUE .)
    STRING          reduce using rule 116 (boolean -> TRUE .)
    LSQUARE         reduce using rule 116 (boolean -> TRUE .)


state 60

    (117) boolean -> FALSE .

    EQUAL           reduce using rule 117 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 117 (boolean -> FALSE .)
    LESS            reduce using rule 117 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 117 (boolean -> FALSE .)
    GREATER         reduce using rule 117 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 117 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 117 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 117 (boolean -> FALSE .)
    $end            reduce using rule 117 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 117 (boolean -> FALSE .)
    RPAREN          reduce using rule 117 (boolean -> FALSE .)
    LINE_BREAK      reduce using rule 117 (boolean -> FALSE .)
    PRINT           reduce using rule 117 (boolean -> FALSE .)
    IF              reduce using rule 117 (boolean -> FALSE .)
    WHILE           reduce using rule 117 (boolean -> FALSE .)
    FOR             reduce using rule 117 (boolean -> FALSE .)
    IDENTIFIER      reduce using rule 117 (boolean -> FALSE .)
    FINAL           reduce using rule 117 (boolean -> FALSE .)
    CONST           reduce using rule 117 (boolean -> FALSE .)
    INTEGER_TYPE    reduce using rule 117 (boolean -> FALSE .)
    DOUBLE_TYPE     reduce using rule 117 (boolean -> FALSE .)
    BOOLEAN_TYPE    reduce using rule 117 (boolean -> FALSE .)
    QUEUE_TYPE      reduce using rule 117 (boolean -> FALSE .)
    STRING_TYPE     reduce using rule 117 (boolean -> FALSE .)
    ENUM_TYPE       reduce using rule 117 (boolean -> FALSE .)
    VAR             reduce using rule 117 (boolean -> FALSE .)
    LIST_TYPE       reduce using rule 117 (boolean -> FALSE .)
    MAP_TYPE        reduce using rule 117 (boolean -> FALSE .)
    SET_TYPE        reduce using rule 117 (boolean -> FALSE .)
    DYNAMIC_TYPE    reduce using rule 117 (boolean -> FALSE .)
    VOID            reduce using rule 117 (boolean -> FALSE .)
    RBRACE          reduce using rule 117 (boolean -> FALSE .)
    LPAREN          reduce using rule 117 (boolean -> FALSE .)
    LOGICAL_NOT     reduce using rule 117 (boolean -> FALSE .)
    TRUE            reduce using rule 117 (boolean -> FALSE .)
    FALSE           reduce using rule 117 (boolean -> FALSE .)
    INTEGER         reduce using rule 117 (boolean -> FALSE .)
    DOUBLE          reduce using rule 117 (boolean -> FALSE .)
    STRING          reduce using rule 117 (boolean -> FALSE .)
    LSQUARE         reduce using rule 117 (boolean -> FALSE .)


state 61

    (118) list -> LSQUARE . RSQUARE
    (119) list -> LSQUARE . values RSQUARE
    (107) values -> . value
    (108) values -> . value COMMA values
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 124
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    values                         shift and go to state 125
    value                          shift and go to state 58
    number                         shift and go to state 126
    string                         shift and go to state 127
    list                           shift and go to state 50

state 62

    (50) if_statement -> if_statement ELSE . if_statement
    (51) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 129
    IF              shift and go to state 25

    if_statement                   shift and go to state 128

state 63

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 130


state 64

    (128) line -> print .

    LINE_BREAK      reduce using rule 128 (line -> print .)
    PRINT           reduce using rule 128 (line -> print .)
    IF              reduce using rule 128 (line -> print .)
    WHILE           reduce using rule 128 (line -> print .)
    FOR             reduce using rule 128 (line -> print .)
    IDENTIFIER      reduce using rule 128 (line -> print .)
    FINAL           reduce using rule 128 (line -> print .)
    CONST           reduce using rule 128 (line -> print .)
    INTEGER_TYPE    reduce using rule 128 (line -> print .)
    DOUBLE_TYPE     reduce using rule 128 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 128 (line -> print .)
    QUEUE_TYPE      reduce using rule 128 (line -> print .)
    STRING_TYPE     reduce using rule 128 (line -> print .)
    ENUM_TYPE       reduce using rule 128 (line -> print .)
    VAR             reduce using rule 128 (line -> print .)
    LIST_TYPE       reduce using rule 128 (line -> print .)
    MAP_TYPE        reduce using rule 128 (line -> print .)
    SET_TYPE        reduce using rule 128 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 128 (line -> print .)
    VOID            reduce using rule 128 (line -> print .)
    RBRACE          reduce using rule 128 (line -> print .)
    $end            reduce using rule 128 (line -> print .)


state 65

    (129) line -> assignment .

    LINE_BREAK      reduce using rule 129 (line -> assignment .)
    PRINT           reduce using rule 129 (line -> assignment .)
    IF              reduce using rule 129 (line -> assignment .)
    WHILE           reduce using rule 129 (line -> assignment .)
    FOR             reduce using rule 129 (line -> assignment .)
    IDENTIFIER      reduce using rule 129 (line -> assignment .)
    FINAL           reduce using rule 129 (line -> assignment .)
    CONST           reduce using rule 129 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 129 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 129 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 129 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 129 (line -> assignment .)
    STRING_TYPE     reduce using rule 129 (line -> assignment .)
    ENUM_TYPE       reduce using rule 129 (line -> assignment .)
    VAR             reduce using rule 129 (line -> assignment .)
    LIST_TYPE       reduce using rule 129 (line -> assignment .)
    MAP_TYPE        reduce using rule 129 (line -> assignment .)
    SET_TYPE        reduce using rule 129 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 129 (line -> assignment .)
    VOID            reduce using rule 129 (line -> assignment .)
    RBRACE          reduce using rule 129 (line -> assignment .)
    $end            reduce using rule 129 (line -> assignment .)


state 66

    (130) line -> function .

    LINE_BREAK      reduce using rule 130 (line -> function .)
    PRINT           reduce using rule 130 (line -> function .)
    IF              reduce using rule 130 (line -> function .)
    WHILE           reduce using rule 130 (line -> function .)
    FOR             reduce using rule 130 (line -> function .)
    IDENTIFIER      reduce using rule 130 (line -> function .)
    FINAL           reduce using rule 130 (line -> function .)
    CONST           reduce using rule 130 (line -> function .)
    INTEGER_TYPE    reduce using rule 130 (line -> function .)
    DOUBLE_TYPE     reduce using rule 130 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 130 (line -> function .)
    QUEUE_TYPE      reduce using rule 130 (line -> function .)
    STRING_TYPE     reduce using rule 130 (line -> function .)
    ENUM_TYPE       reduce using rule 130 (line -> function .)
    VAR             reduce using rule 130 (line -> function .)
    LIST_TYPE       reduce using rule 130 (line -> function .)
    MAP_TYPE        reduce using rule 130 (line -> function .)
    SET_TYPE        reduce using rule 130 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 130 (line -> function .)
    VOID            reduce using rule 130 (line -> function .)
    RBRACE          reduce using rule 130 (line -> function .)
    $end            reduce using rule 130 (line -> function .)


state 67

    (131) line -> if_statement .
    (50) if_statement -> if_statement . ELSE if_statement
    (51) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 131 (line -> if_statement .)
    PRINT           reduce using rule 131 (line -> if_statement .)
    IF              reduce using rule 131 (line -> if_statement .)
    WHILE           reduce using rule 131 (line -> if_statement .)
    FOR             reduce using rule 131 (line -> if_statement .)
    IDENTIFIER      reduce using rule 131 (line -> if_statement .)
    FINAL           reduce using rule 131 (line -> if_statement .)
    CONST           reduce using rule 131 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 131 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 131 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 131 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 131 (line -> if_statement .)
    STRING_TYPE     reduce using rule 131 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 131 (line -> if_statement .)
    VAR             reduce using rule 131 (line -> if_statement .)
    LIST_TYPE       reduce using rule 131 (line -> if_statement .)
    MAP_TYPE        reduce using rule 131 (line -> if_statement .)
    SET_TYPE        reduce using rule 131 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 131 (line -> if_statement .)
    VOID            reduce using rule 131 (line -> if_statement .)
    RBRACE          reduce using rule 131 (line -> if_statement .)
    $end            reduce using rule 131 (line -> if_statement .)
    ELSE            shift and go to state 62


state 68

    (132) line -> while_statement .

    LINE_BREAK      reduce using rule 132 (line -> while_statement .)
    PRINT           reduce using rule 132 (line -> while_statement .)
    IF              reduce using rule 132 (line -> while_statement .)
    WHILE           reduce using rule 132 (line -> while_statement .)
    FOR             reduce using rule 132 (line -> while_statement .)
    IDENTIFIER      reduce using rule 132 (line -> while_statement .)
    FINAL           reduce using rule 132 (line -> while_statement .)
    CONST           reduce using rule 132 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 132 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 132 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 132 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 132 (line -> while_statement .)
    STRING_TYPE     reduce using rule 132 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 132 (line -> while_statement .)
    VAR             reduce using rule 132 (line -> while_statement .)
    LIST_TYPE       reduce using rule 132 (line -> while_statement .)
    MAP_TYPE        reduce using rule 132 (line -> while_statement .)
    SET_TYPE        reduce using rule 132 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 132 (line -> while_statement .)
    VOID            reduce using rule 132 (line -> while_statement .)
    RBRACE          reduce using rule 132 (line -> while_statement .)
    $end            reduce using rule 132 (line -> while_statement .)


state 69

    (133) line -> for_statement .

    LINE_BREAK      reduce using rule 133 (line -> for_statement .)
    PRINT           reduce using rule 133 (line -> for_statement .)
    IF              reduce using rule 133 (line -> for_statement .)
    WHILE           reduce using rule 133 (line -> for_statement .)
    FOR             reduce using rule 133 (line -> for_statement .)
    IDENTIFIER      reduce using rule 133 (line -> for_statement .)
    FINAL           reduce using rule 133 (line -> for_statement .)
    CONST           reduce using rule 133 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 133 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 133 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 133 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 133 (line -> for_statement .)
    STRING_TYPE     reduce using rule 133 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 133 (line -> for_statement .)
    VAR             reduce using rule 133 (line -> for_statement .)
    LIST_TYPE       reduce using rule 133 (line -> for_statement .)
    MAP_TYPE        reduce using rule 133 (line -> for_statement .)
    SET_TYPE        reduce using rule 133 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 133 (line -> for_statement .)
    VOID            reduce using rule 133 (line -> for_statement .)
    RBRACE          reduce using rule 133 (line -> for_statement .)
    $end            reduce using rule 133 (line -> for_statement .)


state 70

    (134) line -> function_call .

    LINE_BREAK      reduce using rule 134 (line -> function_call .)
    PRINT           reduce using rule 134 (line -> function_call .)
    IF              reduce using rule 134 (line -> function_call .)
    WHILE           reduce using rule 134 (line -> function_call .)
    FOR             reduce using rule 134 (line -> function_call .)
    IDENTIFIER      reduce using rule 134 (line -> function_call .)
    FINAL           reduce using rule 134 (line -> function_call .)
    CONST           reduce using rule 134 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 134 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 134 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 134 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 134 (line -> function_call .)
    STRING_TYPE     reduce using rule 134 (line -> function_call .)
    ENUM_TYPE       reduce using rule 134 (line -> function_call .)
    VAR             reduce using rule 134 (line -> function_call .)
    LIST_TYPE       reduce using rule 134 (line -> function_call .)
    MAP_TYPE        reduce using rule 134 (line -> function_call .)
    SET_TYPE        reduce using rule 134 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 134 (line -> function_call .)
    VOID            reduce using rule 134 (line -> function_call .)
    RBRACE          reduce using rule 134 (line -> function_call .)
    $end            reduce using rule 134 (line -> function_call .)


state 71

    (135) line -> reassignment .

    LINE_BREAK      reduce using rule 135 (line -> reassignment .)
    PRINT           reduce using rule 135 (line -> reassignment .)
    IF              reduce using rule 135 (line -> reassignment .)
    WHILE           reduce using rule 135 (line -> reassignment .)
    FOR             reduce using rule 135 (line -> reassignment .)
    IDENTIFIER      reduce using rule 135 (line -> reassignment .)
    FINAL           reduce using rule 135 (line -> reassignment .)
    CONST           reduce using rule 135 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 135 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 135 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 135 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 135 (line -> reassignment .)
    STRING_TYPE     reduce using rule 135 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 135 (line -> reassignment .)
    VAR             reduce using rule 135 (line -> reassignment .)
    LIST_TYPE       reduce using rule 135 (line -> reassignment .)
    MAP_TYPE        reduce using rule 135 (line -> reassignment .)
    SET_TYPE        reduce using rule 135 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 135 (line -> reassignment .)
    VOID            reduce using rule 135 (line -> reassignment .)
    RBRACE          reduce using rule 135 (line -> reassignment .)
    $end            reduce using rule 135 (line -> reassignment .)


state 72

    (52) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (53) function_call -> IDENTIFIER . LPAREN values RPAREN
    (54) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (55) function_call -> IDENTIFIER . LPAREN RPAREN
    (39) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (40) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH number
    (43) reassignment -> IDENTIFIER . INLINE_ARITH
    (120) list_assigment -> IDENTIFIER . ASSIGN list SEMICOLON
    (146) map_assigment -> IDENTIFIER . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON

    LPAREN          shift and go to state 91
    ASSIGN          shift and go to state 89
    INLINE_ARITH    shift and go to state 90
    IDENTIFIER      shift and go to state 88


state 73

    (74) arithmetic -> arithmetic arith_op . arithmetic
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (113) number -> . INTEGER
    (114) number -> . DOUBLE

    LPAREN          shift and go to state 133
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 131
    number                         shift and go to state 132

state 74

    (98) arith_op -> PLUS .

    LPAREN          reduce using rule 98 (arith_op -> PLUS .)
    INTEGER         reduce using rule 98 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 98 (arith_op -> PLUS .)


state 75

    (99) arith_op -> MINUS .

    LPAREN          reduce using rule 99 (arith_op -> MINUS .)
    INTEGER         reduce using rule 99 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 99 (arith_op -> MINUS .)


state 76

    (100) arith_op -> TIMES .

    LPAREN          reduce using rule 100 (arith_op -> TIMES .)
    INTEGER         reduce using rule 100 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 100 (arith_op -> TIMES .)


state 77

    (78) concate -> concate PLUS . concate
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (115) string -> . STRING

    LPAREN          shift and go to state 136
    STRING          shift and go to state 54

    concate                        shift and go to state 134
    string                         shift and go to state 135

state 78

    (93) logic -> logic logic_op . logic
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 116
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    logic                          shift and go to state 137
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    number                         shift and go to state 117
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 79

    (96) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 96 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 96 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 96 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 96 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 96 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 96 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 96 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 96 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 96 (logic_op -> LOGICAL_AND .)


state 80

    (97) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 97 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 97 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 97 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 97 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 97 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 97 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 97 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 97 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 97 (logic_op -> LOGICAL_OR .)


state 81

    (12) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (44) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 139
    QUESTION_MARK   shift and go to state 87

    nullable                       shift and go to state 138

state 82

    (29) string_assignment -> modifier type_string . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> modifier type_string . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> modifier type_string . IDENTIFIER ASSIGN concate SEMICOLON
    (44) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 141
    QUESTION_MARK   shift and go to state 87

    nullable                       shift and go to state 140

state 83

    (64) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 64 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 64 (type -> MAP_TYPE .)
    COMMA           reduce using rule 64 (type -> MAP_TYPE .)
    COLON           reduce using rule 64 (type -> MAP_TYPE .)
    GREATER         reduce using rule 64 (type -> MAP_TYPE .)
    RBRACE          reduce using rule 64 (type -> MAP_TYPE .)


state 84

    (13) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 142


state 85

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression
    (122) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 143
    LPAREN          shift and go to state 144


state 86

    (121) list_assigment -> type ASSIGN . list SEMICOLON
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LSQUARE         shift and go to state 61

    list                           shift and go to state 145

state 87

    (44) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 44 (nullable -> QUESTION_MARK .)


state 88

    (146) map_assigment -> IDENTIFIER IDENTIFIER . ASSIGN LBRACE map_values RBRACE SEMICOLON

    ASSIGN          shift and go to state 146


state 89

    (39) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (120) list_assigment -> IDENTIFIER ASSIGN . list SEMICOLON
    (147) map_assigment -> IDENTIFIER ASSIGN . LBRACE RBRACE SEMICOLON
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list

    LBRACE          shift and go to state 150
    LSQUARE         shift and go to state 61
    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 147
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    expression                     shift and go to state 148
    list                           shift and go to state 149
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 151
    division                       shift and go to state 16
    values                         shift and go to state 34
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58

state 90

    (40) reassignment -> IDENTIFIER INLINE_ARITH . number SEMICOLON
    (41) reassignment -> IDENTIFIER INLINE_ARITH . SEMICOLON
    (42) reassignment -> IDENTIFIER INLINE_ARITH . number
    (43) reassignment -> IDENTIFIER INLINE_ARITH .
    (113) number -> . INTEGER
    (114) number -> . DOUBLE

    SEMICOLON       shift and go to state 153
    $end            reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LINE_BREAK      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    PRINT           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IF              reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    WHILE           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FOR             reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IDENTIFIER      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FINAL           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    CONST           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DOUBLE_TYPE     reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    BOOLEAN_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    QUEUE_TYPE      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    STRING_TYPE     reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    ENUM_TYPE       reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VAR             reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LIST_TYPE       reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    MAP_TYPE        reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    SET_TYPE        reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DYNAMIC_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VOID            reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RBRACE          reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RPAREN          reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 152

state 91

    (52) function_call -> IDENTIFIER LPAREN . values RPAREN SEMICOLON
    (53) function_call -> IDENTIFIER LPAREN . values RPAREN
    (54) function_call -> IDENTIFIER LPAREN . RPAREN SEMICOLON
    (55) function_call -> IDENTIFIER LPAREN . RPAREN
    (107) values -> . value
    (108) values -> . value COMMA values
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 155
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    values                         shift and go to state 154
    value                          shift and go to state 58
    number                         shift and go to state 126
    string                         shift and go to state 127
    list                           shift and go to state 50

state 92

    (47) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (48) print -> PRINT LPAREN . RPAREN SEMICOLON
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 157
    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 147
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    LSQUARE         shift and go to state 61

    expression                     shift and go to state 156
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 151
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 93

    (75) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (74) arithmetic -> arithmetic . arith_op arithmetic
    (98) arith_op -> . PLUS
    (99) arith_op -> . MINUS
    (100) arith_op -> . TIMES

    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76

    arith_op                       shift and go to state 158

state 94

    (79) concate -> LPAREN concate . PLUS concate RPAREN
    (78) concate -> concate . PLUS concate

    PLUS            shift and go to state 159


state 95

    (94) logic -> LPAREN logic . logic_op logic RPAREN
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

    logic_op                       shift and go to state 160

state 96

    (83) comparison -> LPAREN comparison . comp_op number comparison
    (92) logic -> comparison .
    (82) comparison -> comparison . comp_op comparison
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 92 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 92 (logic -> comparison .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

    comp_op                        shift and go to state 161

state 97

    (88) int_comparison -> LPAREN number . comp_op number RPAREN
    (73) arithmetic -> number .
    (87) int_comparison -> number . comp_op number
    (110) value -> number .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    PLUS            reduce using rule 73 (arithmetic -> number .)
    MINUS           reduce using rule 73 (arithmetic -> number .)
    TIMES           reduce using rule 73 (arithmetic -> number .)
    COMMA           reduce using rule 110 (value -> number .)
    LOGICAL_AND     reduce using rule 110 (value -> number .)
    LOGICAL_OR      reduce using rule 110 (value -> number .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 110 (value -> number .) ]
  ! NOT_EQUAL       [ reduce using rule 110 (value -> number .) ]
  ! LESS            [ reduce using rule 110 (value -> number .) ]
  ! LESS_EQUAL      [ reduce using rule 110 (value -> number .) ]
  ! GREATER         [ reduce using rule 110 (value -> number .) ]
  ! GREATER_EQUAL   [ reduce using rule 110 (value -> number .) ]

    comp_op                        shift and go to state 162

state 98

    (91) string_comparison -> LPAREN string . comp_op string RPAREN
    (77) concate -> string .
    (90) string_comparison -> string . comp_op string
    (111) value -> string .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    PLUS            reduce using rule 77 (concate -> string .)
    COMMA           reduce using rule 111 (value -> string .)
    LOGICAL_AND     reduce using rule 111 (value -> string .)
    LOGICAL_OR      reduce using rule 111 (value -> string .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 111 (value -> string .) ]
  ! NOT_EQUAL       [ reduce using rule 111 (value -> string .) ]
  ! LESS            [ reduce using rule 111 (value -> string .) ]
  ! LESS_EQUAL      [ reduce using rule 111 (value -> string .) ]
  ! GREATER         [ reduce using rule 111 (value -> string .) ]
  ! GREATER_EQUAL   [ reduce using rule 111 (value -> string .) ]

    comp_op                        shift and go to state 163

state 99

    (109) value -> IDENTIFIER .

    COMMA           reduce using rule 109 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 109 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 109 (value -> IDENTIFIER .)
    LESS            reduce using rule 109 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 109 (value -> IDENTIFIER .)
    GREATER         reduce using rule 109 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 109 (value -> IDENTIFIER .)
    $end            reduce using rule 109 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 109 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 109 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 109 (value -> IDENTIFIER .)
    PRINT           reduce using rule 109 (value -> IDENTIFIER .)
    IF              reduce using rule 109 (value -> IDENTIFIER .)
    WHILE           reduce using rule 109 (value -> IDENTIFIER .)
    FOR             reduce using rule 109 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 109 (value -> IDENTIFIER .)
    FINAL           reduce using rule 109 (value -> IDENTIFIER .)
    CONST           reduce using rule 109 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 109 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 109 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 109 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 109 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 109 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 109 (value -> IDENTIFIER .)
    VAR             reduce using rule 109 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 109 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 109 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 109 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 109 (value -> IDENTIFIER .)
    VOID            reduce using rule 109 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 109 (value -> IDENTIFIER .)
    LPAREN          reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 109 (value -> IDENTIFIER .)
    TRUE            reduce using rule 109 (value -> IDENTIFIER .)
    FALSE           reduce using rule 109 (value -> IDENTIFIER .)
    INTEGER         reduce using rule 109 (value -> IDENTIFIER .)
    DOUBLE          reduce using rule 109 (value -> IDENTIFIER .)
    STRING          reduce using rule 109 (value -> IDENTIFIER .)
    LSQUARE         reduce using rule 109 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 109 (value -> IDENTIFIER .)


state 100

    (49) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 116
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    logic                          shift and go to state 164
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    number                         shift and go to state 117
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 101

    (156) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 116
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    logic                          shift and go to state 165
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    number                         shift and go to state 117
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 102

    (157) for_statement -> FOR LPAREN . assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48
    IDENTIFIER      shift and go to state 168

    assignment                     shift and go to state 166
    modifier                       shift and go to state 17
    type                           shift and go to state 167
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 103

    (123) lines -> line LINE_BREAK . lines
    (126) lines -> LINE_BREAK .
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

  ! reduce/reduce conflict for $end resolved using rule 126 (lines -> LINE_BREAK .)
  ! reduce/reduce conflict for RBRACE resolved using rule 126 (lines -> LINE_BREAK .)
    $end            reduce using rule 126 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 126 (lines -> LINE_BREAK .)
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

  ! $end            [ reduce using rule 127 (lines -> .) ]
  ! RBRACE          [ reduce using rule 127 (lines -> .) ]

    line                           shift and go to state 28
    lines                          shift and go to state 169
    print                          shift and go to state 64
    assignment                     shift and go to state 65
    function                       shift and go to state 66
    if_statement                   shift and go to state 67
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    reassignment                   shift and go to state 71
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 104

    (124) lines -> line lines .

    $end            reduce using rule 124 (lines -> line lines .)
    RBRACE          reduce using rule 124 (lines -> line lines .)


state 105

    (76) division -> number DIVIDE . number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE

    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 170

state 106

    (87) int_comparison -> number comp_op . number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE

    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 171

state 107

    (101) comp_op -> EQUAL .

    INTEGER         reduce using rule 101 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 101 (comp_op -> EQUAL .)
    STRING          reduce using rule 101 (comp_op -> EQUAL .)
    LPAREN          reduce using rule 101 (comp_op -> EQUAL .)
    TRUE            reduce using rule 101 (comp_op -> EQUAL .)
    FALSE           reduce using rule 101 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 101 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 101 (comp_op -> EQUAL .)


state 108

    (102) comp_op -> NOT_EQUAL .

    INTEGER         reduce using rule 102 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 102 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 102 (comp_op -> NOT_EQUAL .)
    LPAREN          reduce using rule 102 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 102 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 102 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 102 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 102 (comp_op -> NOT_EQUAL .)


state 109

    (103) comp_op -> LESS .

    INTEGER         reduce using rule 103 (comp_op -> LESS .)
    DOUBLE          reduce using rule 103 (comp_op -> LESS .)
    STRING          reduce using rule 103 (comp_op -> LESS .)
    LPAREN          reduce using rule 103 (comp_op -> LESS .)
    TRUE            reduce using rule 103 (comp_op -> LESS .)
    FALSE           reduce using rule 103 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 103 (comp_op -> LESS .)
    LSQUARE         reduce using rule 103 (comp_op -> LESS .)


state 110

    (104) comp_op -> LESS_EQUAL .

    INTEGER         reduce using rule 104 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 104 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 104 (comp_op -> LESS_EQUAL .)
    LPAREN          reduce using rule 104 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 104 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 104 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 104 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 104 (comp_op -> LESS_EQUAL .)


state 111

    (105) comp_op -> GREATER .

    INTEGER         reduce using rule 105 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 105 (comp_op -> GREATER .)
    STRING          reduce using rule 105 (comp_op -> GREATER .)
    LPAREN          reduce using rule 105 (comp_op -> GREATER .)
    TRUE            reduce using rule 105 (comp_op -> GREATER .)
    FALSE           reduce using rule 105 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 105 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 105 (comp_op -> GREATER .)


state 112

    (106) comp_op -> GREATER_EQUAL .

    INTEGER         reduce using rule 106 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 106 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 106 (comp_op -> GREATER_EQUAL .)
    LPAREN          reduce using rule 106 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 106 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 106 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 106 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 106 (comp_op -> GREATER_EQUAL .)


state 113

    (90) string_comparison -> string comp_op . string
    (115) string -> . STRING

    STRING          shift and go to state 54

    string                         shift and go to state 172

state 114

    (82) comparison -> comparison comp_op . comparison
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 174
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    comparison                     shift and go to state 173
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    number                         shift and go to state 117
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 115

    (95) logic -> LOGICAL_NOT logic .
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    LINE_BREAK      reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    PRINT           reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    IF              reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    WHILE           reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    FOR             reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    IDENTIFIER      reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    FINAL           reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    CONST           reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    INTEGER_TYPE    reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    DOUBLE_TYPE     reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    BOOLEAN_TYPE    reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    QUEUE_TYPE      reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    STRING_TYPE     reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    ENUM_TYPE       reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    VAR             reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    LIST_TYPE       reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    MAP_TYPE        reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    SET_TYPE        reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    DYNAMIC_TYPE    reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    VOID            reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    RBRACE          reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    LPAREN          reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    LOGICAL_NOT     reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    TRUE            reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    FALSE           reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    INTEGER         reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    DOUBLE          reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    STRING          reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    LSQUARE         reduce using rule 95 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

  ! LOGICAL_AND     [ reduce using rule 95 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 95 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 78

state 116

    (94) logic -> LPAREN . logic logic_op logic RPAREN
    (83) comparison -> LPAREN . comparison comp_op number comparison
    (88) int_comparison -> LPAREN . number comp_op number RPAREN
    (91) string_comparison -> LPAREN . string comp_op string RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 116
    LOGICAL_NOT     shift and go to state 33
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    LSQUARE         shift and go to state 61

    logic                          shift and go to state 95
    comparison                     shift and go to state 96
    number                         shift and go to state 175
    string                         shift and go to state 176
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 117

    (87) int_comparison -> number . comp_op number
    (110) value -> number .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    COMMA           reduce using rule 110 (value -> number .)
    LOGICAL_AND     reduce using rule 110 (value -> number .)
    LOGICAL_OR      reduce using rule 110 (value -> number .)
    $end            reduce using rule 110 (value -> number .)
    SEMICOLON       reduce using rule 110 (value -> number .)
    RPAREN          reduce using rule 110 (value -> number .)
    LINE_BREAK      reduce using rule 110 (value -> number .)
    PRINT           reduce using rule 110 (value -> number .)
    IF              reduce using rule 110 (value -> number .)
    WHILE           reduce using rule 110 (value -> number .)
    FOR             reduce using rule 110 (value -> number .)
    IDENTIFIER      reduce using rule 110 (value -> number .)
    FINAL           reduce using rule 110 (value -> number .)
    CONST           reduce using rule 110 (value -> number .)
    INTEGER_TYPE    reduce using rule 110 (value -> number .)
    DOUBLE_TYPE     reduce using rule 110 (value -> number .)
    BOOLEAN_TYPE    reduce using rule 110 (value -> number .)
    QUEUE_TYPE      reduce using rule 110 (value -> number .)
    STRING_TYPE     reduce using rule 110 (value -> number .)
    ENUM_TYPE       reduce using rule 110 (value -> number .)
    VAR             reduce using rule 110 (value -> number .)
    LIST_TYPE       reduce using rule 110 (value -> number .)
    MAP_TYPE        reduce using rule 110 (value -> number .)
    SET_TYPE        reduce using rule 110 (value -> number .)
    DYNAMIC_TYPE    reduce using rule 110 (value -> number .)
    VOID            reduce using rule 110 (value -> number .)
    RBRACE          reduce using rule 110 (value -> number .)
    LPAREN          reduce using rule 110 (value -> number .)
    LOGICAL_NOT     reduce using rule 110 (value -> number .)
    TRUE            reduce using rule 110 (value -> number .)
    FALSE           reduce using rule 110 (value -> number .)
    INTEGER         reduce using rule 110 (value -> number .)
    DOUBLE          reduce using rule 110 (value -> number .)
    STRING          reduce using rule 110 (value -> number .)
    LSQUARE         reduce using rule 110 (value -> number .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 110 (value -> number .) ]
  ! NOT_EQUAL       [ reduce using rule 110 (value -> number .) ]
  ! LESS            [ reduce using rule 110 (value -> number .) ]
  ! LESS_EQUAL      [ reduce using rule 110 (value -> number .) ]
  ! GREATER         [ reduce using rule 110 (value -> number .) ]
  ! GREATER_EQUAL   [ reduce using rule 110 (value -> number .) ]

    comp_op                        shift and go to state 106

state 118

    (90) string_comparison -> string . comp_op string
    (111) value -> string .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    COMMA           reduce using rule 111 (value -> string .)
    LOGICAL_AND     reduce using rule 111 (value -> string .)
    LOGICAL_OR      reduce using rule 111 (value -> string .)
    $end            reduce using rule 111 (value -> string .)
    SEMICOLON       reduce using rule 111 (value -> string .)
    RPAREN          reduce using rule 111 (value -> string .)
    LINE_BREAK      reduce using rule 111 (value -> string .)
    PRINT           reduce using rule 111 (value -> string .)
    IF              reduce using rule 111 (value -> string .)
    WHILE           reduce using rule 111 (value -> string .)
    FOR             reduce using rule 111 (value -> string .)
    IDENTIFIER      reduce using rule 111 (value -> string .)
    FINAL           reduce using rule 111 (value -> string .)
    CONST           reduce using rule 111 (value -> string .)
    INTEGER_TYPE    reduce using rule 111 (value -> string .)
    DOUBLE_TYPE     reduce using rule 111 (value -> string .)
    BOOLEAN_TYPE    reduce using rule 111 (value -> string .)
    QUEUE_TYPE      reduce using rule 111 (value -> string .)
    STRING_TYPE     reduce using rule 111 (value -> string .)
    ENUM_TYPE       reduce using rule 111 (value -> string .)
    VAR             reduce using rule 111 (value -> string .)
    LIST_TYPE       reduce using rule 111 (value -> string .)
    MAP_TYPE        reduce using rule 111 (value -> string .)
    SET_TYPE        reduce using rule 111 (value -> string .)
    DYNAMIC_TYPE    reduce using rule 111 (value -> string .)
    VOID            reduce using rule 111 (value -> string .)
    RBRACE          reduce using rule 111 (value -> string .)
    LPAREN          reduce using rule 111 (value -> string .)
    LOGICAL_NOT     reduce using rule 111 (value -> string .)
    TRUE            reduce using rule 111 (value -> string .)
    FALSE           reduce using rule 111 (value -> string .)
    INTEGER         reduce using rule 111 (value -> string .)
    DOUBLE          reduce using rule 111 (value -> string .)
    STRING          reduce using rule 111 (value -> string .)
    LSQUARE         reduce using rule 111 (value -> string .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 111 (value -> string .) ]
  ! NOT_EQUAL       [ reduce using rule 111 (value -> string .) ]
  ! LESS            [ reduce using rule 111 (value -> string .) ]
  ! LESS_EQUAL      [ reduce using rule 111 (value -> string .) ]
  ! GREATER         [ reduce using rule 111 (value -> string .) ]
  ! GREATER_EQUAL   [ reduce using rule 111 (value -> string .) ]

    comp_op                        shift and go to state 113

state 119

    (142) map -> MAP_TYPE LESS . type COMMA type GREATER
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 177

state 120

    (27) string_assignment -> type_string IDENTIFIER . ASSIGN concate SEMICOLON
    (28) string_assignment -> type_string IDENTIFIER . ASSIGN concate

    ASSIGN          shift and go to state 180


state 121

    (30) string_assignment -> type_string nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> type_string nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 181


state 122

    (144) map_assigment -> map IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> map IDENTIFIER . ASSIGN LBRACE map_values RBRACE SEMICOLON

    ASSIGN          shift and go to state 182


state 123

    (108) values -> value COMMA . values
    (107) values -> . value
    (108) values -> . value COMMA values
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    value                          shift and go to state 58
    values                         shift and go to state 183
    number                         shift and go to state 126
    string                         shift and go to state 127
    list                           shift and go to state 50

state 124

    (118) list -> LSQUARE RSQUARE .

    COMMA           reduce using rule 118 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 118 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 118 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 118 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 118 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 118 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 118 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LINE_BREAK      reduce using rule 118 (list -> LSQUARE RSQUARE .)
    PRINT           reduce using rule 118 (list -> LSQUARE RSQUARE .)
    IF              reduce using rule 118 (list -> LSQUARE RSQUARE .)
    WHILE           reduce using rule 118 (list -> LSQUARE RSQUARE .)
    FOR             reduce using rule 118 (list -> LSQUARE RSQUARE .)
    IDENTIFIER      reduce using rule 118 (list -> LSQUARE RSQUARE .)
    FINAL           reduce using rule 118 (list -> LSQUARE RSQUARE .)
    CONST           reduce using rule 118 (list -> LSQUARE RSQUARE .)
    INTEGER_TYPE    reduce using rule 118 (list -> LSQUARE RSQUARE .)
    DOUBLE_TYPE     reduce using rule 118 (list -> LSQUARE RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 118 (list -> LSQUARE RSQUARE .)
    QUEUE_TYPE      reduce using rule 118 (list -> LSQUARE RSQUARE .)
    STRING_TYPE     reduce using rule 118 (list -> LSQUARE RSQUARE .)
    ENUM_TYPE       reduce using rule 118 (list -> LSQUARE RSQUARE .)
    VAR             reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LIST_TYPE       reduce using rule 118 (list -> LSQUARE RSQUARE .)
    MAP_TYPE        reduce using rule 118 (list -> LSQUARE RSQUARE .)
    SET_TYPE        reduce using rule 118 (list -> LSQUARE RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 118 (list -> LSQUARE RSQUARE .)
    VOID            reduce using rule 118 (list -> LSQUARE RSQUARE .)
    RBRACE          reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LPAREN          reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LOGICAL_NOT     reduce using rule 118 (list -> LSQUARE RSQUARE .)
    TRUE            reduce using rule 118 (list -> LSQUARE RSQUARE .)
    FALSE           reduce using rule 118 (list -> LSQUARE RSQUARE .)
    INTEGER         reduce using rule 118 (list -> LSQUARE RSQUARE .)
    DOUBLE          reduce using rule 118 (list -> LSQUARE RSQUARE .)
    STRING          reduce using rule 118 (list -> LSQUARE RSQUARE .)
    LSQUARE         reduce using rule 118 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 118 (list -> LSQUARE RSQUARE .)


state 125

    (119) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 184


state 126

    (110) value -> number .

    COMMA           reduce using rule 110 (value -> number .)
    RSQUARE         reduce using rule 110 (value -> number .)
    RPAREN          reduce using rule 110 (value -> number .)
    EQUAL           reduce using rule 110 (value -> number .)
    NOT_EQUAL       reduce using rule 110 (value -> number .)
    LESS            reduce using rule 110 (value -> number .)
    LESS_EQUAL      reduce using rule 110 (value -> number .)
    GREATER         reduce using rule 110 (value -> number .)
    GREATER_EQUAL   reduce using rule 110 (value -> number .)
    LOGICAL_AND     reduce using rule 110 (value -> number .)
    LOGICAL_OR      reduce using rule 110 (value -> number .)
    $end            reduce using rule 110 (value -> number .)
    SEMICOLON       reduce using rule 110 (value -> number .)
    LINE_BREAK      reduce using rule 110 (value -> number .)
    PRINT           reduce using rule 110 (value -> number .)
    IF              reduce using rule 110 (value -> number .)
    WHILE           reduce using rule 110 (value -> number .)
    FOR             reduce using rule 110 (value -> number .)
    IDENTIFIER      reduce using rule 110 (value -> number .)
    FINAL           reduce using rule 110 (value -> number .)
    CONST           reduce using rule 110 (value -> number .)
    INTEGER_TYPE    reduce using rule 110 (value -> number .)
    DOUBLE_TYPE     reduce using rule 110 (value -> number .)
    BOOLEAN_TYPE    reduce using rule 110 (value -> number .)
    QUEUE_TYPE      reduce using rule 110 (value -> number .)
    STRING_TYPE     reduce using rule 110 (value -> number .)
    ENUM_TYPE       reduce using rule 110 (value -> number .)
    VAR             reduce using rule 110 (value -> number .)
    LIST_TYPE       reduce using rule 110 (value -> number .)
    MAP_TYPE        reduce using rule 110 (value -> number .)
    SET_TYPE        reduce using rule 110 (value -> number .)
    DYNAMIC_TYPE    reduce using rule 110 (value -> number .)
    VOID            reduce using rule 110 (value -> number .)
    RBRACE          reduce using rule 110 (value -> number .)
    LPAREN          reduce using rule 110 (value -> number .)
    LOGICAL_NOT     reduce using rule 110 (value -> number .)
    TRUE            reduce using rule 110 (value -> number .)
    FALSE           reduce using rule 110 (value -> number .)
    INTEGER         reduce using rule 110 (value -> number .)
    DOUBLE          reduce using rule 110 (value -> number .)
    STRING          reduce using rule 110 (value -> number .)
    LSQUARE         reduce using rule 110 (value -> number .)


state 127

    (111) value -> string .

    COMMA           reduce using rule 111 (value -> string .)
    RSQUARE         reduce using rule 111 (value -> string .)
    RPAREN          reduce using rule 111 (value -> string .)
    EQUAL           reduce using rule 111 (value -> string .)
    NOT_EQUAL       reduce using rule 111 (value -> string .)
    LESS            reduce using rule 111 (value -> string .)
    LESS_EQUAL      reduce using rule 111 (value -> string .)
    GREATER         reduce using rule 111 (value -> string .)
    GREATER_EQUAL   reduce using rule 111 (value -> string .)
    LOGICAL_AND     reduce using rule 111 (value -> string .)
    LOGICAL_OR      reduce using rule 111 (value -> string .)
    $end            reduce using rule 111 (value -> string .)
    SEMICOLON       reduce using rule 111 (value -> string .)
    LINE_BREAK      reduce using rule 111 (value -> string .)
    PRINT           reduce using rule 111 (value -> string .)
    IF              reduce using rule 111 (value -> string .)
    WHILE           reduce using rule 111 (value -> string .)
    FOR             reduce using rule 111 (value -> string .)
    IDENTIFIER      reduce using rule 111 (value -> string .)
    FINAL           reduce using rule 111 (value -> string .)
    CONST           reduce using rule 111 (value -> string .)
    INTEGER_TYPE    reduce using rule 111 (value -> string .)
    DOUBLE_TYPE     reduce using rule 111 (value -> string .)
    BOOLEAN_TYPE    reduce using rule 111 (value -> string .)
    QUEUE_TYPE      reduce using rule 111 (value -> string .)
    STRING_TYPE     reduce using rule 111 (value -> string .)
    ENUM_TYPE       reduce using rule 111 (value -> string .)
    VAR             reduce using rule 111 (value -> string .)
    LIST_TYPE       reduce using rule 111 (value -> string .)
    MAP_TYPE        reduce using rule 111 (value -> string .)
    SET_TYPE        reduce using rule 111 (value -> string .)
    DYNAMIC_TYPE    reduce using rule 111 (value -> string .)
    VOID            reduce using rule 111 (value -> string .)
    RBRACE          reduce using rule 111 (value -> string .)
    LPAREN          reduce using rule 111 (value -> string .)
    LOGICAL_NOT     reduce using rule 111 (value -> string .)
    TRUE            reduce using rule 111 (value -> string .)
    FALSE           reduce using rule 111 (value -> string .)
    INTEGER         reduce using rule 111 (value -> string .)
    DOUBLE          reduce using rule 111 (value -> string .)
    STRING          reduce using rule 111 (value -> string .)
    LSQUARE         reduce using rule 111 (value -> string .)


state 128

    (50) if_statement -> if_statement ELSE if_statement .
    (50) if_statement -> if_statement . ELSE if_statement
    (51) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    WHILE           reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    FOR             reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    IDENTIFIER      reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 50 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 62

  ! ELSE            [ reduce using rule 50 (if_statement -> if_statement ELSE if_statement .) ]


state 129

    (51) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 29
    RBRACE          reduce using rule 127 (lines -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    if_statement                   shift and go to state 67
    lines                          shift and go to state 185
    line                           shift and go to state 28
    print                          shift and go to state 64
    assignment                     shift and go to state 65
    function                       shift and go to state 66
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    reassignment                   shift and go to state 71
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 130

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 131

    (74) arithmetic -> arithmetic arith_op arithmetic .
    (74) arithmetic -> arithmetic . arith_op arithmetic
    (98) arith_op -> . PLUS
    (99) arith_op -> . MINUS
    (100) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    $end            reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    LINE_BREAK      reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    PRINT           reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    IF              reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    WHILE           reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    FOR             reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    IDENTIFIER      reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    FINAL           reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    CONST           reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER_TYPE    reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE_TYPE     reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    BOOLEAN_TYPE    reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    QUEUE_TYPE      reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING_TYPE     reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    ENUM_TYPE       reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    VAR             reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    LIST_TYPE       reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    MAP_TYPE        reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    SET_TYPE        reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    DYNAMIC_TYPE    reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    VOID            reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    RBRACE          reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    LPAREN          reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    LOGICAL_NOT     reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    TRUE            reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    FALSE           reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER         reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE          reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING          reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    LSQUARE         reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76

  ! PLUS            [ reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 73

state 132

    (73) arithmetic -> number .

    PLUS            reduce using rule 73 (arithmetic -> number .)
    MINUS           reduce using rule 73 (arithmetic -> number .)
    TIMES           reduce using rule 73 (arithmetic -> number .)
    $end            reduce using rule 73 (arithmetic -> number .)
    SEMICOLON       reduce using rule 73 (arithmetic -> number .)
    RPAREN          reduce using rule 73 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 73 (arithmetic -> number .)
    PRINT           reduce using rule 73 (arithmetic -> number .)
    IF              reduce using rule 73 (arithmetic -> number .)
    WHILE           reduce using rule 73 (arithmetic -> number .)
    FOR             reduce using rule 73 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 73 (arithmetic -> number .)
    FINAL           reduce using rule 73 (arithmetic -> number .)
    CONST           reduce using rule 73 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 73 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 73 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 73 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 73 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 73 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 73 (arithmetic -> number .)
    VAR             reduce using rule 73 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 73 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 73 (arithmetic -> number .)
    SET_TYPE        reduce using rule 73 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 73 (arithmetic -> number .)
    VOID            reduce using rule 73 (arithmetic -> number .)
    RBRACE          reduce using rule 73 (arithmetic -> number .)
    LPAREN          reduce using rule 73 (arithmetic -> number .)
    LOGICAL_NOT     reduce using rule 73 (arithmetic -> number .)
    TRUE            reduce using rule 73 (arithmetic -> number .)
    FALSE           reduce using rule 73 (arithmetic -> number .)
    INTEGER         reduce using rule 73 (arithmetic -> number .)
    DOUBLE          reduce using rule 73 (arithmetic -> number .)
    STRING          reduce using rule 73 (arithmetic -> number .)
    LSQUARE         reduce using rule 73 (arithmetic -> number .)


state 133

    (75) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (113) number -> . INTEGER
    (114) number -> . DOUBLE

    LPAREN          shift and go to state 133
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 93
    number                         shift and go to state 132

state 134

    (78) concate -> concate PLUS concate .
    (78) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    $end            reduce using rule 78 (concate -> concate PLUS concate .)
    SEMICOLON       reduce using rule 78 (concate -> concate PLUS concate .)
    RPAREN          reduce using rule 78 (concate -> concate PLUS concate .)
    LINE_BREAK      reduce using rule 78 (concate -> concate PLUS concate .)
    PRINT           reduce using rule 78 (concate -> concate PLUS concate .)
    IF              reduce using rule 78 (concate -> concate PLUS concate .)
    WHILE           reduce using rule 78 (concate -> concate PLUS concate .)
    FOR             reduce using rule 78 (concate -> concate PLUS concate .)
    IDENTIFIER      reduce using rule 78 (concate -> concate PLUS concate .)
    FINAL           reduce using rule 78 (concate -> concate PLUS concate .)
    CONST           reduce using rule 78 (concate -> concate PLUS concate .)
    INTEGER_TYPE    reduce using rule 78 (concate -> concate PLUS concate .)
    DOUBLE_TYPE     reduce using rule 78 (concate -> concate PLUS concate .)
    BOOLEAN_TYPE    reduce using rule 78 (concate -> concate PLUS concate .)
    QUEUE_TYPE      reduce using rule 78 (concate -> concate PLUS concate .)
    STRING_TYPE     reduce using rule 78 (concate -> concate PLUS concate .)
    ENUM_TYPE       reduce using rule 78 (concate -> concate PLUS concate .)
    VAR             reduce using rule 78 (concate -> concate PLUS concate .)
    LIST_TYPE       reduce using rule 78 (concate -> concate PLUS concate .)
    MAP_TYPE        reduce using rule 78 (concate -> concate PLUS concate .)
    SET_TYPE        reduce using rule 78 (concate -> concate PLUS concate .)
    DYNAMIC_TYPE    reduce using rule 78 (concate -> concate PLUS concate .)
    VOID            reduce using rule 78 (concate -> concate PLUS concate .)
    RBRACE          reduce using rule 78 (concate -> concate PLUS concate .)
    LPAREN          reduce using rule 78 (concate -> concate PLUS concate .)
    LOGICAL_NOT     reduce using rule 78 (concate -> concate PLUS concate .)
    TRUE            reduce using rule 78 (concate -> concate PLUS concate .)
    FALSE           reduce using rule 78 (concate -> concate PLUS concate .)
    INTEGER         reduce using rule 78 (concate -> concate PLUS concate .)
    DOUBLE          reduce using rule 78 (concate -> concate PLUS concate .)
    STRING          reduce using rule 78 (concate -> concate PLUS concate .)
    LSQUARE         reduce using rule 78 (concate -> concate PLUS concate .)
    PLUS            shift and go to state 77

  ! PLUS            [ reduce using rule 78 (concate -> concate PLUS concate .) ]


state 135

    (77) concate -> string .

    PLUS            reduce using rule 77 (concate -> string .)
    $end            reduce using rule 77 (concate -> string .)
    SEMICOLON       reduce using rule 77 (concate -> string .)
    RPAREN          reduce using rule 77 (concate -> string .)
    LINE_BREAK      reduce using rule 77 (concate -> string .)
    PRINT           reduce using rule 77 (concate -> string .)
    IF              reduce using rule 77 (concate -> string .)
    WHILE           reduce using rule 77 (concate -> string .)
    FOR             reduce using rule 77 (concate -> string .)
    IDENTIFIER      reduce using rule 77 (concate -> string .)
    FINAL           reduce using rule 77 (concate -> string .)
    CONST           reduce using rule 77 (concate -> string .)
    INTEGER_TYPE    reduce using rule 77 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 77 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 77 (concate -> string .)
    QUEUE_TYPE      reduce using rule 77 (concate -> string .)
    STRING_TYPE     reduce using rule 77 (concate -> string .)
    ENUM_TYPE       reduce using rule 77 (concate -> string .)
    VAR             reduce using rule 77 (concate -> string .)
    LIST_TYPE       reduce using rule 77 (concate -> string .)
    MAP_TYPE        reduce using rule 77 (concate -> string .)
    SET_TYPE        reduce using rule 77 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 77 (concate -> string .)
    VOID            reduce using rule 77 (concate -> string .)
    RBRACE          reduce using rule 77 (concate -> string .)
    LPAREN          reduce using rule 77 (concate -> string .)
    LOGICAL_NOT     reduce using rule 77 (concate -> string .)
    TRUE            reduce using rule 77 (concate -> string .)
    FALSE           reduce using rule 77 (concate -> string .)
    INTEGER         reduce using rule 77 (concate -> string .)
    DOUBLE          reduce using rule 77 (concate -> string .)
    STRING          reduce using rule 77 (concate -> string .)
    LSQUARE         reduce using rule 77 (concate -> string .)


state 136

    (79) concate -> LPAREN . concate PLUS concate RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (115) string -> . STRING

    LPAREN          shift and go to state 136
    STRING          shift and go to state 54

    concate                        shift and go to state 94
    string                         shift and go to state 135

state 137

    (93) logic -> logic logic_op logic .
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 93 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 93 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 93 (logic -> logic logic_op logic .)
    LINE_BREAK      reduce using rule 93 (logic -> logic logic_op logic .)
    PRINT           reduce using rule 93 (logic -> logic logic_op logic .)
    IF              reduce using rule 93 (logic -> logic logic_op logic .)
    WHILE           reduce using rule 93 (logic -> logic logic_op logic .)
    FOR             reduce using rule 93 (logic -> logic logic_op logic .)
    IDENTIFIER      reduce using rule 93 (logic -> logic logic_op logic .)
    FINAL           reduce using rule 93 (logic -> logic logic_op logic .)
    CONST           reduce using rule 93 (logic -> logic logic_op logic .)
    INTEGER_TYPE    reduce using rule 93 (logic -> logic logic_op logic .)
    DOUBLE_TYPE     reduce using rule 93 (logic -> logic logic_op logic .)
    BOOLEAN_TYPE    reduce using rule 93 (logic -> logic logic_op logic .)
    QUEUE_TYPE      reduce using rule 93 (logic -> logic logic_op logic .)
    STRING_TYPE     reduce using rule 93 (logic -> logic logic_op logic .)
    ENUM_TYPE       reduce using rule 93 (logic -> logic logic_op logic .)
    VAR             reduce using rule 93 (logic -> logic logic_op logic .)
    LIST_TYPE       reduce using rule 93 (logic -> logic logic_op logic .)
    MAP_TYPE        reduce using rule 93 (logic -> logic logic_op logic .)
    SET_TYPE        reduce using rule 93 (logic -> logic logic_op logic .)
    DYNAMIC_TYPE    reduce using rule 93 (logic -> logic logic_op logic .)
    VOID            reduce using rule 93 (logic -> logic logic_op logic .)
    RBRACE          reduce using rule 93 (logic -> logic logic_op logic .)
    LPAREN          reduce using rule 93 (logic -> logic logic_op logic .)
    LOGICAL_NOT     reduce using rule 93 (logic -> logic logic_op logic .)
    TRUE            reduce using rule 93 (logic -> logic logic_op logic .)
    FALSE           reduce using rule 93 (logic -> logic logic_op logic .)
    INTEGER         reduce using rule 93 (logic -> logic logic_op logic .)
    DOUBLE          reduce using rule 93 (logic -> logic logic_op logic .)
    STRING          reduce using rule 93 (logic -> logic logic_op logic .)
    LSQUARE         reduce using rule 93 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

  ! LOGICAL_AND     [ reduce using rule 93 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 93 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 78

state 138

    (12) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 186


state 139

    (14) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 187


state 140

    (29) string_assignment -> modifier type_string nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> modifier type_string nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 188


state 141

    (33) string_assignment -> modifier type_string IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 189


state 142

    (13) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 190


state 143

    (15) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN . expression
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 147
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    LSQUARE         shift and go to state 61

    expression                     shift and go to state 191
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 151
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 144

    (122) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (136) parameters -> . VOID
    (137) parameters -> . parameter
    (138) parameters -> . parameter COMMA parameters
    (139) parameters -> .
    (140) parameter -> . type IDENTIFIER
    (141) parameter -> . IDENTIFIER
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    VOID            shift and go to state 195
    RPAREN          reduce using rule 139 (parameters -> .)
    IDENTIFIER      shift and go to state 193
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47

    type                           shift and go to state 192
    parameters                     shift and go to state 194
    parameter                      shift and go to state 196

state 145

    (121) list_assigment -> type ASSIGN list . SEMICOLON

    SEMICOLON       shift and go to state 197


state 146

    (146) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN . LBRACE map_values RBRACE SEMICOLON

    LBRACE          shift and go to state 198


state 147

    (52) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (53) function_call -> IDENTIFIER . LPAREN values RPAREN
    (54) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (55) function_call -> IDENTIFIER . LPAREN RPAREN
    (109) value -> IDENTIFIER .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 91
    COMMA           reduce using rule 109 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 109 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 109 (value -> IDENTIFIER .)
    LESS            reduce using rule 109 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 109 (value -> IDENTIFIER .)
    GREATER         reduce using rule 109 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 109 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 109 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 109 (value -> IDENTIFIER .)
    $end            reduce using rule 109 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 109 (value -> IDENTIFIER .)
    PRINT           reduce using rule 109 (value -> IDENTIFIER .)
    IF              reduce using rule 109 (value -> IDENTIFIER .)
    WHILE           reduce using rule 109 (value -> IDENTIFIER .)
    FOR             reduce using rule 109 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 109 (value -> IDENTIFIER .)
    FINAL           reduce using rule 109 (value -> IDENTIFIER .)
    CONST           reduce using rule 109 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 109 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 109 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 109 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 109 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 109 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 109 (value -> IDENTIFIER .)
    VAR             reduce using rule 109 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 109 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 109 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 109 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 109 (value -> IDENTIFIER .)
    VOID            reduce using rule 109 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 109 (value -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 109 (value -> IDENTIFIER .)
    TRUE            reduce using rule 109 (value -> IDENTIFIER .)
    FALSE           reduce using rule 109 (value -> IDENTIFIER .)
    INTEGER         reduce using rule 109 (value -> IDENTIFIER .)
    DOUBLE          reduce using rule 109 (value -> IDENTIFIER .)
    STRING          reduce using rule 109 (value -> IDENTIFIER .)
    LSQUARE         reduce using rule 109 (value -> IDENTIFIER .)

  ! LPAREN          [ reduce using rule 109 (value -> IDENTIFIER .) ]


state 148

    (39) reassignment -> IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 199


state 149

    (120) list_assigment -> IDENTIFIER ASSIGN list . SEMICOLON
    (112) value -> list .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 200
    COMMA           reduce using rule 112 (value -> list .)
    EQUAL           reduce using rule 112 (value -> list .)
    NOT_EQUAL       reduce using rule 112 (value -> list .)
    LESS            reduce using rule 112 (value -> list .)
    LESS_EQUAL      reduce using rule 112 (value -> list .)
    GREATER         reduce using rule 112 (value -> list .)
    GREATER_EQUAL   reduce using rule 112 (value -> list .)
    LOGICAL_AND     reduce using rule 112 (value -> list .)
    LOGICAL_OR      reduce using rule 112 (value -> list .)

  ! SEMICOLON       [ reduce using rule 112 (value -> list .) ]


state 150

    (147) map_assigment -> IDENTIFIER ASSIGN LBRACE . RBRACE SEMICOLON

    RBRACE          shift and go to state 201


state 151

    (71) expression -> function_call .

    SEMICOLON       reduce using rule 71 (expression -> function_call .)
    RPAREN          reduce using rule 71 (expression -> function_call .)
    $end            reduce using rule 71 (expression -> function_call .)
    LINE_BREAK      reduce using rule 71 (expression -> function_call .)
    PRINT           reduce using rule 71 (expression -> function_call .)
    IF              reduce using rule 71 (expression -> function_call .)
    WHILE           reduce using rule 71 (expression -> function_call .)
    FOR             reduce using rule 71 (expression -> function_call .)
    IDENTIFIER      reduce using rule 71 (expression -> function_call .)
    FINAL           reduce using rule 71 (expression -> function_call .)
    CONST           reduce using rule 71 (expression -> function_call .)
    INTEGER_TYPE    reduce using rule 71 (expression -> function_call .)
    DOUBLE_TYPE     reduce using rule 71 (expression -> function_call .)
    BOOLEAN_TYPE    reduce using rule 71 (expression -> function_call .)
    QUEUE_TYPE      reduce using rule 71 (expression -> function_call .)
    STRING_TYPE     reduce using rule 71 (expression -> function_call .)
    ENUM_TYPE       reduce using rule 71 (expression -> function_call .)
    VAR             reduce using rule 71 (expression -> function_call .)
    LIST_TYPE       reduce using rule 71 (expression -> function_call .)
    MAP_TYPE        reduce using rule 71 (expression -> function_call .)
    SET_TYPE        reduce using rule 71 (expression -> function_call .)
    DYNAMIC_TYPE    reduce using rule 71 (expression -> function_call .)
    VOID            reduce using rule 71 (expression -> function_call .)
    RBRACE          reduce using rule 71 (expression -> function_call .)
    LPAREN          reduce using rule 71 (expression -> function_call .)
    LOGICAL_NOT     reduce using rule 71 (expression -> function_call .)
    TRUE            reduce using rule 71 (expression -> function_call .)
    FALSE           reduce using rule 71 (expression -> function_call .)
    INTEGER         reduce using rule 71 (expression -> function_call .)
    DOUBLE          reduce using rule 71 (expression -> function_call .)
    STRING          reduce using rule 71 (expression -> function_call .)
    LSQUARE         reduce using rule 71 (expression -> function_call .)


state 152

    (40) reassignment -> IDENTIFIER INLINE_ARITH number . SEMICOLON
    (42) reassignment -> IDENTIFIER INLINE_ARITH number .

    SEMICOLON       shift and go to state 202
    $end            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LINE_BREAK      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    PRINT           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IF              reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    WHILE           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FOR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IDENTIFIER      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FINAL           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    CONST           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    INTEGER_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DOUBLE_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    BOOLEAN_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    QUEUE_TYPE      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    STRING_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    ENUM_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VAR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LIST_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    MAP_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    SET_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DYNAMIC_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VOID            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RBRACE          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RPAREN          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH number .)


state 153

    (41) reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .

    $end            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LINE_BREAK      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    PRINT           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IF              reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    WHILE           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FOR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FINAL           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    CONST           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    INTEGER_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    QUEUE_TYPE      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    STRING_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    ENUM_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VAR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LIST_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    MAP_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    SET_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VOID            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RBRACE          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RPAREN          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)


state 154

    (52) function_call -> IDENTIFIER LPAREN values . RPAREN SEMICOLON
    (53) function_call -> IDENTIFIER LPAREN values . RPAREN

    RPAREN          shift and go to state 203


state 155

    (54) function_call -> IDENTIFIER LPAREN RPAREN . SEMICOLON
    (55) function_call -> IDENTIFIER LPAREN RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 204
    $end            reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LINE_BREAK      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FINAL           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONST           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE_TYPE     reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BOOLEAN_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    QUEUE_TYPE      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING_TYPE     reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ENUM_TYPE       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LIST_TYPE       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MAP_TYPE        reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SET_TYPE        reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DYNAMIC_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VOID            reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LPAREN          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LOGICAL_NOT     reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    TRUE            reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FALSE           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER         reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LSQUARE         reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN .) ]


state 156

    (47) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 205


state 157

    (48) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 206


state 158

    (75) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (74) arithmetic -> arithmetic arith_op . arithmetic
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (113) number -> . INTEGER
    (114) number -> . DOUBLE

    LPAREN          shift and go to state 133
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 207
    number                         shift and go to state 132

state 159

    (79) concate -> LPAREN concate PLUS . concate RPAREN
    (78) concate -> concate PLUS . concate
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (115) string -> . STRING

    LPAREN          shift and go to state 136
    STRING          shift and go to state 54

    concate                        shift and go to state 208
    string                         shift and go to state 135

state 160

    (94) logic -> LPAREN logic logic_op . logic RPAREN
    (93) logic -> logic logic_op . logic
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 116
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    logic                          shift and go to state 209
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    number                         shift and go to state 117
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 161

    (83) comparison -> LPAREN comparison comp_op . number comparison
    (82) comparison -> comparison comp_op . comparison
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    LPAREN          shift and go to state 174
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    comparison                     shift and go to state 173
    number                         shift and go to state 210
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 162

    (88) int_comparison -> LPAREN number comp_op . number RPAREN
    (87) int_comparison -> number comp_op . number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE

    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 211

state 163

    (91) string_comparison -> LPAREN string comp_op . string RPAREN
    (90) string_comparison -> string comp_op . string
    (115) string -> . STRING

    STRING          shift and go to state 54

    string                         shift and go to state 212

state 164

    (49) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 213
    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

    logic_op                       shift and go to state 78

state 165

    (156) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 214
    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

    logic_op                       shift and go to state 78

state 166

    (157) for_statement -> FOR LPAREN assignment . logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 116
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

    logic                          shift and go to state 215
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    number                         shift and go to state 117
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 167

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (121) list_assigment -> type . ASSIGN list SEMICOLON
    (44) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 216
    ASSIGN          shift and go to state 86
    QUESTION_MARK   shift and go to state 87

    nullable                       shift and go to state 84

state 168

    (120) list_assigment -> IDENTIFIER . ASSIGN list SEMICOLON
    (146) map_assigment -> IDENTIFIER . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON

    ASSIGN          shift and go to state 217
    IDENTIFIER      shift and go to state 88


state 169

    (123) lines -> line LINE_BREAK lines .

    $end            reduce using rule 123 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 123 (lines -> line LINE_BREAK lines .)


state 170

    (76) division -> number DIVIDE number .

    $end            reduce using rule 76 (division -> number DIVIDE number .)
    SEMICOLON       reduce using rule 76 (division -> number DIVIDE number .)
    RPAREN          reduce using rule 76 (division -> number DIVIDE number .)
    LINE_BREAK      reduce using rule 76 (division -> number DIVIDE number .)
    PRINT           reduce using rule 76 (division -> number DIVIDE number .)
    IF              reduce using rule 76 (division -> number DIVIDE number .)
    WHILE           reduce using rule 76 (division -> number DIVIDE number .)
    FOR             reduce using rule 76 (division -> number DIVIDE number .)
    IDENTIFIER      reduce using rule 76 (division -> number DIVIDE number .)
    FINAL           reduce using rule 76 (division -> number DIVIDE number .)
    CONST           reduce using rule 76 (division -> number DIVIDE number .)
    INTEGER_TYPE    reduce using rule 76 (division -> number DIVIDE number .)
    DOUBLE_TYPE     reduce using rule 76 (division -> number DIVIDE number .)
    BOOLEAN_TYPE    reduce using rule 76 (division -> number DIVIDE number .)
    QUEUE_TYPE      reduce using rule 76 (division -> number DIVIDE number .)
    STRING_TYPE     reduce using rule 76 (division -> number DIVIDE number .)
    ENUM_TYPE       reduce using rule 76 (division -> number DIVIDE number .)
    VAR             reduce using rule 76 (division -> number DIVIDE number .)
    LIST_TYPE       reduce using rule 76 (division -> number DIVIDE number .)
    MAP_TYPE        reduce using rule 76 (division -> number DIVIDE number .)
    SET_TYPE        reduce using rule 76 (division -> number DIVIDE number .)
    DYNAMIC_TYPE    reduce using rule 76 (division -> number DIVIDE number .)
    VOID            reduce using rule 76 (division -> number DIVIDE number .)
    RBRACE          reduce using rule 76 (division -> number DIVIDE number .)
    LPAREN          reduce using rule 76 (division -> number DIVIDE number .)
    LOGICAL_NOT     reduce using rule 76 (division -> number DIVIDE number .)
    TRUE            reduce using rule 76 (division -> number DIVIDE number .)
    FALSE           reduce using rule 76 (division -> number DIVIDE number .)
    INTEGER         reduce using rule 76 (division -> number DIVIDE number .)
    DOUBLE          reduce using rule 76 (division -> number DIVIDE number .)
    STRING          reduce using rule 76 (division -> number DIVIDE number .)
    LSQUARE         reduce using rule 76 (division -> number DIVIDE number .)


state 171

    (87) int_comparison -> number comp_op number .

    EQUAL           reduce using rule 87 (int_comparison -> number comp_op number .)
    NOT_EQUAL       reduce using rule 87 (int_comparison -> number comp_op number .)
    LESS            reduce using rule 87 (int_comparison -> number comp_op number .)
    LESS_EQUAL      reduce using rule 87 (int_comparison -> number comp_op number .)
    GREATER         reduce using rule 87 (int_comparison -> number comp_op number .)
    GREATER_EQUAL   reduce using rule 87 (int_comparison -> number comp_op number .)
    LOGICAL_AND     reduce using rule 87 (int_comparison -> number comp_op number .)
    LOGICAL_OR      reduce using rule 87 (int_comparison -> number comp_op number .)
    $end            reduce using rule 87 (int_comparison -> number comp_op number .)
    SEMICOLON       reduce using rule 87 (int_comparison -> number comp_op number .)
    RPAREN          reduce using rule 87 (int_comparison -> number comp_op number .)
    LINE_BREAK      reduce using rule 87 (int_comparison -> number comp_op number .)
    PRINT           reduce using rule 87 (int_comparison -> number comp_op number .)
    IF              reduce using rule 87 (int_comparison -> number comp_op number .)
    WHILE           reduce using rule 87 (int_comparison -> number comp_op number .)
    FOR             reduce using rule 87 (int_comparison -> number comp_op number .)
    IDENTIFIER      reduce using rule 87 (int_comparison -> number comp_op number .)
    FINAL           reduce using rule 87 (int_comparison -> number comp_op number .)
    CONST           reduce using rule 87 (int_comparison -> number comp_op number .)
    INTEGER_TYPE    reduce using rule 87 (int_comparison -> number comp_op number .)
    DOUBLE_TYPE     reduce using rule 87 (int_comparison -> number comp_op number .)
    BOOLEAN_TYPE    reduce using rule 87 (int_comparison -> number comp_op number .)
    QUEUE_TYPE      reduce using rule 87 (int_comparison -> number comp_op number .)
    STRING_TYPE     reduce using rule 87 (int_comparison -> number comp_op number .)
    ENUM_TYPE       reduce using rule 87 (int_comparison -> number comp_op number .)
    VAR             reduce using rule 87 (int_comparison -> number comp_op number .)
    LIST_TYPE       reduce using rule 87 (int_comparison -> number comp_op number .)
    MAP_TYPE        reduce using rule 87 (int_comparison -> number comp_op number .)
    SET_TYPE        reduce using rule 87 (int_comparison -> number comp_op number .)
    DYNAMIC_TYPE    reduce using rule 87 (int_comparison -> number comp_op number .)
    VOID            reduce using rule 87 (int_comparison -> number comp_op number .)
    RBRACE          reduce using rule 87 (int_comparison -> number comp_op number .)
    LPAREN          reduce using rule 87 (int_comparison -> number comp_op number .)
    LOGICAL_NOT     reduce using rule 87 (int_comparison -> number comp_op number .)
    TRUE            reduce using rule 87 (int_comparison -> number comp_op number .)
    FALSE           reduce using rule 87 (int_comparison -> number comp_op number .)
    INTEGER         reduce using rule 87 (int_comparison -> number comp_op number .)
    DOUBLE          reduce using rule 87 (int_comparison -> number comp_op number .)
    STRING          reduce using rule 87 (int_comparison -> number comp_op number .)
    LSQUARE         reduce using rule 87 (int_comparison -> number comp_op number .)


state 172

    (90) string_comparison -> string comp_op string .

    EQUAL           reduce using rule 90 (string_comparison -> string comp_op string .)
    NOT_EQUAL       reduce using rule 90 (string_comparison -> string comp_op string .)
    LESS            reduce using rule 90 (string_comparison -> string comp_op string .)
    LESS_EQUAL      reduce using rule 90 (string_comparison -> string comp_op string .)
    GREATER         reduce using rule 90 (string_comparison -> string comp_op string .)
    GREATER_EQUAL   reduce using rule 90 (string_comparison -> string comp_op string .)
    LOGICAL_AND     reduce using rule 90 (string_comparison -> string comp_op string .)
    LOGICAL_OR      reduce using rule 90 (string_comparison -> string comp_op string .)
    $end            reduce using rule 90 (string_comparison -> string comp_op string .)
    SEMICOLON       reduce using rule 90 (string_comparison -> string comp_op string .)
    RPAREN          reduce using rule 90 (string_comparison -> string comp_op string .)
    LINE_BREAK      reduce using rule 90 (string_comparison -> string comp_op string .)
    PRINT           reduce using rule 90 (string_comparison -> string comp_op string .)
    IF              reduce using rule 90 (string_comparison -> string comp_op string .)
    WHILE           reduce using rule 90 (string_comparison -> string comp_op string .)
    FOR             reduce using rule 90 (string_comparison -> string comp_op string .)
    IDENTIFIER      reduce using rule 90 (string_comparison -> string comp_op string .)
    FINAL           reduce using rule 90 (string_comparison -> string comp_op string .)
    CONST           reduce using rule 90 (string_comparison -> string comp_op string .)
    INTEGER_TYPE    reduce using rule 90 (string_comparison -> string comp_op string .)
    DOUBLE_TYPE     reduce using rule 90 (string_comparison -> string comp_op string .)
    BOOLEAN_TYPE    reduce using rule 90 (string_comparison -> string comp_op string .)
    QUEUE_TYPE      reduce using rule 90 (string_comparison -> string comp_op string .)
    STRING_TYPE     reduce using rule 90 (string_comparison -> string comp_op string .)
    ENUM_TYPE       reduce using rule 90 (string_comparison -> string comp_op string .)
    VAR             reduce using rule 90 (string_comparison -> string comp_op string .)
    LIST_TYPE       reduce using rule 90 (string_comparison -> string comp_op string .)
    MAP_TYPE        reduce using rule 90 (string_comparison -> string comp_op string .)
    SET_TYPE        reduce using rule 90 (string_comparison -> string comp_op string .)
    DYNAMIC_TYPE    reduce using rule 90 (string_comparison -> string comp_op string .)
    VOID            reduce using rule 90 (string_comparison -> string comp_op string .)
    RBRACE          reduce using rule 90 (string_comparison -> string comp_op string .)
    LPAREN          reduce using rule 90 (string_comparison -> string comp_op string .)
    LOGICAL_NOT     reduce using rule 90 (string_comparison -> string comp_op string .)
    TRUE            reduce using rule 90 (string_comparison -> string comp_op string .)
    FALSE           reduce using rule 90 (string_comparison -> string comp_op string .)
    INTEGER         reduce using rule 90 (string_comparison -> string comp_op string .)
    DOUBLE          reduce using rule 90 (string_comparison -> string comp_op string .)
    STRING          reduce using rule 90 (string_comparison -> string comp_op string .)
    LSQUARE         reduce using rule 90 (string_comparison -> string comp_op string .)


state 173

    (82) comparison -> comparison comp_op comparison .
    (82) comparison -> comparison . comp_op comparison
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 82 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 82 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 82 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 82 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 82 (comparison -> comparison comp_op comparison .)
    LINE_BREAK      reduce using rule 82 (comparison -> comparison comp_op comparison .)
    PRINT           reduce using rule 82 (comparison -> comparison comp_op comparison .)
    IF              reduce using rule 82 (comparison -> comparison comp_op comparison .)
    WHILE           reduce using rule 82 (comparison -> comparison comp_op comparison .)
    FOR             reduce using rule 82 (comparison -> comparison comp_op comparison .)
    IDENTIFIER      reduce using rule 82 (comparison -> comparison comp_op comparison .)
    FINAL           reduce using rule 82 (comparison -> comparison comp_op comparison .)
    CONST           reduce using rule 82 (comparison -> comparison comp_op comparison .)
    INTEGER_TYPE    reduce using rule 82 (comparison -> comparison comp_op comparison .)
    DOUBLE_TYPE     reduce using rule 82 (comparison -> comparison comp_op comparison .)
    BOOLEAN_TYPE    reduce using rule 82 (comparison -> comparison comp_op comparison .)
    QUEUE_TYPE      reduce using rule 82 (comparison -> comparison comp_op comparison .)
    STRING_TYPE     reduce using rule 82 (comparison -> comparison comp_op comparison .)
    ENUM_TYPE       reduce using rule 82 (comparison -> comparison comp_op comparison .)
    VAR             reduce using rule 82 (comparison -> comparison comp_op comparison .)
    LIST_TYPE       reduce using rule 82 (comparison -> comparison comp_op comparison .)
    MAP_TYPE        reduce using rule 82 (comparison -> comparison comp_op comparison .)
    SET_TYPE        reduce using rule 82 (comparison -> comparison comp_op comparison .)
    DYNAMIC_TYPE    reduce using rule 82 (comparison -> comparison comp_op comparison .)
    VOID            reduce using rule 82 (comparison -> comparison comp_op comparison .)
    RBRACE          reduce using rule 82 (comparison -> comparison comp_op comparison .)
    LPAREN          reduce using rule 82 (comparison -> comparison comp_op comparison .)
    LOGICAL_NOT     reduce using rule 82 (comparison -> comparison comp_op comparison .)
    TRUE            reduce using rule 82 (comparison -> comparison comp_op comparison .)
    FALSE           reduce using rule 82 (comparison -> comparison comp_op comparison .)
    INTEGER         reduce using rule 82 (comparison -> comparison comp_op comparison .)
    DOUBLE          reduce using rule 82 (comparison -> comparison comp_op comparison .)
    STRING          reduce using rule 82 (comparison -> comparison comp_op comparison .)
    LSQUARE         reduce using rule 82 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 82 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 82 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 82 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 82 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 82 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 82 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 114

state 174

    (83) comparison -> LPAREN . comparison comp_op number comparison
    (88) int_comparison -> LPAREN . number comp_op number RPAREN
    (91) string_comparison -> LPAREN . string comp_op string RPAREN
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 174
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    LSQUARE         shift and go to state 61

    comparison                     shift and go to state 218
    number                         shift and go to state 175
    string                         shift and go to state 176
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 175

    (88) int_comparison -> LPAREN number . comp_op number RPAREN
    (87) int_comparison -> number . comp_op number
    (110) value -> number .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    COMMA           reduce using rule 110 (value -> number .)
    LOGICAL_AND     reduce using rule 110 (value -> number .)
    LOGICAL_OR      reduce using rule 110 (value -> number .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 110 (value -> number .) ]
  ! NOT_EQUAL       [ reduce using rule 110 (value -> number .) ]
  ! LESS            [ reduce using rule 110 (value -> number .) ]
  ! LESS_EQUAL      [ reduce using rule 110 (value -> number .) ]
  ! GREATER         [ reduce using rule 110 (value -> number .) ]
  ! GREATER_EQUAL   [ reduce using rule 110 (value -> number .) ]

    comp_op                        shift and go to state 162

state 176

    (91) string_comparison -> LPAREN string . comp_op string RPAREN
    (90) string_comparison -> string . comp_op string
    (111) value -> string .
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    COMMA           reduce using rule 111 (value -> string .)
    LOGICAL_AND     reduce using rule 111 (value -> string .)
    LOGICAL_OR      reduce using rule 111 (value -> string .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 111 (value -> string .) ]
  ! NOT_EQUAL       [ reduce using rule 111 (value -> string .) ]
  ! LESS            [ reduce using rule 111 (value -> string .) ]
  ! LESS_EQUAL      [ reduce using rule 111 (value -> string .) ]
  ! GREATER         [ reduce using rule 111 (value -> string .) ]
  ! GREATER_EQUAL   [ reduce using rule 111 (value -> string .) ]

    comp_op                        shift and go to state 163

state 177

    (142) map -> MAP_TYPE LESS type . COMMA type GREATER

    COMMA           shift and go to state 219


state 178

    (60) type -> STRING_TYPE .

    COMMA           reduce using rule 60 (type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 60 (type -> STRING_TYPE .)
    COLON           reduce using rule 60 (type -> STRING_TYPE .)
    GREATER         reduce using rule 60 (type -> STRING_TYPE .)
    RBRACE          reduce using rule 60 (type -> STRING_TYPE .)


state 179

    (62) type -> VAR .

    COMMA           reduce using rule 62 (type -> VAR .)
    IDENTIFIER      reduce using rule 62 (type -> VAR .)
    COLON           reduce using rule 62 (type -> VAR .)
    GREATER         reduce using rule 62 (type -> VAR .)
    RBRACE          reduce using rule 62 (type -> VAR .)


state 180

    (27) string_assignment -> type_string IDENTIFIER ASSIGN . concate SEMICOLON
    (28) string_assignment -> type_string IDENTIFIER ASSIGN . concate
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (115) string -> . STRING

    LPAREN          shift and go to state 136
    STRING          shift and go to state 54

    concate                        shift and go to state 220
    string                         shift and go to state 135

state 181

    (30) string_assignment -> type_string nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (32) string_assignment -> type_string nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 221


state 182

    (144) map_assigment -> map IDENTIFIER ASSIGN . LBRACE RBRACE SEMICOLON
    (145) map_assigment -> map IDENTIFIER ASSIGN . LBRACE map_values RBRACE SEMICOLON

    LBRACE          shift and go to state 222


state 183

    (108) values -> value COMMA values .

    EQUAL           reduce using rule 108 (values -> value COMMA values .)
    NOT_EQUAL       reduce using rule 108 (values -> value COMMA values .)
    LESS            reduce using rule 108 (values -> value COMMA values .)
    LESS_EQUAL      reduce using rule 108 (values -> value COMMA values .)
    GREATER         reduce using rule 108 (values -> value COMMA values .)
    GREATER_EQUAL   reduce using rule 108 (values -> value COMMA values .)
    LOGICAL_AND     reduce using rule 108 (values -> value COMMA values .)
    LOGICAL_OR      reduce using rule 108 (values -> value COMMA values .)
    $end            reduce using rule 108 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 108 (values -> value COMMA values .)
    RPAREN          reduce using rule 108 (values -> value COMMA values .)
    LINE_BREAK      reduce using rule 108 (values -> value COMMA values .)
    PRINT           reduce using rule 108 (values -> value COMMA values .)
    IF              reduce using rule 108 (values -> value COMMA values .)
    WHILE           reduce using rule 108 (values -> value COMMA values .)
    FOR             reduce using rule 108 (values -> value COMMA values .)
    IDENTIFIER      reduce using rule 108 (values -> value COMMA values .)
    FINAL           reduce using rule 108 (values -> value COMMA values .)
    CONST           reduce using rule 108 (values -> value COMMA values .)
    INTEGER_TYPE    reduce using rule 108 (values -> value COMMA values .)
    DOUBLE_TYPE     reduce using rule 108 (values -> value COMMA values .)
    BOOLEAN_TYPE    reduce using rule 108 (values -> value COMMA values .)
    QUEUE_TYPE      reduce using rule 108 (values -> value COMMA values .)
    STRING_TYPE     reduce using rule 108 (values -> value COMMA values .)
    ENUM_TYPE       reduce using rule 108 (values -> value COMMA values .)
    VAR             reduce using rule 108 (values -> value COMMA values .)
    LIST_TYPE       reduce using rule 108 (values -> value COMMA values .)
    MAP_TYPE        reduce using rule 108 (values -> value COMMA values .)
    SET_TYPE        reduce using rule 108 (values -> value COMMA values .)
    DYNAMIC_TYPE    reduce using rule 108 (values -> value COMMA values .)
    VOID            reduce using rule 108 (values -> value COMMA values .)
    RBRACE          reduce using rule 108 (values -> value COMMA values .)
    LPAREN          reduce using rule 108 (values -> value COMMA values .)
    LOGICAL_NOT     reduce using rule 108 (values -> value COMMA values .)
    TRUE            reduce using rule 108 (values -> value COMMA values .)
    FALSE           reduce using rule 108 (values -> value COMMA values .)
    INTEGER         reduce using rule 108 (values -> value COMMA values .)
    DOUBLE          reduce using rule 108 (values -> value COMMA values .)
    STRING          reduce using rule 108 (values -> value COMMA values .)
    LSQUARE         reduce using rule 108 (values -> value COMMA values .)
    RSQUARE         reduce using rule 108 (values -> value COMMA values .)


state 184

    (119) list -> LSQUARE values RSQUARE .

    COMMA           reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LINE_BREAK      reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    PRINT           reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    IF              reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    WHILE           reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    FOR             reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    IDENTIFIER      reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    FINAL           reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    CONST           reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    INTEGER_TYPE    reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    DOUBLE_TYPE     reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    QUEUE_TYPE      reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    STRING_TYPE     reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    ENUM_TYPE       reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    VAR             reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LIST_TYPE       reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    MAP_TYPE        reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    SET_TYPE        reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    VOID            reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    RBRACE          reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LPAREN          reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LOGICAL_NOT     reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    TRUE            reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    FALSE           reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    INTEGER         reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    DOUBLE          reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    STRING          reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    LSQUARE         reduce using rule 119 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 119 (list -> LSQUARE values RSQUARE .)


state 185

    (51) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 223


state 186

    (12) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 224


state 187

    (14) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 147
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    LSQUARE         shift and go to state 61

    expression                     shift and go to state 225
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 151
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 188

    (29) string_assignment -> modifier type_string nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (31) string_assignment -> modifier type_string nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 226


state 189

    (33) string_assignment -> modifier type_string IDENTIFIER ASSIGN . concate SEMICOLON
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (115) string -> . STRING

    LPAREN          shift and go to state 136
    STRING          shift and go to state 54

    concate                        shift and go to state 227
    string                         shift and go to state 135

state 190

    (13) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 147
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    LSQUARE         shift and go to state 61

    expression                     shift and go to state 228
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 151
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 191

    (15) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN expression .

    SEMICOLON       shift and go to state 229
    $end            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LINE_BREAK      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    PRINT           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FINAL           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    BOOLEAN_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    QUEUE_TYPE      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    ENUM_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LIST_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    MAP_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    SET_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DYNAMIC_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VOID            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LOGICAL_NOT     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER         reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LSQUARE         reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)


state 192

    (140) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 230


state 193

    (141) parameter -> IDENTIFIER .

    COMMA           reduce using rule 141 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 141 (parameter -> IDENTIFIER .)


state 194

    (122) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 231


state 195

    (136) parameters -> VOID .
    (67) type -> VOID .

    RPAREN          reduce using rule 136 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 67 (type -> VOID .)


state 196

    (137) parameters -> parameter .
    (138) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 137 (parameters -> parameter .)
    COMMA           shift and go to state 232


state 197

    (121) list_assigment -> type ASSIGN list SEMICOLON .

    $end            reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    LINE_BREAK      reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    PRINT           reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    IF              reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    WHILE           reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    FOR             reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    IDENTIFIER      reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    FINAL           reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    CONST           reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    INTEGER_TYPE    reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    QUEUE_TYPE      reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    STRING_TYPE     reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    ENUM_TYPE       reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    VAR             reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    LIST_TYPE       reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    MAP_TYPE        reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    SET_TYPE        reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    VOID            reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    RBRACE          reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    LPAREN          reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    TRUE            reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    FALSE           reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    INTEGER         reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    DOUBLE          reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    STRING          reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)
    LSQUARE         reduce using rule 121 (list_assigment -> type ASSIGN list SEMICOLON .)


state 198

    (146) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE . map_values RBRACE SEMICOLON
    (148) map_values -> . type COLON type
    (149) map_values -> . type COLON type COMMA map_values
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    map_values                     shift and go to state 233
    type                           shift and go to state 234

state 199

    (39) reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 39 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 200

    (120) list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .

    $end            reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    LINE_BREAK      reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    PRINT           reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    IF              reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    WHILE           reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    FOR             reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    IDENTIFIER      reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    FINAL           reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    CONST           reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    INTEGER_TYPE    reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    QUEUE_TYPE      reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    STRING_TYPE     reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    ENUM_TYPE       reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    VAR             reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    LIST_TYPE       reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    MAP_TYPE        reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    SET_TYPE        reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    VOID            reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    RBRACE          reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    LPAREN          reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    LOGICAL_NOT     reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    TRUE            reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    FALSE           reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    INTEGER         reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    DOUBLE          reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    STRING          reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    LSQUARE         reduce using rule 120 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)


state 201

    (147) map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 235


state 202

    (40) reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .

    $end            reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LINE_BREAK      reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    PRINT           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IF              reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    WHILE           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FOR             reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FINAL           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    CONST           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    INTEGER_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    QUEUE_TYPE      reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    STRING_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    ENUM_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VAR             reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LIST_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    MAP_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    SET_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VOID            reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RBRACE          reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RPAREN          reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)


state 203

    (52) function_call -> IDENTIFIER LPAREN values RPAREN . SEMICOLON
    (53) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 236
    $end            reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LINE_BREAK      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PRINT           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    WHILE           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FINAL           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    QUEUE_TYPE      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    ENUM_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LIST_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    MAP_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SET_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DYNAMIC_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VOID            reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RBRACE          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RPAREN          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LPAREN          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_NOT     reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    TRUE            reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FALSE           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LSQUARE         reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! SEMICOLON       [ reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN .) ]


state 204

    (54) function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LSQUARE         reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)


state 205

    (47) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 237


state 206

    (48) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 48 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 207

    (75) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (74) arithmetic -> arithmetic arith_op arithmetic .
    (74) arithmetic -> arithmetic . arith_op arithmetic
    (98) arith_op -> . PLUS
    (99) arith_op -> . MINUS
    (100) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    RPAREN          shift and go to state 238
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    TIMES           shift and go to state 76

  ! PLUS            [ reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 74 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 73

state 208

    (79) concate -> LPAREN concate PLUS concate . RPAREN
    (78) concate -> concate PLUS concate .
    (78) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 239
    PLUS            shift and go to state 77

  ! PLUS            [ reduce using rule 78 (concate -> concate PLUS concate .) ]


state 209

    (94) logic -> LPAREN logic logic_op logic . RPAREN
    (93) logic -> logic logic_op logic .
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 240
    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

  ! LOGICAL_AND     [ reduce using rule 93 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 93 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 78

state 210

    (83) comparison -> LPAREN comparison comp_op number . comparison
    (87) int_comparison -> number . comp_op number
    (110) value -> number .
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    COMMA           reduce using rule 110 (value -> number .)
    LOGICAL_AND     reduce using rule 110 (value -> number .)
    LOGICAL_OR      reduce using rule 110 (value -> number .)
    LPAREN          shift and go to state 174
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENTIFIER      shift and go to state 99
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 61

  ! EQUAL           [ reduce using rule 110 (value -> number .) ]
  ! NOT_EQUAL       [ reduce using rule 110 (value -> number .) ]
  ! LESS            [ reduce using rule 110 (value -> number .) ]
  ! LESS_EQUAL      [ reduce using rule 110 (value -> number .) ]
  ! GREATER         [ reduce using rule 110 (value -> number .) ]
  ! GREATER_EQUAL   [ reduce using rule 110 (value -> number .) ]

    comparison                     shift and go to state 241
    comp_op                        shift and go to state 106
    number                         shift and go to state 117
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    string                         shift and go to state 118
    list                           shift and go to state 50

state 211

    (88) int_comparison -> LPAREN number comp_op number . RPAREN
    (87) int_comparison -> number comp_op number .

    RPAREN          shift and go to state 242
    EQUAL           reduce using rule 87 (int_comparison -> number comp_op number .)
    NOT_EQUAL       reduce using rule 87 (int_comparison -> number comp_op number .)
    LESS            reduce using rule 87 (int_comparison -> number comp_op number .)
    LESS_EQUAL      reduce using rule 87 (int_comparison -> number comp_op number .)
    GREATER         reduce using rule 87 (int_comparison -> number comp_op number .)
    GREATER_EQUAL   reduce using rule 87 (int_comparison -> number comp_op number .)
    LOGICAL_AND     reduce using rule 87 (int_comparison -> number comp_op number .)
    LOGICAL_OR      reduce using rule 87 (int_comparison -> number comp_op number .)


state 212

    (91) string_comparison -> LPAREN string comp_op string . RPAREN
    (90) string_comparison -> string comp_op string .

    RPAREN          shift and go to state 243
    EQUAL           reduce using rule 90 (string_comparison -> string comp_op string .)
    NOT_EQUAL       reduce using rule 90 (string_comparison -> string comp_op string .)
    LESS            reduce using rule 90 (string_comparison -> string comp_op string .)
    LESS_EQUAL      reduce using rule 90 (string_comparison -> string comp_op string .)
    GREATER         reduce using rule 90 (string_comparison -> string comp_op string .)
    GREATER_EQUAL   reduce using rule 90 (string_comparison -> string comp_op string .)
    LOGICAL_AND     reduce using rule 90 (string_comparison -> string comp_op string .)
    LOGICAL_OR      reduce using rule 90 (string_comparison -> string comp_op string .)


state 213

    (49) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 244


state 214

    (156) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 245


state 215

    (157) for_statement -> FOR LPAREN assignment logic . SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (93) logic -> logic . logic_op logic
    (96) logic_op -> . LOGICAL_AND
    (97) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 246
    LOGICAL_AND     shift and go to state 79
    LOGICAL_OR      shift and go to state 80

    logic_op                       shift and go to state 78

state 216

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 143


state 217

    (120) list_assigment -> IDENTIFIER ASSIGN . list SEMICOLON
    (147) map_assigment -> IDENTIFIER ASSIGN . LBRACE RBRACE SEMICOLON
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LBRACE          shift and go to state 150
    LSQUARE         shift and go to state 61

    list                           shift and go to state 247

state 218

    (83) comparison -> LPAREN comparison . comp_op number comparison
    (82) comparison -> comparison . comp_op comparison
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

    comp_op                        shift and go to state 161

state 219

    (142) map -> MAP_TYPE LESS type COMMA . type GREATER
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 248

state 220

    (27) string_assignment -> type_string IDENTIFIER ASSIGN concate . SEMICOLON
    (28) string_assignment -> type_string IDENTIFIER ASSIGN concate .
    (78) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 249
    $end            reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LINE_BREAK      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    PRINT           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    IF              reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    WHILE           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    FOR             reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    IDENTIFIER      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    FINAL           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    CONST           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    INTEGER_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    DOUBLE_TYPE     reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    BOOLEAN_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    QUEUE_TYPE      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    STRING_TYPE     reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    ENUM_TYPE       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    VAR             reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LIST_TYPE       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    MAP_TYPE        reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    SET_TYPE        reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    DYNAMIC_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    VOID            reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    RBRACE          reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LPAREN          reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LOGICAL_NOT     reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    TRUE            reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    FALSE           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    INTEGER         reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    DOUBLE          reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    STRING          reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LSQUARE         reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    PLUS            shift and go to state 77


state 221

    (30) string_assignment -> type_string nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (32) string_assignment -> type_string nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (115) string -> . STRING

    NULL            shift and go to state 250
    LPAREN          shift and go to state 136
    STRING          shift and go to state 54

    concate                        shift and go to state 251
    string                         shift and go to state 135

state 222

    (144) map_assigment -> map IDENTIFIER ASSIGN LBRACE . RBRACE SEMICOLON
    (145) map_assigment -> map IDENTIFIER ASSIGN LBRACE . map_values RBRACE SEMICOLON
    (148) map_values -> . type COLON type
    (149) map_values -> . type COLON type COMMA map_values
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    RBRACE          shift and go to state 252
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    map_values                     shift and go to state 253
    type                           shift and go to state 234

state 223

    (51) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    WHILE           reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FOR             reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 51 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 224

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 147
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    LSQUARE         shift and go to state 61

    expression                     shift and go to state 254
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 151
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 225

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 255


state 226

    (29) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (31) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (115) string -> . STRING

    NULL            shift and go to state 256
    LPAREN          shift and go to state 136
    STRING          shift and go to state 54

    concate                        shift and go to state 257
    string                         shift and go to state 135

state 227

    (33) string_assignment -> modifier type_string IDENTIFIER ASSIGN concate . SEMICOLON
    (78) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 258
    PLUS            shift and go to state 77


state 228

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 259


state 229

    (15) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 230

    (140) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 140 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 140 (parameter -> type IDENTIFIER .)


state 231

    (122) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 260


state 232

    (138) parameters -> parameter COMMA . parameters
    (136) parameters -> . VOID
    (137) parameters -> . parameter
    (138) parameters -> . parameter COMMA parameters
    (139) parameters -> .
    (140) parameter -> . type IDENTIFIER
    (141) parameter -> . IDENTIFIER
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    VOID            shift and go to state 195
    RPAREN          reduce using rule 139 (parameters -> .)
    IDENTIFIER      shift and go to state 193
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47

    parameter                      shift and go to state 196
    parameters                     shift and go to state 261
    type                           shift and go to state 192

state 233

    (146) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values . RBRACE SEMICOLON

    RBRACE          shift and go to state 262


state 234

    (148) map_values -> type . COLON type
    (149) map_values -> type . COLON type COMMA map_values

    COLON           shift and go to state 263


state 235

    (147) map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .

    $end            reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    PRINT           reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IF              reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    WHILE           reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FOR             reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FINAL           reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    CONST           reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VAR             reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VOID            reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    RBRACE          reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LPAREN          reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LOGICAL_NOT     reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    TRUE            reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FALSE           reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    INTEGER         reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    STRING          reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LSQUARE         reduce using rule 147 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)


state 236

    (52) function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    WHILE           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FINAL           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    CONST           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VOID            reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RBRACE          reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RPAREN          reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LPAREN          reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    TRUE            reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FALSE           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER         reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING          reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LSQUARE         reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)


state 237

    (47) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 47 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 238

    (75) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LINE_BREAK      reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    PRINT           reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IF              reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    WHILE           reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FOR             reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FINAL           reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    CONST           reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER_TYPE    reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE_TYPE     reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    QUEUE_TYPE      reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING_TYPE     reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    ENUM_TYPE       reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VAR             reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LIST_TYPE       reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MAP_TYPE        reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SET_TYPE        reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VOID            reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RBRACE          reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LPAREN          reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LOGICAL_NOT     reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TRUE            reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FALSE           reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER         reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE          reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING          reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LSQUARE         reduce using rule 75 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 239

    (79) concate -> LPAREN concate PLUS concate RPAREN .

    PLUS            reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    $end            reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    SEMICOLON       reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    RPAREN          reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    LINE_BREAK      reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    PRINT           reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    IF              reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    WHILE           reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    FOR             reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    IDENTIFIER      reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    FINAL           reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    CONST           reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    INTEGER_TYPE    reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    DOUBLE_TYPE     reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    BOOLEAN_TYPE    reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    QUEUE_TYPE      reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    STRING_TYPE     reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    ENUM_TYPE       reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    VAR             reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    LIST_TYPE       reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    MAP_TYPE        reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    SET_TYPE        reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    DYNAMIC_TYPE    reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    VOID            reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    RBRACE          reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    LPAREN          reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    LOGICAL_NOT     reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    TRUE            reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    FALSE           reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    INTEGER         reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    DOUBLE          reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    STRING          reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)
    LSQUARE         reduce using rule 79 (concate -> LPAREN concate PLUS concate RPAREN .)


state 240

    (94) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    LINE_BREAK      reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    PRINT           reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    IF              reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    WHILE           reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    FOR             reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    IDENTIFIER      reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    FINAL           reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    CONST           reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER_TYPE    reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE_TYPE     reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    QUEUE_TYPE      reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING_TYPE     reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    ENUM_TYPE       reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    VAR             reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    LIST_TYPE       reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    MAP_TYPE        reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    SET_TYPE        reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    VOID            reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    RBRACE          reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    LPAREN          reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_NOT     reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    TRUE            reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    FALSE           reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER         reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE          reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING          reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)
    LSQUARE         reduce using rule 94 (logic -> LPAREN logic logic_op logic RPAREN .)


state 241

    (83) comparison -> LPAREN comparison comp_op number comparison .
    (82) comparison -> comparison . comp_op comparison
    (101) comp_op -> . EQUAL
    (102) comp_op -> . NOT_EQUAL
    (103) comp_op -> . LESS
    (104) comp_op -> . LESS_EQUAL
    (105) comp_op -> . GREATER
    (106) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    LOGICAL_OR      reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    $end            reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    SEMICOLON       reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    RPAREN          reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    LINE_BREAK      reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    PRINT           reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    IF              reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    WHILE           reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    FOR             reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    IDENTIFIER      reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    FINAL           reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    CONST           reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    INTEGER_TYPE    reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    DOUBLE_TYPE     reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    BOOLEAN_TYPE    reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    QUEUE_TYPE      reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    STRING_TYPE     reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    ENUM_TYPE       reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    VAR             reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    LIST_TYPE       reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    MAP_TYPE        reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    SET_TYPE        reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    DYNAMIC_TYPE    reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    VOID            reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    RBRACE          reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    LPAREN          reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    LOGICAL_NOT     reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    TRUE            reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    FALSE           reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    INTEGER         reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    DOUBLE          reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    STRING          reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    LSQUARE         reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .)
    EQUAL           shift and go to state 107
    NOT_EQUAL       shift and go to state 108
    LESS            shift and go to state 109
    LESS_EQUAL      shift and go to state 110
    GREATER         shift and go to state 111
    GREATER_EQUAL   shift and go to state 112

  ! EQUAL           [ reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! LESS            [ reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! GREATER         [ reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 83 (comparison -> LPAREN comparison comp_op number comparison .) ]

    comp_op                        shift and go to state 114

state 242

    (88) int_comparison -> LPAREN number comp_op number RPAREN .

    EQUAL           reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    NOT_EQUAL       reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LESS            reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LESS_EQUAL      reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    GREATER         reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    GREATER_EQUAL   reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LOGICAL_AND     reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LOGICAL_OR      reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    $end            reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    SEMICOLON       reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    RPAREN          reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LINE_BREAK      reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    PRINT           reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    IF              reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    WHILE           reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    FOR             reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    IDENTIFIER      reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    FINAL           reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    CONST           reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    INTEGER_TYPE    reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    DOUBLE_TYPE     reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    BOOLEAN_TYPE    reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    QUEUE_TYPE      reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    STRING_TYPE     reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    ENUM_TYPE       reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    VAR             reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LIST_TYPE       reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    MAP_TYPE        reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    SET_TYPE        reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    DYNAMIC_TYPE    reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    VOID            reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    RBRACE          reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LPAREN          reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LOGICAL_NOT     reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    TRUE            reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    FALSE           reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    INTEGER         reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    DOUBLE          reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    STRING          reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LSQUARE         reduce using rule 88 (int_comparison -> LPAREN number comp_op number RPAREN .)


state 243

    (91) string_comparison -> LPAREN string comp_op string RPAREN .

    EQUAL           reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    NOT_EQUAL       reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LESS            reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LESS_EQUAL      reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    GREATER         reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    GREATER_EQUAL   reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LOGICAL_AND     reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LOGICAL_OR      reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    $end            reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    SEMICOLON       reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    RPAREN          reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LINE_BREAK      reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    PRINT           reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    IF              reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    WHILE           reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    FOR             reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    IDENTIFIER      reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    FINAL           reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    CONST           reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    INTEGER_TYPE    reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    DOUBLE_TYPE     reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    BOOLEAN_TYPE    reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    QUEUE_TYPE      reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    STRING_TYPE     reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    ENUM_TYPE       reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    VAR             reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LIST_TYPE       reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    MAP_TYPE        reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    SET_TYPE        reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    DYNAMIC_TYPE    reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    VOID            reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    RBRACE          reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LPAREN          reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LOGICAL_NOT     reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    TRUE            reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    FALSE           reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    INTEGER         reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    DOUBLE          reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    STRING          reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LSQUARE         reduce using rule 91 (string_comparison -> LPAREN string comp_op string RPAREN .)


state 244

    (49) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 29
    RBRACE          reduce using rule 127 (lines -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    lines                          shift and go to state 264
    line                           shift and go to state 28
    print                          shift and go to state 64
    assignment                     shift and go to state 65
    function                       shift and go to state 66
    if_statement                   shift and go to state 67
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    reassignment                   shift and go to state 71
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 245

    (156) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 29
    RBRACE          reduce using rule 127 (lines -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    lines                          shift and go to state 265
    line                           shift and go to state 28
    print                          shift and go to state 64
    assignment                     shift and go to state 65
    function                       shift and go to state 66
    if_statement                   shift and go to state 67
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    reassignment                   shift and go to state 71
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 246

    (157) for_statement -> FOR LPAREN assignment logic SEMICOLON . reassignment RPAREN LBRACE lines RBRACE
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH

    IDENTIFIER      shift and go to state 267

    reassignment                   shift and go to state 266

state 247

    (120) list_assigment -> IDENTIFIER ASSIGN list . SEMICOLON

    SEMICOLON       shift and go to state 200


state 248

    (142) map -> MAP_TYPE LESS type COMMA type . GREATER

    GREATER         shift and go to state 268


state 249

    (27) string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LPAREN          reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LOGICAL_NOT     reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    TRUE            reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FALSE           reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER         reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE          reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING          reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LSQUARE         reduce using rule 27 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)


state 250

    (30) string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 269


state 251

    (32) string_assignment -> type_string nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (78) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 270
    PLUS            shift and go to state 77


state 252

    (144) map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 271


state 253

    (145) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values . RBRACE SEMICOLON

    RBRACE          shift and go to state 272


state 254

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 273


state 255

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 256

    (29) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 274


state 257

    (31) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (78) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 275
    PLUS            shift and go to state 77


state 258

    (33) string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LPAREN          reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LOGICAL_NOT     reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    TRUE            reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FALSE           reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER         reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE          reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING          reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LSQUARE         reduce using rule 33 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)


state 259

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 260

    (122) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 29
    RBRACE          reduce using rule 127 (lines -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 18
    lines                          shift and go to state 276
    line                           shift and go to state 28
    print                          shift and go to state 64
    assignment                     shift and go to state 65
    function                       shift and go to state 66
    if_statement                   shift and go to state 67
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    reassignment                   shift and go to state 71
    modifier                       shift and go to state 17
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 261

    (138) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 138 (parameters -> parameter COMMA parameters .)


state 262

    (146) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 277


state 263

    (148) map_values -> type COLON . type
    (149) map_values -> type COLON . type COMMA map_values
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 278

state 264

    (49) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 279


state 265

    (156) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 280


state 266

    (157) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 281


state 267

    (39) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (40) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH number
    (43) reassignment -> IDENTIFIER . INLINE_ARITH

    ASSIGN          shift and go to state 282
    INLINE_ARITH    shift and go to state 90


state 268

    (142) map -> MAP_TYPE LESS type COMMA type GREATER .

    IDENTIFIER      reduce using rule 142 (map -> MAP_TYPE LESS type COMMA type GREATER .)


state 269

    (30) string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LPAREN          reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LOGICAL_NOT     reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    TRUE            reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FALSE           reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER         reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE          reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING          reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LSQUARE         reduce using rule 30 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 270

    (32) string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LPAREN          reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LOGICAL_NOT     reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    TRUE            reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FALSE           reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER         reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE          reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING          reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LSQUARE         reduce using rule 32 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 271

    (144) map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .

    $end            reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    PRINT           reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IF              reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    WHILE           reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FOR             reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FINAL           reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    CONST           reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VAR             reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VOID            reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    RBRACE          reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LPAREN          reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LOGICAL_NOT     reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    TRUE            reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FALSE           reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    INTEGER         reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    STRING          reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LSQUARE         reduce using rule 144 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)


state 272

    (145) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 283


state 273

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 274

    (29) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LPAREN          reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LOGICAL_NOT     reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    TRUE            reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FALSE           reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER         reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE          reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING          reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LSQUARE         reduce using rule 29 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 275

    (31) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LPAREN          reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LOGICAL_NOT     reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    TRUE            reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FALSE           reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER         reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE          reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING          reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LSQUARE         reduce using rule 31 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 276

    (122) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 284


state 277

    (146) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .

    $end            reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    PRINT           reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IF              reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    WHILE           reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FOR             reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FINAL           reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    CONST           reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VAR             reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VOID            reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    RBRACE          reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LPAREN          reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LOGICAL_NOT     reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    TRUE            reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FALSE           reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    INTEGER         reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    STRING          reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LSQUARE         reduce using rule 146 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)


state 278

    (148) map_values -> type COLON type .
    (149) map_values -> type COLON type . COMMA map_values

    RBRACE          reduce using rule 148 (map_values -> type COLON type .)
    COMMA           shift and go to state 285


state 279

    (49) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 49 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 280

    (156) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 156 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 281

    (157) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 286


state 282

    (39) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (68) expression -> . arithmetic
    (69) expression -> . concate
    (70) expression -> . logic
    (71) expression -> . function_call
    (72) expression -> . division
    (73) arithmetic -> . number
    (74) arithmetic -> . arithmetic arith_op arithmetic
    (75) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (77) concate -> . string
    (78) concate -> . concate PLUS concate
    (79) concate -> . LPAREN concate PLUS concate RPAREN
    (92) logic -> . comparison
    (93) logic -> . logic logic_op logic
    (94) logic -> . LPAREN logic logic_op logic RPAREN
    (95) logic -> . LOGICAL_NOT logic
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (76) division -> . number DIVIDE number
    (113) number -> . INTEGER
    (114) number -> . DOUBLE
    (115) string -> . STRING
    (80) comparison -> . values
    (81) comparison -> . boolean
    (82) comparison -> . comparison comp_op comparison
    (83) comparison -> . LPAREN comparison comp_op number comparison
    (84) comparison -> . int_comparison
    (85) comparison -> . string_comparison
    (107) values -> . value
    (108) values -> . value COMMA values
    (116) boolean -> . TRUE
    (117) boolean -> . FALSE
    (86) int_comparison -> . boolean
    (87) int_comparison -> . number comp_op number
    (88) int_comparison -> . LPAREN number comp_op number RPAREN
    (89) string_comparison -> . boolean
    (90) string_comparison -> . string comp_op string
    (91) string_comparison -> . LPAREN string comp_op string RPAREN
    (109) value -> . IDENTIFIER
    (110) value -> . number
    (111) value -> . string
    (112) value -> . list
    (118) list -> . LSQUARE RSQUARE
    (119) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 147
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    LSQUARE         shift and go to state 61

    expression                     shift and go to state 148
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 151
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    values                         shift and go to state 34
    boolean                        shift and go to state 55
    int_comparison                 shift and go to state 56
    string_comparison              shift and go to state 57
    value                          shift and go to state 58
    list                           shift and go to state 50

state 283

    (145) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .

    $end            reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    PRINT           reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IF              reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    WHILE           reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FOR             reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FINAL           reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    CONST           reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VAR             reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VOID            reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    RBRACE          reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LPAREN          reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LOGICAL_NOT     reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    TRUE            reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FALSE           reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    INTEGER         reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    STRING          reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LSQUARE         reduce using rule 145 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)


state 284

    (122) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 122 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 285

    (149) map_values -> type COLON type COMMA . map_values
    (148) map_values -> . type COLON type
    (149) map_values -> . type COLON type COMMA map_values
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID

    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 83
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 234
    map_values                     shift and go to state 287

state 286

    (157) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE . lines RBRACE
    (123) lines -> . line LINE_BREAK lines
    (124) lines -> . line lines
    (125) lines -> . line
    (126) lines -> . LINE_BREAK
    (127) lines -> .
    (128) line -> . print
    (129) line -> . assignment
    (130) line -> . function
    (131) line -> . if_statement
    (132) line -> . while_statement
    (133) line -> . for_statement
    (134) line -> . function_call
    (135) line -> . reassignment
    (47) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (48) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . string_assignment
    (18) assignment -> . list_assigment
    (19) assignment -> . map_assigment
    (122) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (49) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (50) if_statement -> . if_statement ELSE if_statement
    (51) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (156) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (157) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN
    (54) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (55) function_call -> . IDENTIFIER LPAREN RPAREN
    (39) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH number
    (43) reassignment -> . IDENTIFIER INLINE_ARITH
    (45) modifier -> . FINAL
    (46) modifier -> . CONST
    (56) type -> . INTEGER_TYPE
    (57) type -> . DOUBLE_TYPE
    (58) type -> . BOOLEAN_TYPE
    (59) type -> . QUEUE_TYPE
    (60) type -> . STRING_TYPE
    (61) type -> . ENUM_TYPE
    (62) type -> . VAR
    (63) type -> . LIST_TYPE
    (64) type -> . MAP_TYPE
    (65) type -> . SET_TYPE
    (66) type -> . DYNAMIC_TYPE
    (67) type -> . VOID
    (27) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (29) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (30) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (120) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (121) list_assigment -> . type ASSIGN list SEMICOLON
    (144) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (145) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (146) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (147) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (37) type_string -> . STRING_TYPE
    (38) type_string -> . VAR
    (142) map -> . MAP_TYPE LESS type COMMA type GREATER
    (143) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 29
    RBRACE          reduce using rule 127 (lines -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 72
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    assignment                     shift and go to state 65
    reassignment                   shift and go to state 71
    lines                          shift and go to state 288
    line                           shift and go to state 28
    print                          shift and go to state 64
    function                       shift and go to state 66
    if_statement                   shift and go to state 67
    while_statement                shift and go to state 68
    for_statement                  shift and go to state 69
    function_call                  shift and go to state 70
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    string_assignment              shift and go to state 20
    list_assigment                 shift and go to state 21
    map_assigment                  shift and go to state 22
    type_string                    shift and go to state 49
    map                            shift and go to state 51

state 287

    (149) map_values -> type COLON type COMMA map_values .

    RBRACE          reduce using rule 149 (map_values -> type COLON type COMMA map_values .)


state 288

    (157) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 289


state 289

    (157) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 157 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQUAL in state 30 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 30 resolved as shift
WARNING: shift/reduce conflict for LESS in state 30 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 30 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 30 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 30 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for LESS in state 31 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 31 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 97 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 97 resolved as shift
WARNING: shift/reduce conflict for LESS in state 97 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 97 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 97 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 97 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for LESS in state 98 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 98 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 115 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 115 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 118 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 128 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 131 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 131 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 137 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 137 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 147 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 149 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 155 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for LESS in state 173 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for LESS in state 175 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for LESS in state 176 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 176 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 203 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 207 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 207 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 207 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 208 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 209 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 209 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 210 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 210 resolved as shift
WARNING: shift/reduce conflict for LESS in state 210 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 210 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 210 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 210 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 241 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 241 resolved as shift
WARNING: shift/reduce conflict for LESS in state 241 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 241 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 241 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 241 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (statement -> while_statement)
WARNING: rejected rule (line -> while_statement) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (statement -> for_statement)
WARNING: rejected rule (line -> for_statement) in state 8
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> reassignment)
WARNING: rejected rule (line -> reassignment) in state 11
WARNING: reduce/reduce conflict in state 15 resolved using rule (expression -> function_call)
WARNING: rejected rule (line -> function_call) in state 15
WARNING: reduce/reduce conflict in state 28 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 28
WARNING: reduce/reduce conflict in state 30 resolved using rule (arithmetic -> number)
WARNING: rejected rule (value -> number) in state 30
WARNING: reduce/reduce conflict in state 31 resolved using rule (concate -> string)
WARNING: rejected rule (value -> string) in state 31
WARNING: reduce/reduce conflict in state 41 resolved using rule (type_string -> STRING_TYPE)
WARNING: rejected rule (type -> STRING_TYPE) in state 41
WARNING: reduce/reduce conflict in state 43 resolved using rule (type_string -> VAR)
WARNING: rejected rule (type -> VAR) in state 43
WARNING: reduce/reduce conflict in state 45 resolved using rule (type -> MAP_TYPE)
WARNING: rejected rule (map -> MAP_TYPE) in state 45
WARNING: reduce/reduce conflict in state 55 resolved using rule (comparison -> boolean)
WARNING: rejected rule (int_comparison -> boolean) in state 55
WARNING: reduce/reduce conflict in state 55 resolved using rule (comparison -> boolean)
WARNING: rejected rule (string_comparison -> boolean) in state 55
WARNING: reduce/reduce conflict in state 103 resolved using rule (lines -> LINE_BREAK)
WARNING: rejected rule (lines -> <empty>) in state 103
WARNING: Rule (map -> MAP_TYPE) is never reduced
WARNING: Rule (int_comparison -> boolean) is never reduced
WARNING: Rule (string_comparison -> boolean) is never reduced
