Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DO
    DOT
    ENUM
    EXTENDS
    FINALLY
    GET
    IMPLEMENTS
    IN
    NULL
    RETURN
    SET
    SWITCH
    THROW
    TRY
    TYPEDEF
    ZERO

Grammar

Rule 0     S' -> statement
Rule 1     statement -> concate
Rule 2     assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 3     assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 4     assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 5     assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 6     assignment -> type IDENTIFIER ASSIGN expression
Rule 7     reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 8     reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 9     reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 10    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 11    reassignment -> IDENTIFIER INLINE_ARITH
Rule 12    nullable -> QUESTION_MARK
Rule 13    modifier -> LATE
Rule 14    modifier -> FINAL
Rule 15    modifier -> CONST
Rule 16    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 17    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 18    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 19    if_statement -> if_statement ELSE if_statement
Rule 20    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 21    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 22    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 23    function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON
Rule 24    function_call -> IDENTIFIER LPAREN RPAREN
Rule 25    type -> INTEGER_TYPE
Rule 26    type -> DOUBLE_TYPE
Rule 27    type -> BOOLEAN_TYPE
Rule 28    type -> QUEUE_TYPE
Rule 29    type -> STRING_TYPE
Rule 30    type -> ENUM_TYPE
Rule 31    type -> VAR
Rule 32    type -> LIST_TYPE
Rule 33    type -> MAP_TYPE
Rule 34    type -> SET_TYPE
Rule 35    type -> DYNAMIC_TYPE
Rule 36    type -> VOID
Rule 37    expression -> arithmetic
Rule 38    expression -> concate
Rule 39    expression -> logic
Rule 40    expression -> function_call
Rule 41    expression -> division
Rule 42    arithmetic -> number
Rule 43    arithmetic -> arithmetic arith_op arithmetic
Rule 44    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 45    division -> number DIVIDE number
Rule 46    concate -> string PLUS string
Rule 47    comparison -> value
Rule 48    comparison -> boolean
Rule 49    comparison -> comparison comp_op comparison
Rule 50    comparison -> LPAREN comparison comp_op comparison RPAREN
Rule 51    logic -> comparison
Rule 52    logic -> logic logic_op logic
Rule 53    logic -> LPAREN logic logic_op logic RPAREN
Rule 54    logic -> LOGICAL_NOT logic
Rule 55    logic_op -> LOGICAL_AND
Rule 56    logic_op -> LOGICAL_OR
Rule 57    arith_op -> PLUS
Rule 58    arith_op -> MINUS
Rule 59    arith_op -> TIMES
Rule 60    comp_op -> EQUAL
Rule 61    comp_op -> NOT_EQUAL
Rule 62    comp_op -> LESS
Rule 63    comp_op -> LESS_EQUAL
Rule 64    comp_op -> GREATER
Rule 65    comp_op -> GREATER_EQUAL
Rule 66    values -> value
Rule 67    values -> value COMMA values
Rule 68    value -> IDENTIFIER
Rule 69    value -> number
Rule 70    value -> string
Rule 71    value -> list
Rule 72    number -> INTEGER
Rule 73    number -> DOUBLE
Rule 74    string -> STRING
Rule 75    boolean -> TRUE
Rule 76    boolean -> FALSE
Rule 77    list -> LSQUARE RSQUARE
Rule 78    list -> LSQUARE values RSQUARE
Rule 79    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 80    lines -> line LINE_BREAK lines
Rule 81    lines -> line lines
Rule 82    lines -> line
Rule 83    lines -> LINE_BREAK
Rule 84    lines -> <empty>
Rule 85    line -> print
Rule 86    line -> assignment
Rule 87    line -> function
Rule 88    line -> if_statement
Rule 89    line -> while_statement
Rule 90    line -> for_statement
Rule 91    line -> function_call
Rule 92    line -> reassignment
Rule 93    parameters -> VOID
Rule 94    parameters -> parameter
Rule 95    parameters -> parameter COMMA parameters
Rule 96    parameters -> <empty>
Rule 97    parameter -> type IDENTIFIER
Rule 98    parameter -> IDENTIFIER
Rule 99    map -> MAP_TYPE LESS type COMMA type GREATER
Rule 100   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE values RSQUARE
Rule 101   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE RSQUARE
Rule 102   set -> SET_TYPE LESS type GREATER
Rule 103   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 104   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 105   queue -> QUEUE_TYPE LESS type GREATER
Rule 106   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 107   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 108   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 109   for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
ASSIGN               : 2 3 4 5 6 7
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 27
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 67 95 99 100 101
COMMENT              : 
CONST                : 15
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 45
DO                   : 
DOT                  : 
DOUBLE               : 73
DOUBLE_TYPE          : 26
DYNAMIC_TYPE         : 35
ELSE                 : 19 20
ENUM                 : 
ENUM_TYPE            : 30
EQUAL                : 60
EXTENDS              : 
FALSE                : 76
FINAL                : 14
FINALLY              : 
FOR                  : 109
GET                  : 
GREATER              : 64 99 100 101 102 103 104 105 106 107
GREATER_EQUAL        : 65
IDENTIFIER           : 2 3 4 5 6 7 8 9 10 11 21 22 23 24 68 79 97 98
IF                   : 18
IMPLEMENTS           : 
IN                   : 
INLINE_ARITH         : 8 9 10 11
INTEGER              : 72
INTEGER_TYPE         : 25
LATE                 : 13
LBRACE               : 18 20 79 108 109
LESS                 : 62 99 100 101 102 103 104 105 106 107
LESS_EQUAL           : 63
LINE_BREAK           : 80 83
LIST_TYPE            : 32
LOGICAL_AND          : 55
LOGICAL_NOT          : 54
LOGICAL_OR           : 56
LPAREN               : 16 17 18 21 22 23 24 44 50 53 79 108 109
LSQUARE              : 77 78 100 101 103 104 106 107
MAP_TYPE             : 33 99 100 101
MINUS                : 58
NOT_EQUAL            : 61
NULL                 : 
PLUS                 : 46 57
PRINT                : 16 17
QUESTION_MARK        : 12
QUEUE_TYPE           : 28 105 106 107
RBRACE               : 18 20 79 108 109
RETURN               : 
RPAREN               : 16 17 18 21 22 23 24 44 50 53 79 108 109
RSQUARE              : 77 78 100 101 103 104 106 107
SEMICOLON            : 2 3 4 5 7 8 9 16 17 21 23 109 109
SET                  : 
SET_TYPE             : 34 102 103 104
STRING               : 74
STRING_TYPE          : 29
SWITCH               : 
THROW                : 
TIMES                : 59
TRUE                 : 75
TRY                  : 
TYPEDEF              : 
VAR                  : 31
VOID                 : 36 93
WHILE                : 108
ZERO                 : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 43 44
arithmetic           : 37 43 43 44 44
assignment           : 86 109
boolean              : 48
comp_op              : 49 50
comparison           : 49 49 50 50 51
concate              : 1 38
division             : 41
expression           : 2 3 4 5 6 7 16
for_statement        : 90
function             : 87
function_call        : 40 91
if_statement         : 19 19 20 88
line                 : 80 81 82
lines                : 18 20 79 80 81 108 109
list                 : 71
logic                : 18 39 52 52 53 53 54 108 109
logic_op             : 52 53
map                  : 
modifier             : 2 4
nullable             : 2 3
number               : 8 10 42 45 45 69
parameter            : 94 95
parameters           : 79 95
print                : 85
queue                : 
reassignment         : 92 109
set                  : 
statement            : 0
string               : 46 46 70
type                 : 2 3 4 5 6 79 97 99 99 100 100 101 101 102 103 104 105 106 107
value                : 47 66 67
values               : 21 22 67 78 100 103 106
while_statement      : 89

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . concate
    (46) concate -> . string PLUS string
    (74) string -> . STRING

    STRING          shift and go to state 4

    statement                      shift and go to state 1
    concate                        shift and go to state 2
    string                         shift and go to state 3

state 1

    (0) S' -> statement .



state 2

    (1) statement -> concate .

    $end            reduce using rule 1 (statement -> concate .)


state 3

    (46) concate -> string . PLUS string

    PLUS            shift and go to state 5


state 4

    (74) string -> STRING .

    PLUS            reduce using rule 74 (string -> STRING .)
    $end            reduce using rule 74 (string -> STRING .)


state 5

    (46) concate -> string PLUS . string
    (74) string -> . STRING

    STRING          shift and go to state 4

    string                         shift and go to state 6

state 6

    (46) concate -> string PLUS string .

    $end            reduce using rule 46 (concate -> string PLUS string .)

