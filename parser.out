Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COMMENT
    CONTINUE
    DEFAULT
    DO
    DOT
    ENUM
    EXTENDS
    FINALLY
    GET
    IMPLEMENTS
    IN
    RETURN
    SWITCH
    THROW
    TRY
    TYPEDEF
    ZERO

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> reassignment
Rule 11    statement -> <empty>
Rule 12    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 16    assignment -> type IDENTIFIER ASSIGN expression
Rule 17    assignment -> int_assignment
Rule 18    assignment -> string_assignment
Rule 19    assignment -> <empty>
Rule 20    assignment -> map_assigment
Rule 21    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 22    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic
Rule 23    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 24    int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 25    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 26    int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 27    int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 28    string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON
Rule 29    string_assignment -> type_string IDENTIFIER ASSIGN concate
Rule 30    string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 31    string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 32    string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 33    string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 34    string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
Rule 35    number_type -> INTEGER_TYPE
Rule 36    number_type -> VAR
Rule 37    number_type -> DOUBLE_TYPE
Rule 38    type_string -> STRING_TYPE
Rule 39    type_string -> VAR
Rule 40    reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 41    reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 42    reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 43    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 44    reassignment -> IDENTIFIER INLINE_ARITH
Rule 45    nullable -> QUESTION_MARK
Rule 46    modifier -> FINAL
Rule 47    modifier -> CONST
Rule 48    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 49    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 50    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 51    if_statement -> if_statement ELSE if_statement
Rule 52    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 53    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 54    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 55    function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON
Rule 56    function_call -> IDENTIFIER LPAREN RPAREN
Rule 57    type -> INTEGER_TYPE
Rule 58    type -> DOUBLE_TYPE
Rule 59    type -> BOOLEAN_TYPE
Rule 60    type -> QUEUE_TYPE
Rule 61    type -> STRING_TYPE
Rule 62    type -> ENUM_TYPE
Rule 63    type -> VAR
Rule 64    type -> LIST_TYPE
Rule 65    type -> MAP_TYPE
Rule 66    type -> SET_TYPE
Rule 67    type -> DYNAMIC_TYPE
Rule 68    type -> VOID
Rule 69    expression -> arithmetic
Rule 70    expression -> concate
Rule 71    expression -> logic
Rule 72    expression -> function_call
Rule 73    expression -> division
Rule 74    arithmetic -> number
Rule 75    arithmetic -> arithmetic arith_op arithmetic
Rule 76    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 77    division -> number DIVIDE number
Rule 78    concate -> string
Rule 79    concate -> concate PLUS concate
Rule 80    concate -> LPAREN concate PLUS concate RPAREN
Rule 81    comparison -> int_comparison
Rule 82    comparison -> string_comparison
Rule 83    int_comparison -> boolean
Rule 84    int_comparison -> number comp_op number
Rule 85    int_comparison -> LPAREN number comp_op number RPAREN
Rule 86    string_comparison -> boolean
Rule 87    string_comparison -> string comp_op string
Rule 88    string_comparison -> LPAREN string comp_op string RPAREN
Rule 89    logic -> comparison
Rule 90    logic -> logic logic_op logic
Rule 91    logic -> LPAREN logic logic_op logic RPAREN
Rule 92    logic -> LOGICAL_NOT logic
Rule 93    logic_op -> LOGICAL_AND
Rule 94    logic_op -> LOGICAL_OR
Rule 95    arith_op -> PLUS
Rule 96    arith_op -> MINUS
Rule 97    arith_op -> TIMES
Rule 98    comp_op -> EQUAL
Rule 99    comp_op -> NOT_EQUAL
Rule 100   comp_op -> LESS
Rule 101   comp_op -> LESS_EQUAL
Rule 102   comp_op -> GREATER
Rule 103   comp_op -> GREATER_EQUAL
Rule 104   values -> value
Rule 105   values -> value COMMA values
Rule 106   value -> IDENTIFIER
Rule 107   value -> number
Rule 108   value -> string
Rule 109   value -> list
Rule 110   number -> INTEGER
Rule 111   number -> DOUBLE
Rule 112   string -> STRING
Rule 113   boolean -> TRUE
Rule 114   boolean -> FALSE
Rule 115   list -> LSQUARE RSQUARE
Rule 116   list -> LSQUARE values RSQUARE
Rule 117   function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 118   lines -> line LINE_BREAK lines
Rule 119   lines -> line lines
Rule 120   lines -> line
Rule 121   lines -> LINE_BREAK
Rule 122   lines -> <empty>
Rule 123   line -> print
Rule 124   line -> assignment
Rule 125   line -> function
Rule 126   line -> if_statement
Rule 127   line -> while_statement
Rule 128   line -> for_statement
Rule 129   line -> function_call
Rule 130   line -> reassignment
Rule 131   parameters -> VOID
Rule 132   parameters -> parameter
Rule 133   parameters -> parameter COMMA parameters
Rule 134   parameters -> <empty>
Rule 135   parameter -> type IDENTIFIER
Rule 136   parameter -> IDENTIFIER
Rule 137   map -> MAP_TYPE LESS type COMMA type GREATER
Rule 138   map -> MAP_TYPE
Rule 139   map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
Rule 140   map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
Rule 141   map_values -> type COLON type
Rule 142   map_values -> type COLON type COMMA map_values
Rule 143   set -> SET_TYPE LESS type GREATER
Rule 144   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 145   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 146   queue -> QUEUE_TYPE LESS type GREATER
Rule 147   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 148   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 149   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 150   for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
ASSIGN               : 12 13 14 15 16 21 22 23 24 25 26 27 28 29 30 31 32 33 34 40 139 140
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 59
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 141 142
COMMA                : 105 133 137 142
COMMENT              : 
CONST                : 47
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 77
DO                   : 
DOT                  : 
DOUBLE               : 111
DOUBLE_TYPE          : 37 58
DYNAMIC_TYPE         : 67
ELSE                 : 51 52
ENUM                 : 
ENUM_TYPE            : 62
EQUAL                : 98
EXTENDS              : 
FALSE                : 114
FINAL                : 46
FINALLY              : 
FOR                  : 150
GET                  : 
GREATER              : 102 137 143 144 145 146 147 148
GREATER_EQUAL        : 103
IDENTIFIER           : 12 13 14 15 16 21 22 23 24 25 26 27 28 29 30 31 32 33 34 40 41 42 43 44 53 54 55 56 106 117 135 136 139 140
IF                   : 50
IMPLEMENTS           : 
IN                   : 
INLINE_ARITH         : 41 42 43 44
INTEGER              : 110
INTEGER_TYPE         : 35 57
LBRACE               : 9 50 52 117 139 140 149 150
LESS                 : 100 137 143 144 145 146 147 148
LESS_EQUAL           : 101
LINE_BREAK           : 118 121
LIST_TYPE            : 64
LOGICAL_AND          : 93
LOGICAL_NOT          : 92
LOGICAL_OR           : 94
LPAREN               : 48 49 50 53 54 55 56 76 80 85 88 91 117 149 150
LSQUARE              : 115 116 144 145 147 148
MAP_TYPE             : 65 137 138
MINUS                : 96
NOT_EQUAL            : 99
NULL                 : 23 24 30 31
PLUS                 : 79 80 95
PRINT                : 48 49
QUESTION_MARK        : 45
QUEUE_TYPE           : 60 146 147 148
RBRACE               : 9 50 52 117 139 140 149 150
RETURN               : 
RPAREN               : 48 49 50 53 54 55 56 76 80 85 88 91 117 149 150
RSQUARE              : 115 116 144 145 147 148
SEMICOLON            : 12 13 14 15 21 23 24 25 26 27 28 30 31 32 33 34 40 41 42 48 49 53 55 139 140 150 150
SET_TYPE             : 66 143 144 145
STRING               : 112
STRING_TYPE          : 38 61
SWITCH               : 
THROW                : 
TIMES                : 97
TRUE                 : 113
TRY                  : 
TYPEDEF              : 
VAR                  : 36 39 63
VOID                 : 68 131
WHILE                : 149
ZERO                 : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 75 76
arithmetic           : 21 22 25 26 27 69 75 75 76 76
assignment           : 2 124 150
boolean              : 83 86
comp_op              : 84 85 87 88
comparison           : 89
concate              : 28 29 32 33 34 70 79 79 80 80
division             : 73
expression           : 1 12 13 14 15 16 40 48
for_statement        : 7 128
function             : 4 125
function_call        : 72 129
if_statement         : 5 51 51 52 126
int_assignment       : 17
int_comparison       : 81
line                 : 118 119 120
lines                : 8 9 50 52 117 118 119 149 150
list                 : 109
logic                : 50 71 90 90 91 91 92 149 150
logic_op             : 90 91
map                  : 139 140
map_assigment        : 20
map_values           : 140 142
modifier             : 12 14 23 25 27 30 32 34
nullable             : 12 13 23 24 25 26 30 31 32 33
number               : 41 43 74 77 77 84 84 85 85 107
number_type          : 21 22 23 24 25 26 27
parameter            : 132 133
parameters           : 117 133
print                : 3 123
queue                : 
reassignment         : 10 130 150
set                  : 
statement            : 0
string               : 78 87 87 88 88 108
string_assignment    : 18
string_comparison    : 82
type                 : 12 13 14 15 16 117 135 137 137 141 141 142 142 143 144 145 146 147 148
type_string          : 28 29 30 31 32 33 34
value                : 104 105
values               : 53 54 105 116 144 147
while_statement      : 6 127

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> . reassignment
    (11) statement -> .
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LBRACE          shift and go to state 10
    $end            reduce using rule 11 (statement -> .)
    PRINT           shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    LINE_BREAK      shift and go to state 29
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

  ! $end            [ reduce using rule 19 (assignment -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]
  ! $end            [ reduce using rule 122 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    reassignment                   shift and go to state 11
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 15
    division                       shift and go to state 16
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    line                           shift and go to state 28
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (124) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 124 (line -> assignment .)
    PRINT           reduce using rule 124 (line -> assignment .)
    IF              reduce using rule 124 (line -> assignment .)
    WHILE           reduce using rule 124 (line -> assignment .)
    FOR             reduce using rule 124 (line -> assignment .)
    IDENTIFIER      reduce using rule 124 (line -> assignment .)
    FINAL           reduce using rule 124 (line -> assignment .)
    CONST           reduce using rule 124 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 124 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 124 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 124 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 124 (line -> assignment .)
    STRING_TYPE     reduce using rule 124 (line -> assignment .)
    ENUM_TYPE       reduce using rule 124 (line -> assignment .)
    VAR             reduce using rule 124 (line -> assignment .)
    LIST_TYPE       reduce using rule 124 (line -> assignment .)
    MAP_TYPE        reduce using rule 124 (line -> assignment .)
    SET_TYPE        reduce using rule 124 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 124 (line -> assignment .)
    VOID            reduce using rule 124 (line -> assignment .)

  ! $end            [ reduce using rule 124 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (123) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 123 (line -> print .)
    PRINT           reduce using rule 123 (line -> print .)
    IF              reduce using rule 123 (line -> print .)
    WHILE           reduce using rule 123 (line -> print .)
    FOR             reduce using rule 123 (line -> print .)
    IDENTIFIER      reduce using rule 123 (line -> print .)
    FINAL           reduce using rule 123 (line -> print .)
    CONST           reduce using rule 123 (line -> print .)
    INTEGER_TYPE    reduce using rule 123 (line -> print .)
    DOUBLE_TYPE     reduce using rule 123 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 123 (line -> print .)
    QUEUE_TYPE      reduce using rule 123 (line -> print .)
    STRING_TYPE     reduce using rule 123 (line -> print .)
    ENUM_TYPE       reduce using rule 123 (line -> print .)
    VAR             reduce using rule 123 (line -> print .)
    LIST_TYPE       reduce using rule 123 (line -> print .)
    MAP_TYPE        reduce using rule 123 (line -> print .)
    SET_TYPE        reduce using rule 123 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 123 (line -> print .)
    VOID            reduce using rule 123 (line -> print .)

  ! $end            [ reduce using rule 123 (line -> print .) ]


state 5

    (4) statement -> function .
    (125) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 125 (line -> function .)
    PRINT           reduce using rule 125 (line -> function .)
    IF              reduce using rule 125 (line -> function .)
    WHILE           reduce using rule 125 (line -> function .)
    FOR             reduce using rule 125 (line -> function .)
    IDENTIFIER      reduce using rule 125 (line -> function .)
    FINAL           reduce using rule 125 (line -> function .)
    CONST           reduce using rule 125 (line -> function .)
    INTEGER_TYPE    reduce using rule 125 (line -> function .)
    DOUBLE_TYPE     reduce using rule 125 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 125 (line -> function .)
    QUEUE_TYPE      reduce using rule 125 (line -> function .)
    STRING_TYPE     reduce using rule 125 (line -> function .)
    ENUM_TYPE       reduce using rule 125 (line -> function .)
    VAR             reduce using rule 125 (line -> function .)
    LIST_TYPE       reduce using rule 125 (line -> function .)
    MAP_TYPE        reduce using rule 125 (line -> function .)
    SET_TYPE        reduce using rule 125 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 125 (line -> function .)
    VOID            reduce using rule 125 (line -> function .)

  ! $end            [ reduce using rule 125 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (51) if_statement -> if_statement . ELSE if_statement
    (52) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (126) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 59
    LINE_BREAK      reduce using rule 126 (line -> if_statement .)
    PRINT           reduce using rule 126 (line -> if_statement .)
    IF              reduce using rule 126 (line -> if_statement .)
    WHILE           reduce using rule 126 (line -> if_statement .)
    FOR             reduce using rule 126 (line -> if_statement .)
    IDENTIFIER      reduce using rule 126 (line -> if_statement .)
    FINAL           reduce using rule 126 (line -> if_statement .)
    CONST           reduce using rule 126 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 126 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 126 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 126 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 126 (line -> if_statement .)
    STRING_TYPE     reduce using rule 126 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 126 (line -> if_statement .)
    VAR             reduce using rule 126 (line -> if_statement .)
    LIST_TYPE       reduce using rule 126 (line -> if_statement .)
    MAP_TYPE        reduce using rule 126 (line -> if_statement .)
    SET_TYPE        reduce using rule 126 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 126 (line -> if_statement .)
    VOID            reduce using rule 126 (line -> if_statement .)

  ! $end            [ reduce using rule 126 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .
    (127) line -> while_statement .

  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> while_statement .)
    $end            reduce using rule 6 (statement -> while_statement .)
    LINE_BREAK      reduce using rule 127 (line -> while_statement .)
    PRINT           reduce using rule 127 (line -> while_statement .)
    IF              reduce using rule 127 (line -> while_statement .)
    WHILE           reduce using rule 127 (line -> while_statement .)
    FOR             reduce using rule 127 (line -> while_statement .)
    IDENTIFIER      reduce using rule 127 (line -> while_statement .)
    FINAL           reduce using rule 127 (line -> while_statement .)
    CONST           reduce using rule 127 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 127 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 127 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 127 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 127 (line -> while_statement .)
    STRING_TYPE     reduce using rule 127 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 127 (line -> while_statement .)
    VAR             reduce using rule 127 (line -> while_statement .)
    LIST_TYPE       reduce using rule 127 (line -> while_statement .)
    MAP_TYPE        reduce using rule 127 (line -> while_statement .)
    SET_TYPE        reduce using rule 127 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 127 (line -> while_statement .)
    VOID            reduce using rule 127 (line -> while_statement .)

  ! $end            [ reduce using rule 127 (line -> while_statement .) ]


state 8

    (7) statement -> for_statement .
    (128) line -> for_statement .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    LINE_BREAK      reduce using rule 128 (line -> for_statement .)
    PRINT           reduce using rule 128 (line -> for_statement .)
    IF              reduce using rule 128 (line -> for_statement .)
    WHILE           reduce using rule 128 (line -> for_statement .)
    FOR             reduce using rule 128 (line -> for_statement .)
    IDENTIFIER      reduce using rule 128 (line -> for_statement .)
    FINAL           reduce using rule 128 (line -> for_statement .)
    CONST           reduce using rule 128 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 128 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 128 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 128 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 128 (line -> for_statement .)
    STRING_TYPE     reduce using rule 128 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 128 (line -> for_statement .)
    VAR             reduce using rule 128 (line -> for_statement .)
    LIST_TYPE       reduce using rule 128 (line -> for_statement .)
    MAP_TYPE        reduce using rule 128 (line -> for_statement .)
    SET_TYPE        reduce using rule 128 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 128 (line -> for_statement .)
    VOID            reduce using rule 128 (line -> for_statement .)

  ! $end            [ reduce using rule 128 (line -> for_statement .) ]


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    lines                          shift and go to state 60
    line                           shift and go to state 28
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 11

    (10) statement -> reassignment .
    (130) line -> reassignment .

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> reassignment .)
    $end            reduce using rule 10 (statement -> reassignment .)
    LINE_BREAK      reduce using rule 130 (line -> reassignment .)
    PRINT           reduce using rule 130 (line -> reassignment .)
    IF              reduce using rule 130 (line -> reassignment .)
    WHILE           reduce using rule 130 (line -> reassignment .)
    FOR             reduce using rule 130 (line -> reassignment .)
    IDENTIFIER      reduce using rule 130 (line -> reassignment .)
    FINAL           reduce using rule 130 (line -> reassignment .)
    CONST           reduce using rule 130 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 130 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 130 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 130 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 130 (line -> reassignment .)
    STRING_TYPE     reduce using rule 130 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 130 (line -> reassignment .)
    VAR             reduce using rule 130 (line -> reassignment .)
    LIST_TYPE       reduce using rule 130 (line -> reassignment .)
    MAP_TYPE        reduce using rule 130 (line -> reassignment .)
    SET_TYPE        reduce using rule 130 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 130 (line -> reassignment .)
    VOID            reduce using rule 130 (line -> reassignment .)

  ! $end            [ reduce using rule 130 (line -> reassignment .) ]


state 12

    (69) expression -> arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    $end            reduce using rule 69 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 69 (expression -> arithmetic .)
    RPAREN          reduce using rule 69 (expression -> arithmetic .)
    LINE_BREAK      reduce using rule 69 (expression -> arithmetic .)
    PRINT           reduce using rule 69 (expression -> arithmetic .)
    IF              reduce using rule 69 (expression -> arithmetic .)
    WHILE           reduce using rule 69 (expression -> arithmetic .)
    FOR             reduce using rule 69 (expression -> arithmetic .)
    IDENTIFIER      reduce using rule 69 (expression -> arithmetic .)
    FINAL           reduce using rule 69 (expression -> arithmetic .)
    CONST           reduce using rule 69 (expression -> arithmetic .)
    INTEGER_TYPE    reduce using rule 69 (expression -> arithmetic .)
    DOUBLE_TYPE     reduce using rule 69 (expression -> arithmetic .)
    BOOLEAN_TYPE    reduce using rule 69 (expression -> arithmetic .)
    QUEUE_TYPE      reduce using rule 69 (expression -> arithmetic .)
    STRING_TYPE     reduce using rule 69 (expression -> arithmetic .)
    ENUM_TYPE       reduce using rule 69 (expression -> arithmetic .)
    VAR             reduce using rule 69 (expression -> arithmetic .)
    LIST_TYPE       reduce using rule 69 (expression -> arithmetic .)
    MAP_TYPE        reduce using rule 69 (expression -> arithmetic .)
    SET_TYPE        reduce using rule 69 (expression -> arithmetic .)
    DYNAMIC_TYPE    reduce using rule 69 (expression -> arithmetic .)
    VOID            reduce using rule 69 (expression -> arithmetic .)
    RBRACE          reduce using rule 69 (expression -> arithmetic .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 13

    (70) expression -> concate .
    (79) concate -> concate . PLUS concate

    $end            reduce using rule 70 (expression -> concate .)
    SEMICOLON       reduce using rule 70 (expression -> concate .)
    RPAREN          reduce using rule 70 (expression -> concate .)
    LINE_BREAK      reduce using rule 70 (expression -> concate .)
    PRINT           reduce using rule 70 (expression -> concate .)
    IF              reduce using rule 70 (expression -> concate .)
    WHILE           reduce using rule 70 (expression -> concate .)
    FOR             reduce using rule 70 (expression -> concate .)
    IDENTIFIER      reduce using rule 70 (expression -> concate .)
    FINAL           reduce using rule 70 (expression -> concate .)
    CONST           reduce using rule 70 (expression -> concate .)
    INTEGER_TYPE    reduce using rule 70 (expression -> concate .)
    DOUBLE_TYPE     reduce using rule 70 (expression -> concate .)
    BOOLEAN_TYPE    reduce using rule 70 (expression -> concate .)
    QUEUE_TYPE      reduce using rule 70 (expression -> concate .)
    STRING_TYPE     reduce using rule 70 (expression -> concate .)
    ENUM_TYPE       reduce using rule 70 (expression -> concate .)
    VAR             reduce using rule 70 (expression -> concate .)
    LIST_TYPE       reduce using rule 70 (expression -> concate .)
    MAP_TYPE        reduce using rule 70 (expression -> concate .)
    SET_TYPE        reduce using rule 70 (expression -> concate .)
    DYNAMIC_TYPE    reduce using rule 70 (expression -> concate .)
    VOID            reduce using rule 70 (expression -> concate .)
    RBRACE          reduce using rule 70 (expression -> concate .)
    PLUS            shift and go to state 74


state 14

    (71) expression -> logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    $end            reduce using rule 71 (expression -> logic .)
    SEMICOLON       reduce using rule 71 (expression -> logic .)
    RPAREN          reduce using rule 71 (expression -> logic .)
    LINE_BREAK      reduce using rule 71 (expression -> logic .)
    PRINT           reduce using rule 71 (expression -> logic .)
    IF              reduce using rule 71 (expression -> logic .)
    WHILE           reduce using rule 71 (expression -> logic .)
    FOR             reduce using rule 71 (expression -> logic .)
    IDENTIFIER      reduce using rule 71 (expression -> logic .)
    FINAL           reduce using rule 71 (expression -> logic .)
    CONST           reduce using rule 71 (expression -> logic .)
    INTEGER_TYPE    reduce using rule 71 (expression -> logic .)
    DOUBLE_TYPE     reduce using rule 71 (expression -> logic .)
    BOOLEAN_TYPE    reduce using rule 71 (expression -> logic .)
    QUEUE_TYPE      reduce using rule 71 (expression -> logic .)
    STRING_TYPE     reduce using rule 71 (expression -> logic .)
    ENUM_TYPE       reduce using rule 71 (expression -> logic .)
    VAR             reduce using rule 71 (expression -> logic .)
    LIST_TYPE       reduce using rule 71 (expression -> logic .)
    MAP_TYPE        reduce using rule 71 (expression -> logic .)
    SET_TYPE        reduce using rule 71 (expression -> logic .)
    DYNAMIC_TYPE    reduce using rule 71 (expression -> logic .)
    VOID            reduce using rule 71 (expression -> logic .)
    RBRACE          reduce using rule 71 (expression -> logic .)
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 15

    (72) expression -> function_call .
    (129) line -> function_call .

  ! reduce/reduce conflict for $end resolved using rule 72 (expression -> function_call .)
    $end            reduce using rule 72 (expression -> function_call .)
    LINE_BREAK      reduce using rule 129 (line -> function_call .)
    PRINT           reduce using rule 129 (line -> function_call .)
    IF              reduce using rule 129 (line -> function_call .)
    WHILE           reduce using rule 129 (line -> function_call .)
    FOR             reduce using rule 129 (line -> function_call .)
    IDENTIFIER      reduce using rule 129 (line -> function_call .)
    FINAL           reduce using rule 129 (line -> function_call .)
    CONST           reduce using rule 129 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 129 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 129 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 129 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 129 (line -> function_call .)
    STRING_TYPE     reduce using rule 129 (line -> function_call .)
    ENUM_TYPE       reduce using rule 129 (line -> function_call .)
    VAR             reduce using rule 129 (line -> function_call .)
    LIST_TYPE       reduce using rule 129 (line -> function_call .)
    MAP_TYPE        reduce using rule 129 (line -> function_call .)
    SET_TYPE        reduce using rule 129 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 129 (line -> function_call .)
    VOID            reduce using rule 129 (line -> function_call .)

  ! $end            [ reduce using rule 129 (line -> function_call .) ]


state 16

    (73) expression -> division .

    $end            reduce using rule 73 (expression -> division .)
    SEMICOLON       reduce using rule 73 (expression -> division .)
    RPAREN          reduce using rule 73 (expression -> division .)
    LINE_BREAK      reduce using rule 73 (expression -> division .)
    PRINT           reduce using rule 73 (expression -> division .)
    IF              reduce using rule 73 (expression -> division .)
    WHILE           reduce using rule 73 (expression -> division .)
    FOR             reduce using rule 73 (expression -> division .)
    IDENTIFIER      reduce using rule 73 (expression -> division .)
    FINAL           reduce using rule 73 (expression -> division .)
    CONST           reduce using rule 73 (expression -> division .)
    INTEGER_TYPE    reduce using rule 73 (expression -> division .)
    DOUBLE_TYPE     reduce using rule 73 (expression -> division .)
    BOOLEAN_TYPE    reduce using rule 73 (expression -> division .)
    QUEUE_TYPE      reduce using rule 73 (expression -> division .)
    STRING_TYPE     reduce using rule 73 (expression -> division .)
    ENUM_TYPE       reduce using rule 73 (expression -> division .)
    VAR             reduce using rule 73 (expression -> division .)
    LIST_TYPE       reduce using rule 73 (expression -> division .)
    MAP_TYPE        reduce using rule 73 (expression -> division .)
    SET_TYPE        reduce using rule 73 (expression -> division .)
    DYNAMIC_TYPE    reduce using rule 73 (expression -> division .)
    VOID            reduce using rule 73 (expression -> division .)
    RBRACE          reduce using rule 73 (expression -> division .)


state 17

    (12) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (23) int_assignment -> modifier . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> modifier . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (30) string_assignment -> modifier . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> modifier . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR

    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    type                           shift and go to state 78
    number_type                    shift and go to state 79
    type_string                    shift and go to state 80

state 18

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (117) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 83
    QUESTION_MARK   shift and go to state 84

    nullable                       shift and go to state 82

state 19

    (40) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (43) reassignment -> IDENTIFIER . INLINE_ARITH number
    (44) reassignment -> IDENTIFIER . INLINE_ARITH
    (53) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN values RPAREN
    (55) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER . LPAREN RPAREN

    ASSIGN          shift and go to state 85
    INLINE_ARITH    shift and go to state 86
    LPAREN          shift and go to state 87


state 20

    (17) assignment -> int_assignment .

    $end            reduce using rule 17 (assignment -> int_assignment .)
    LINE_BREAK      reduce using rule 17 (assignment -> int_assignment .)
    PRINT           reduce using rule 17 (assignment -> int_assignment .)
    IF              reduce using rule 17 (assignment -> int_assignment .)
    WHILE           reduce using rule 17 (assignment -> int_assignment .)
    FOR             reduce using rule 17 (assignment -> int_assignment .)
    IDENTIFIER      reduce using rule 17 (assignment -> int_assignment .)
    FINAL           reduce using rule 17 (assignment -> int_assignment .)
    CONST           reduce using rule 17 (assignment -> int_assignment .)
    INTEGER_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    DOUBLE_TYPE     reduce using rule 17 (assignment -> int_assignment .)
    BOOLEAN_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    QUEUE_TYPE      reduce using rule 17 (assignment -> int_assignment .)
    STRING_TYPE     reduce using rule 17 (assignment -> int_assignment .)
    ENUM_TYPE       reduce using rule 17 (assignment -> int_assignment .)
    VAR             reduce using rule 17 (assignment -> int_assignment .)
    LIST_TYPE       reduce using rule 17 (assignment -> int_assignment .)
    MAP_TYPE        reduce using rule 17 (assignment -> int_assignment .)
    SET_TYPE        reduce using rule 17 (assignment -> int_assignment .)
    DYNAMIC_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    VOID            reduce using rule 17 (assignment -> int_assignment .)
    RBRACE          reduce using rule 17 (assignment -> int_assignment .)
    SEMICOLON       reduce using rule 17 (assignment -> int_assignment .)


state 21

    (18) assignment -> string_assignment .

    $end            reduce using rule 18 (assignment -> string_assignment .)
    LINE_BREAK      reduce using rule 18 (assignment -> string_assignment .)
    PRINT           reduce using rule 18 (assignment -> string_assignment .)
    IF              reduce using rule 18 (assignment -> string_assignment .)
    WHILE           reduce using rule 18 (assignment -> string_assignment .)
    FOR             reduce using rule 18 (assignment -> string_assignment .)
    IDENTIFIER      reduce using rule 18 (assignment -> string_assignment .)
    FINAL           reduce using rule 18 (assignment -> string_assignment .)
    CONST           reduce using rule 18 (assignment -> string_assignment .)
    INTEGER_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    DOUBLE_TYPE     reduce using rule 18 (assignment -> string_assignment .)
    BOOLEAN_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    QUEUE_TYPE      reduce using rule 18 (assignment -> string_assignment .)
    STRING_TYPE     reduce using rule 18 (assignment -> string_assignment .)
    ENUM_TYPE       reduce using rule 18 (assignment -> string_assignment .)
    VAR             reduce using rule 18 (assignment -> string_assignment .)
    LIST_TYPE       reduce using rule 18 (assignment -> string_assignment .)
    MAP_TYPE        reduce using rule 18 (assignment -> string_assignment .)
    SET_TYPE        reduce using rule 18 (assignment -> string_assignment .)
    DYNAMIC_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    VOID            reduce using rule 18 (assignment -> string_assignment .)
    RBRACE          reduce using rule 18 (assignment -> string_assignment .)
    SEMICOLON       reduce using rule 18 (assignment -> string_assignment .)


state 22

    (20) assignment -> map_assigment .

    $end            reduce using rule 20 (assignment -> map_assigment .)
    LINE_BREAK      reduce using rule 20 (assignment -> map_assigment .)
    PRINT           reduce using rule 20 (assignment -> map_assigment .)
    IF              reduce using rule 20 (assignment -> map_assigment .)
    WHILE           reduce using rule 20 (assignment -> map_assigment .)
    FOR             reduce using rule 20 (assignment -> map_assigment .)
    IDENTIFIER      reduce using rule 20 (assignment -> map_assigment .)
    FINAL           reduce using rule 20 (assignment -> map_assigment .)
    CONST           reduce using rule 20 (assignment -> map_assigment .)
    INTEGER_TYPE    reduce using rule 20 (assignment -> map_assigment .)
    DOUBLE_TYPE     reduce using rule 20 (assignment -> map_assigment .)
    BOOLEAN_TYPE    reduce using rule 20 (assignment -> map_assigment .)
    QUEUE_TYPE      reduce using rule 20 (assignment -> map_assigment .)
    STRING_TYPE     reduce using rule 20 (assignment -> map_assigment .)
    ENUM_TYPE       reduce using rule 20 (assignment -> map_assigment .)
    VAR             reduce using rule 20 (assignment -> map_assigment .)
    LIST_TYPE       reduce using rule 20 (assignment -> map_assigment .)
    MAP_TYPE        reduce using rule 20 (assignment -> map_assigment .)
    SET_TYPE        reduce using rule 20 (assignment -> map_assigment .)
    DYNAMIC_TYPE    reduce using rule 20 (assignment -> map_assigment .)
    VOID            reduce using rule 20 (assignment -> map_assigment .)
    RBRACE          reduce using rule 20 (assignment -> map_assigment .)
    SEMICOLON       reduce using rule 20 (assignment -> map_assigment .)


state 23

    (48) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (49) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 88


state 24

    (76) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (80) concate -> LPAREN . concate PLUS concate RPAREN
    (91) logic -> LPAREN . logic logic_op logic RPAREN
    (85) int_comparison -> LPAREN . number comp_op number RPAREN
    (88) string_comparison -> LPAREN . string comp_op string RPAREN
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    arithmetic                     shift and go to state 89
    concate                        shift and go to state 90
    logic                          shift and go to state 91
    number                         shift and go to state 92
    string                         shift and go to state 93
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 25

    (50) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 94


state 26

    (149) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 95


state 27

    (150) for_statement -> FOR . LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 96


state 28

    (118) lines -> line . LINE_BREAK lines
    (119) lines -> line . lines
    (120) lines -> line .
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! reduce/reduce conflict for $end resolved using rule 120 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 120 (lines -> line .)
  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 19 (assignment -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 97
    PRINT           shift and go to state 23
    $end            reduce using rule 19 (assignment -> .)
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! $end            [ reduce using rule 120 (lines -> line .) ]
  ! RBRACE          [ reduce using rule 120 (lines -> line .) ]
  ! $end            [ reduce using rule 122 (lines -> .) ]
  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    line                           shift and go to state 28
    lines                          shift and go to state 98
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 29

    (121) lines -> LINE_BREAK .

    $end            reduce using rule 121 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 121 (lines -> LINE_BREAK .)


state 30

    (74) arithmetic -> number .
    (77) division -> number . DIVIDE number
    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 74 (arithmetic -> number .)
    MINUS           reduce using rule 74 (arithmetic -> number .)
    TIMES           reduce using rule 74 (arithmetic -> number .)
    $end            reduce using rule 74 (arithmetic -> number .)
    SEMICOLON       reduce using rule 74 (arithmetic -> number .)
    RPAREN          reduce using rule 74 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 74 (arithmetic -> number .)
    PRINT           reduce using rule 74 (arithmetic -> number .)
    IF              reduce using rule 74 (arithmetic -> number .)
    WHILE           reduce using rule 74 (arithmetic -> number .)
    FOR             reduce using rule 74 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 74 (arithmetic -> number .)
    FINAL           reduce using rule 74 (arithmetic -> number .)
    CONST           reduce using rule 74 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 74 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 74 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 74 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 74 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 74 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 74 (arithmetic -> number .)
    VAR             reduce using rule 74 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 74 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 74 (arithmetic -> number .)
    SET_TYPE        reduce using rule 74 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 74 (arithmetic -> number .)
    VOID            reduce using rule 74 (arithmetic -> number .)
    RBRACE          reduce using rule 74 (arithmetic -> number .)
    DIVIDE          shift and go to state 99
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 100

state 31

    (78) concate -> string .
    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 78 (concate -> string .)
    $end            reduce using rule 78 (concate -> string .)
    SEMICOLON       reduce using rule 78 (concate -> string .)
    RPAREN          reduce using rule 78 (concate -> string .)
    LINE_BREAK      reduce using rule 78 (concate -> string .)
    PRINT           reduce using rule 78 (concate -> string .)
    IF              reduce using rule 78 (concate -> string .)
    WHILE           reduce using rule 78 (concate -> string .)
    FOR             reduce using rule 78 (concate -> string .)
    IDENTIFIER      reduce using rule 78 (concate -> string .)
    FINAL           reduce using rule 78 (concate -> string .)
    CONST           reduce using rule 78 (concate -> string .)
    INTEGER_TYPE    reduce using rule 78 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 78 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 78 (concate -> string .)
    QUEUE_TYPE      reduce using rule 78 (concate -> string .)
    STRING_TYPE     reduce using rule 78 (concate -> string .)
    ENUM_TYPE       reduce using rule 78 (concate -> string .)
    VAR             reduce using rule 78 (concate -> string .)
    LIST_TYPE       reduce using rule 78 (concate -> string .)
    MAP_TYPE        reduce using rule 78 (concate -> string .)
    SET_TYPE        reduce using rule 78 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 78 (concate -> string .)
    VOID            reduce using rule 78 (concate -> string .)
    RBRACE          reduce using rule 78 (concate -> string .)
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 107

state 32

    (89) logic -> comparison .

    LOGICAL_AND     reduce using rule 89 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 89 (logic -> comparison .)
    $end            reduce using rule 89 (logic -> comparison .)
    SEMICOLON       reduce using rule 89 (logic -> comparison .)
    RPAREN          reduce using rule 89 (logic -> comparison .)
    LINE_BREAK      reduce using rule 89 (logic -> comparison .)
    PRINT           reduce using rule 89 (logic -> comparison .)
    IF              reduce using rule 89 (logic -> comparison .)
    WHILE           reduce using rule 89 (logic -> comparison .)
    FOR             reduce using rule 89 (logic -> comparison .)
    IDENTIFIER      reduce using rule 89 (logic -> comparison .)
    FINAL           reduce using rule 89 (logic -> comparison .)
    CONST           reduce using rule 89 (logic -> comparison .)
    INTEGER_TYPE    reduce using rule 89 (logic -> comparison .)
    DOUBLE_TYPE     reduce using rule 89 (logic -> comparison .)
    BOOLEAN_TYPE    reduce using rule 89 (logic -> comparison .)
    QUEUE_TYPE      reduce using rule 89 (logic -> comparison .)
    STRING_TYPE     reduce using rule 89 (logic -> comparison .)
    ENUM_TYPE       reduce using rule 89 (logic -> comparison .)
    VAR             reduce using rule 89 (logic -> comparison .)
    LIST_TYPE       reduce using rule 89 (logic -> comparison .)
    MAP_TYPE        reduce using rule 89 (logic -> comparison .)
    SET_TYPE        reduce using rule 89 (logic -> comparison .)
    DYNAMIC_TYPE    reduce using rule 89 (logic -> comparison .)
    VOID            reduce using rule 89 (logic -> comparison .)
    RBRACE          reduce using rule 89 (logic -> comparison .)


state 33

    (92) logic -> LOGICAL_NOT . logic
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 109
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53

    logic                          shift and go to state 108
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56
    number                         shift and go to state 110
    string                         shift and go to state 111

state 34

    (46) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 46 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 46 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 46 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 46 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 46 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 46 (modifier -> FINAL .)
    VAR             reduce using rule 46 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 46 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 46 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 46 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 46 (modifier -> FINAL .)
    VOID            reduce using rule 46 (modifier -> FINAL .)


state 35

    (47) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 47 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 47 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 47 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 47 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 47 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 47 (modifier -> CONST .)
    VAR             reduce using rule 47 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 47 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 47 (modifier -> CONST .)
    SET_TYPE        reduce using rule 47 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 47 (modifier -> CONST .)
    VOID            reduce using rule 47 (modifier -> CONST .)


state 36

    (57) type -> INTEGER_TYPE .
    (35) number_type -> INTEGER_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 35 (number_type -> INTEGER_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 35 (number_type -> INTEGER_TYPE .)
    IDENTIFIER      reduce using rule 35 (number_type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 35 (number_type -> INTEGER_TYPE .)

  ! IDENTIFIER      [ reduce using rule 57 (type -> INTEGER_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 57 (type -> INTEGER_TYPE .) ]


state 37

    (58) type -> DOUBLE_TYPE .
    (37) number_type -> DOUBLE_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 37 (number_type -> DOUBLE_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 37 (number_type -> DOUBLE_TYPE .)
    IDENTIFIER      reduce using rule 37 (number_type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 37 (number_type -> DOUBLE_TYPE .)

  ! IDENTIFIER      [ reduce using rule 58 (type -> DOUBLE_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 58 (type -> DOUBLE_TYPE .) ]


state 38

    (59) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 59 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 59 (type -> BOOLEAN_TYPE .)
    COMMA           reduce using rule 59 (type -> BOOLEAN_TYPE .)
    GREATER         reduce using rule 59 (type -> BOOLEAN_TYPE .)
    COLON           reduce using rule 59 (type -> BOOLEAN_TYPE .)
    RBRACE          reduce using rule 59 (type -> BOOLEAN_TYPE .)


state 39

    (60) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 60 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 60 (type -> QUEUE_TYPE .)
    COMMA           reduce using rule 60 (type -> QUEUE_TYPE .)
    GREATER         reduce using rule 60 (type -> QUEUE_TYPE .)
    COLON           reduce using rule 60 (type -> QUEUE_TYPE .)
    RBRACE          reduce using rule 60 (type -> QUEUE_TYPE .)


state 40

    (61) type -> STRING_TYPE .
    (38) type_string -> STRING_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 38 (type_string -> STRING_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 38 (type_string -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 38 (type_string -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 38 (type_string -> STRING_TYPE .)

  ! IDENTIFIER      [ reduce using rule 61 (type -> STRING_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 61 (type -> STRING_TYPE .) ]


state 41

    (62) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 62 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 62 (type -> ENUM_TYPE .)
    COMMA           reduce using rule 62 (type -> ENUM_TYPE .)
    GREATER         reduce using rule 62 (type -> ENUM_TYPE .)
    COLON           reduce using rule 62 (type -> ENUM_TYPE .)
    RBRACE          reduce using rule 62 (type -> ENUM_TYPE .)


state 42

    (63) type -> VAR .
    (36) number_type -> VAR .
    (39) type_string -> VAR .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (number_type -> VAR .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 36 (number_type -> VAR .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (number_type -> VAR .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 36 (number_type -> VAR .)
    IDENTIFIER      reduce using rule 36 (number_type -> VAR .)
    QUESTION_MARK   reduce using rule 36 (number_type -> VAR .)

  ! IDENTIFIER      [ reduce using rule 63 (type -> VAR .) ]
  ! QUESTION_MARK   [ reduce using rule 63 (type -> VAR .) ]
  ! IDENTIFIER      [ reduce using rule 39 (type_string -> VAR .) ]
  ! QUESTION_MARK   [ reduce using rule 39 (type_string -> VAR .) ]


state 43

    (64) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 64 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 64 (type -> LIST_TYPE .)
    COMMA           reduce using rule 64 (type -> LIST_TYPE .)
    GREATER         reduce using rule 64 (type -> LIST_TYPE .)
    COLON           reduce using rule 64 (type -> LIST_TYPE .)
    RBRACE          reduce using rule 64 (type -> LIST_TYPE .)


state 44

    (65) type -> MAP_TYPE .
    (137) map -> MAP_TYPE . LESS type COMMA type GREATER
    (138) map -> MAP_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 65 (type -> MAP_TYPE .)
    IDENTIFIER      reduce using rule 65 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 65 (type -> MAP_TYPE .)
    LESS            shift and go to state 112

  ! IDENTIFIER      [ reduce using rule 138 (map -> MAP_TYPE .) ]


state 45

    (66) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 66 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 66 (type -> SET_TYPE .)
    COMMA           reduce using rule 66 (type -> SET_TYPE .)
    GREATER         reduce using rule 66 (type -> SET_TYPE .)
    COLON           reduce using rule 66 (type -> SET_TYPE .)
    RBRACE          reduce using rule 66 (type -> SET_TYPE .)


state 46

    (67) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 67 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 67 (type -> DYNAMIC_TYPE .)
    COMMA           reduce using rule 67 (type -> DYNAMIC_TYPE .)
    GREATER         reduce using rule 67 (type -> DYNAMIC_TYPE .)
    COLON           reduce using rule 67 (type -> DYNAMIC_TYPE .)
    RBRACE          reduce using rule 67 (type -> DYNAMIC_TYPE .)


state 47

    (68) type -> VOID .

    IDENTIFIER      reduce using rule 68 (type -> VOID .)
    QUESTION_MARK   reduce using rule 68 (type -> VOID .)
    COMMA           reduce using rule 68 (type -> VOID .)
    GREATER         reduce using rule 68 (type -> VOID .)
    COLON           reduce using rule 68 (type -> VOID .)
    RBRACE          reduce using rule 68 (type -> VOID .)


state 48

    (21) int_assignment -> number_type . IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> number_type . IDENTIFIER ASSIGN arithmetic
    (24) int_assignment -> number_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (26) int_assignment -> number_type . nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 113
    QUESTION_MARK   shift and go to state 84

    nullable                       shift and go to state 114

state 49

    (28) string_assignment -> type_string . IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> type_string . IDENTIFIER ASSIGN concate
    (31) string_assignment -> type_string . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (33) string_assignment -> type_string . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 115
    QUESTION_MARK   shift and go to state 84

    nullable                       shift and go to state 116

state 50

    (139) map_assigment -> map . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> map . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON

    IDENTIFIER      shift and go to state 117


state 51

    (110) number -> INTEGER .

    DIVIDE          reduce using rule 110 (number -> INTEGER .)
    EQUAL           reduce using rule 110 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 110 (number -> INTEGER .)
    LESS            reduce using rule 110 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 110 (number -> INTEGER .)
    GREATER         reduce using rule 110 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 110 (number -> INTEGER .)
    PLUS            reduce using rule 110 (number -> INTEGER .)
    MINUS           reduce using rule 110 (number -> INTEGER .)
    TIMES           reduce using rule 110 (number -> INTEGER .)
    $end            reduce using rule 110 (number -> INTEGER .)
    SEMICOLON       reduce using rule 110 (number -> INTEGER .)
    RPAREN          reduce using rule 110 (number -> INTEGER .)
    LINE_BREAK      reduce using rule 110 (number -> INTEGER .)
    PRINT           reduce using rule 110 (number -> INTEGER .)
    IF              reduce using rule 110 (number -> INTEGER .)
    WHILE           reduce using rule 110 (number -> INTEGER .)
    FOR             reduce using rule 110 (number -> INTEGER .)
    IDENTIFIER      reduce using rule 110 (number -> INTEGER .)
    FINAL           reduce using rule 110 (number -> INTEGER .)
    CONST           reduce using rule 110 (number -> INTEGER .)
    INTEGER_TYPE    reduce using rule 110 (number -> INTEGER .)
    DOUBLE_TYPE     reduce using rule 110 (number -> INTEGER .)
    BOOLEAN_TYPE    reduce using rule 110 (number -> INTEGER .)
    QUEUE_TYPE      reduce using rule 110 (number -> INTEGER .)
    STRING_TYPE     reduce using rule 110 (number -> INTEGER .)
    ENUM_TYPE       reduce using rule 110 (number -> INTEGER .)
    VAR             reduce using rule 110 (number -> INTEGER .)
    LIST_TYPE       reduce using rule 110 (number -> INTEGER .)
    MAP_TYPE        reduce using rule 110 (number -> INTEGER .)
    SET_TYPE        reduce using rule 110 (number -> INTEGER .)
    DYNAMIC_TYPE    reduce using rule 110 (number -> INTEGER .)
    VOID            reduce using rule 110 (number -> INTEGER .)
    RBRACE          reduce using rule 110 (number -> INTEGER .)
    COMMA           reduce using rule 110 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 110 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 110 (number -> INTEGER .)
    RSQUARE         reduce using rule 110 (number -> INTEGER .)


state 52

    (111) number -> DOUBLE .

    DIVIDE          reduce using rule 111 (number -> DOUBLE .)
    EQUAL           reduce using rule 111 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 111 (number -> DOUBLE .)
    LESS            reduce using rule 111 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 111 (number -> DOUBLE .)
    GREATER         reduce using rule 111 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 111 (number -> DOUBLE .)
    PLUS            reduce using rule 111 (number -> DOUBLE .)
    MINUS           reduce using rule 111 (number -> DOUBLE .)
    TIMES           reduce using rule 111 (number -> DOUBLE .)
    $end            reduce using rule 111 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 111 (number -> DOUBLE .)
    RPAREN          reduce using rule 111 (number -> DOUBLE .)
    LINE_BREAK      reduce using rule 111 (number -> DOUBLE .)
    PRINT           reduce using rule 111 (number -> DOUBLE .)
    IF              reduce using rule 111 (number -> DOUBLE .)
    WHILE           reduce using rule 111 (number -> DOUBLE .)
    FOR             reduce using rule 111 (number -> DOUBLE .)
    IDENTIFIER      reduce using rule 111 (number -> DOUBLE .)
    FINAL           reduce using rule 111 (number -> DOUBLE .)
    CONST           reduce using rule 111 (number -> DOUBLE .)
    INTEGER_TYPE    reduce using rule 111 (number -> DOUBLE .)
    DOUBLE_TYPE     reduce using rule 111 (number -> DOUBLE .)
    BOOLEAN_TYPE    reduce using rule 111 (number -> DOUBLE .)
    QUEUE_TYPE      reduce using rule 111 (number -> DOUBLE .)
    STRING_TYPE     reduce using rule 111 (number -> DOUBLE .)
    ENUM_TYPE       reduce using rule 111 (number -> DOUBLE .)
    VAR             reduce using rule 111 (number -> DOUBLE .)
    LIST_TYPE       reduce using rule 111 (number -> DOUBLE .)
    MAP_TYPE        reduce using rule 111 (number -> DOUBLE .)
    SET_TYPE        reduce using rule 111 (number -> DOUBLE .)
    DYNAMIC_TYPE    reduce using rule 111 (number -> DOUBLE .)
    VOID            reduce using rule 111 (number -> DOUBLE .)
    RBRACE          reduce using rule 111 (number -> DOUBLE .)
    COMMA           reduce using rule 111 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 111 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 111 (number -> DOUBLE .)
    RSQUARE         reduce using rule 111 (number -> DOUBLE .)


state 53

    (112) string -> STRING .

    EQUAL           reduce using rule 112 (string -> STRING .)
    NOT_EQUAL       reduce using rule 112 (string -> STRING .)
    LESS            reduce using rule 112 (string -> STRING .)
    LESS_EQUAL      reduce using rule 112 (string -> STRING .)
    GREATER         reduce using rule 112 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 112 (string -> STRING .)
    PLUS            reduce using rule 112 (string -> STRING .)
    $end            reduce using rule 112 (string -> STRING .)
    SEMICOLON       reduce using rule 112 (string -> STRING .)
    RPAREN          reduce using rule 112 (string -> STRING .)
    LINE_BREAK      reduce using rule 112 (string -> STRING .)
    PRINT           reduce using rule 112 (string -> STRING .)
    IF              reduce using rule 112 (string -> STRING .)
    WHILE           reduce using rule 112 (string -> STRING .)
    FOR             reduce using rule 112 (string -> STRING .)
    IDENTIFIER      reduce using rule 112 (string -> STRING .)
    FINAL           reduce using rule 112 (string -> STRING .)
    CONST           reduce using rule 112 (string -> STRING .)
    INTEGER_TYPE    reduce using rule 112 (string -> STRING .)
    DOUBLE_TYPE     reduce using rule 112 (string -> STRING .)
    BOOLEAN_TYPE    reduce using rule 112 (string -> STRING .)
    QUEUE_TYPE      reduce using rule 112 (string -> STRING .)
    STRING_TYPE     reduce using rule 112 (string -> STRING .)
    ENUM_TYPE       reduce using rule 112 (string -> STRING .)
    VAR             reduce using rule 112 (string -> STRING .)
    LIST_TYPE       reduce using rule 112 (string -> STRING .)
    MAP_TYPE        reduce using rule 112 (string -> STRING .)
    SET_TYPE        reduce using rule 112 (string -> STRING .)
    DYNAMIC_TYPE    reduce using rule 112 (string -> STRING .)
    VOID            reduce using rule 112 (string -> STRING .)
    RBRACE          reduce using rule 112 (string -> STRING .)
    COMMA           reduce using rule 112 (string -> STRING .)
    LOGICAL_AND     reduce using rule 112 (string -> STRING .)
    LOGICAL_OR      reduce using rule 112 (string -> STRING .)
    RSQUARE         reduce using rule 112 (string -> STRING .)


state 54

    (81) comparison -> int_comparison .

    LOGICAL_AND     reduce using rule 81 (comparison -> int_comparison .)
    LOGICAL_OR      reduce using rule 81 (comparison -> int_comparison .)
    $end            reduce using rule 81 (comparison -> int_comparison .)
    SEMICOLON       reduce using rule 81 (comparison -> int_comparison .)
    RPAREN          reduce using rule 81 (comparison -> int_comparison .)
    LINE_BREAK      reduce using rule 81 (comparison -> int_comparison .)
    PRINT           reduce using rule 81 (comparison -> int_comparison .)
    IF              reduce using rule 81 (comparison -> int_comparison .)
    WHILE           reduce using rule 81 (comparison -> int_comparison .)
    FOR             reduce using rule 81 (comparison -> int_comparison .)
    IDENTIFIER      reduce using rule 81 (comparison -> int_comparison .)
    FINAL           reduce using rule 81 (comparison -> int_comparison .)
    CONST           reduce using rule 81 (comparison -> int_comparison .)
    INTEGER_TYPE    reduce using rule 81 (comparison -> int_comparison .)
    DOUBLE_TYPE     reduce using rule 81 (comparison -> int_comparison .)
    BOOLEAN_TYPE    reduce using rule 81 (comparison -> int_comparison .)
    QUEUE_TYPE      reduce using rule 81 (comparison -> int_comparison .)
    STRING_TYPE     reduce using rule 81 (comparison -> int_comparison .)
    ENUM_TYPE       reduce using rule 81 (comparison -> int_comparison .)
    VAR             reduce using rule 81 (comparison -> int_comparison .)
    LIST_TYPE       reduce using rule 81 (comparison -> int_comparison .)
    MAP_TYPE        reduce using rule 81 (comparison -> int_comparison .)
    SET_TYPE        reduce using rule 81 (comparison -> int_comparison .)
    DYNAMIC_TYPE    reduce using rule 81 (comparison -> int_comparison .)
    VOID            reduce using rule 81 (comparison -> int_comparison .)
    RBRACE          reduce using rule 81 (comparison -> int_comparison .)


state 55

    (82) comparison -> string_comparison .

    LOGICAL_AND     reduce using rule 82 (comparison -> string_comparison .)
    LOGICAL_OR      reduce using rule 82 (comparison -> string_comparison .)
    $end            reduce using rule 82 (comparison -> string_comparison .)
    SEMICOLON       reduce using rule 82 (comparison -> string_comparison .)
    RPAREN          reduce using rule 82 (comparison -> string_comparison .)
    LINE_BREAK      reduce using rule 82 (comparison -> string_comparison .)
    PRINT           reduce using rule 82 (comparison -> string_comparison .)
    IF              reduce using rule 82 (comparison -> string_comparison .)
    WHILE           reduce using rule 82 (comparison -> string_comparison .)
    FOR             reduce using rule 82 (comparison -> string_comparison .)
    IDENTIFIER      reduce using rule 82 (comparison -> string_comparison .)
    FINAL           reduce using rule 82 (comparison -> string_comparison .)
    CONST           reduce using rule 82 (comparison -> string_comparison .)
    INTEGER_TYPE    reduce using rule 82 (comparison -> string_comparison .)
    DOUBLE_TYPE     reduce using rule 82 (comparison -> string_comparison .)
    BOOLEAN_TYPE    reduce using rule 82 (comparison -> string_comparison .)
    QUEUE_TYPE      reduce using rule 82 (comparison -> string_comparison .)
    STRING_TYPE     reduce using rule 82 (comparison -> string_comparison .)
    ENUM_TYPE       reduce using rule 82 (comparison -> string_comparison .)
    VAR             reduce using rule 82 (comparison -> string_comparison .)
    LIST_TYPE       reduce using rule 82 (comparison -> string_comparison .)
    MAP_TYPE        reduce using rule 82 (comparison -> string_comparison .)
    SET_TYPE        reduce using rule 82 (comparison -> string_comparison .)
    DYNAMIC_TYPE    reduce using rule 82 (comparison -> string_comparison .)
    VOID            reduce using rule 82 (comparison -> string_comparison .)
    RBRACE          reduce using rule 82 (comparison -> string_comparison .)


state 56

    (83) int_comparison -> boolean .
    (86) string_comparison -> boolean .

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for $end resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for RPAREN resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for PRINT resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for IF resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for WHILE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for FOR resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for FINAL resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for CONST resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for VAR resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for VOID resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for RBRACE resolved using rule 83 (int_comparison -> boolean .)
    LOGICAL_AND     reduce using rule 83 (int_comparison -> boolean .)
    LOGICAL_OR      reduce using rule 83 (int_comparison -> boolean .)
    $end            reduce using rule 83 (int_comparison -> boolean .)
    SEMICOLON       reduce using rule 83 (int_comparison -> boolean .)
    RPAREN          reduce using rule 83 (int_comparison -> boolean .)
    LINE_BREAK      reduce using rule 83 (int_comparison -> boolean .)
    PRINT           reduce using rule 83 (int_comparison -> boolean .)
    IF              reduce using rule 83 (int_comparison -> boolean .)
    WHILE           reduce using rule 83 (int_comparison -> boolean .)
    FOR             reduce using rule 83 (int_comparison -> boolean .)
    IDENTIFIER      reduce using rule 83 (int_comparison -> boolean .)
    FINAL           reduce using rule 83 (int_comparison -> boolean .)
    CONST           reduce using rule 83 (int_comparison -> boolean .)
    INTEGER_TYPE    reduce using rule 83 (int_comparison -> boolean .)
    DOUBLE_TYPE     reduce using rule 83 (int_comparison -> boolean .)
    BOOLEAN_TYPE    reduce using rule 83 (int_comparison -> boolean .)
    QUEUE_TYPE      reduce using rule 83 (int_comparison -> boolean .)
    STRING_TYPE     reduce using rule 83 (int_comparison -> boolean .)
    ENUM_TYPE       reduce using rule 83 (int_comparison -> boolean .)
    VAR             reduce using rule 83 (int_comparison -> boolean .)
    LIST_TYPE       reduce using rule 83 (int_comparison -> boolean .)
    MAP_TYPE        reduce using rule 83 (int_comparison -> boolean .)
    SET_TYPE        reduce using rule 83 (int_comparison -> boolean .)
    DYNAMIC_TYPE    reduce using rule 83 (int_comparison -> boolean .)
    VOID            reduce using rule 83 (int_comparison -> boolean .)
    RBRACE          reduce using rule 83 (int_comparison -> boolean .)

  ! LOGICAL_AND     [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! LOGICAL_OR      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! $end            [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! SEMICOLON       [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! RPAREN          [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! LINE_BREAK      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! PRINT           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! IF              [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! WHILE           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! FOR             [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! IDENTIFIER      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! FINAL           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! CONST           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! INTEGER_TYPE    [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! DOUBLE_TYPE     [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! QUEUE_TYPE      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! STRING_TYPE     [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! ENUM_TYPE       [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! VAR             [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! LIST_TYPE       [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! MAP_TYPE        [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! SET_TYPE        [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! VOID            [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! RBRACE          [ reduce using rule 86 (string_comparison -> boolean .) ]


state 57

    (113) boolean -> TRUE .

    LOGICAL_AND     reduce using rule 113 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 113 (boolean -> TRUE .)
    $end            reduce using rule 113 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 113 (boolean -> TRUE .)
    RPAREN          reduce using rule 113 (boolean -> TRUE .)
    LINE_BREAK      reduce using rule 113 (boolean -> TRUE .)
    PRINT           reduce using rule 113 (boolean -> TRUE .)
    IF              reduce using rule 113 (boolean -> TRUE .)
    WHILE           reduce using rule 113 (boolean -> TRUE .)
    FOR             reduce using rule 113 (boolean -> TRUE .)
    IDENTIFIER      reduce using rule 113 (boolean -> TRUE .)
    FINAL           reduce using rule 113 (boolean -> TRUE .)
    CONST           reduce using rule 113 (boolean -> TRUE .)
    INTEGER_TYPE    reduce using rule 113 (boolean -> TRUE .)
    DOUBLE_TYPE     reduce using rule 113 (boolean -> TRUE .)
    BOOLEAN_TYPE    reduce using rule 113 (boolean -> TRUE .)
    QUEUE_TYPE      reduce using rule 113 (boolean -> TRUE .)
    STRING_TYPE     reduce using rule 113 (boolean -> TRUE .)
    ENUM_TYPE       reduce using rule 113 (boolean -> TRUE .)
    VAR             reduce using rule 113 (boolean -> TRUE .)
    LIST_TYPE       reduce using rule 113 (boolean -> TRUE .)
    MAP_TYPE        reduce using rule 113 (boolean -> TRUE .)
    SET_TYPE        reduce using rule 113 (boolean -> TRUE .)
    DYNAMIC_TYPE    reduce using rule 113 (boolean -> TRUE .)
    VOID            reduce using rule 113 (boolean -> TRUE .)
    RBRACE          reduce using rule 113 (boolean -> TRUE .)


state 58

    (114) boolean -> FALSE .

    LOGICAL_AND     reduce using rule 114 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 114 (boolean -> FALSE .)
    $end            reduce using rule 114 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 114 (boolean -> FALSE .)
    RPAREN          reduce using rule 114 (boolean -> FALSE .)
    LINE_BREAK      reduce using rule 114 (boolean -> FALSE .)
    PRINT           reduce using rule 114 (boolean -> FALSE .)
    IF              reduce using rule 114 (boolean -> FALSE .)
    WHILE           reduce using rule 114 (boolean -> FALSE .)
    FOR             reduce using rule 114 (boolean -> FALSE .)
    IDENTIFIER      reduce using rule 114 (boolean -> FALSE .)
    FINAL           reduce using rule 114 (boolean -> FALSE .)
    CONST           reduce using rule 114 (boolean -> FALSE .)
    INTEGER_TYPE    reduce using rule 114 (boolean -> FALSE .)
    DOUBLE_TYPE     reduce using rule 114 (boolean -> FALSE .)
    BOOLEAN_TYPE    reduce using rule 114 (boolean -> FALSE .)
    QUEUE_TYPE      reduce using rule 114 (boolean -> FALSE .)
    STRING_TYPE     reduce using rule 114 (boolean -> FALSE .)
    ENUM_TYPE       reduce using rule 114 (boolean -> FALSE .)
    VAR             reduce using rule 114 (boolean -> FALSE .)
    LIST_TYPE       reduce using rule 114 (boolean -> FALSE .)
    MAP_TYPE        reduce using rule 114 (boolean -> FALSE .)
    SET_TYPE        reduce using rule 114 (boolean -> FALSE .)
    DYNAMIC_TYPE    reduce using rule 114 (boolean -> FALSE .)
    VOID            reduce using rule 114 (boolean -> FALSE .)
    RBRACE          reduce using rule 114 (boolean -> FALSE .)


state 59

    (51) if_statement -> if_statement ELSE . if_statement
    (52) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 119
    IF              shift and go to state 25

    if_statement                   shift and go to state 118

state 60

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 120


state 61

    (123) line -> print .

    LINE_BREAK      reduce using rule 123 (line -> print .)
    PRINT           reduce using rule 123 (line -> print .)
    IF              reduce using rule 123 (line -> print .)
    WHILE           reduce using rule 123 (line -> print .)
    FOR             reduce using rule 123 (line -> print .)
    IDENTIFIER      reduce using rule 123 (line -> print .)
    FINAL           reduce using rule 123 (line -> print .)
    CONST           reduce using rule 123 (line -> print .)
    INTEGER_TYPE    reduce using rule 123 (line -> print .)
    DOUBLE_TYPE     reduce using rule 123 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 123 (line -> print .)
    QUEUE_TYPE      reduce using rule 123 (line -> print .)
    STRING_TYPE     reduce using rule 123 (line -> print .)
    ENUM_TYPE       reduce using rule 123 (line -> print .)
    VAR             reduce using rule 123 (line -> print .)
    LIST_TYPE       reduce using rule 123 (line -> print .)
    MAP_TYPE        reduce using rule 123 (line -> print .)
    SET_TYPE        reduce using rule 123 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 123 (line -> print .)
    VOID            reduce using rule 123 (line -> print .)
    RBRACE          reduce using rule 123 (line -> print .)
    $end            reduce using rule 123 (line -> print .)


state 62

    (124) line -> assignment .

    LINE_BREAK      reduce using rule 124 (line -> assignment .)
    PRINT           reduce using rule 124 (line -> assignment .)
    IF              reduce using rule 124 (line -> assignment .)
    WHILE           reduce using rule 124 (line -> assignment .)
    FOR             reduce using rule 124 (line -> assignment .)
    IDENTIFIER      reduce using rule 124 (line -> assignment .)
    FINAL           reduce using rule 124 (line -> assignment .)
    CONST           reduce using rule 124 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 124 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 124 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 124 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 124 (line -> assignment .)
    STRING_TYPE     reduce using rule 124 (line -> assignment .)
    ENUM_TYPE       reduce using rule 124 (line -> assignment .)
    VAR             reduce using rule 124 (line -> assignment .)
    LIST_TYPE       reduce using rule 124 (line -> assignment .)
    MAP_TYPE        reduce using rule 124 (line -> assignment .)
    SET_TYPE        reduce using rule 124 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 124 (line -> assignment .)
    VOID            reduce using rule 124 (line -> assignment .)
    RBRACE          reduce using rule 124 (line -> assignment .)
    $end            reduce using rule 124 (line -> assignment .)


state 63

    (125) line -> function .

    LINE_BREAK      reduce using rule 125 (line -> function .)
    PRINT           reduce using rule 125 (line -> function .)
    IF              reduce using rule 125 (line -> function .)
    WHILE           reduce using rule 125 (line -> function .)
    FOR             reduce using rule 125 (line -> function .)
    IDENTIFIER      reduce using rule 125 (line -> function .)
    FINAL           reduce using rule 125 (line -> function .)
    CONST           reduce using rule 125 (line -> function .)
    INTEGER_TYPE    reduce using rule 125 (line -> function .)
    DOUBLE_TYPE     reduce using rule 125 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 125 (line -> function .)
    QUEUE_TYPE      reduce using rule 125 (line -> function .)
    STRING_TYPE     reduce using rule 125 (line -> function .)
    ENUM_TYPE       reduce using rule 125 (line -> function .)
    VAR             reduce using rule 125 (line -> function .)
    LIST_TYPE       reduce using rule 125 (line -> function .)
    MAP_TYPE        reduce using rule 125 (line -> function .)
    SET_TYPE        reduce using rule 125 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 125 (line -> function .)
    VOID            reduce using rule 125 (line -> function .)
    RBRACE          reduce using rule 125 (line -> function .)
    $end            reduce using rule 125 (line -> function .)


state 64

    (126) line -> if_statement .
    (51) if_statement -> if_statement . ELSE if_statement
    (52) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 126 (line -> if_statement .)
    PRINT           reduce using rule 126 (line -> if_statement .)
    IF              reduce using rule 126 (line -> if_statement .)
    WHILE           reduce using rule 126 (line -> if_statement .)
    FOR             reduce using rule 126 (line -> if_statement .)
    IDENTIFIER      reduce using rule 126 (line -> if_statement .)
    FINAL           reduce using rule 126 (line -> if_statement .)
    CONST           reduce using rule 126 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 126 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 126 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 126 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 126 (line -> if_statement .)
    STRING_TYPE     reduce using rule 126 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 126 (line -> if_statement .)
    VAR             reduce using rule 126 (line -> if_statement .)
    LIST_TYPE       reduce using rule 126 (line -> if_statement .)
    MAP_TYPE        reduce using rule 126 (line -> if_statement .)
    SET_TYPE        reduce using rule 126 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 126 (line -> if_statement .)
    VOID            reduce using rule 126 (line -> if_statement .)
    RBRACE          reduce using rule 126 (line -> if_statement .)
    $end            reduce using rule 126 (line -> if_statement .)
    ELSE            shift and go to state 59


state 65

    (127) line -> while_statement .

    LINE_BREAK      reduce using rule 127 (line -> while_statement .)
    PRINT           reduce using rule 127 (line -> while_statement .)
    IF              reduce using rule 127 (line -> while_statement .)
    WHILE           reduce using rule 127 (line -> while_statement .)
    FOR             reduce using rule 127 (line -> while_statement .)
    IDENTIFIER      reduce using rule 127 (line -> while_statement .)
    FINAL           reduce using rule 127 (line -> while_statement .)
    CONST           reduce using rule 127 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 127 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 127 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 127 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 127 (line -> while_statement .)
    STRING_TYPE     reduce using rule 127 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 127 (line -> while_statement .)
    VAR             reduce using rule 127 (line -> while_statement .)
    LIST_TYPE       reduce using rule 127 (line -> while_statement .)
    MAP_TYPE        reduce using rule 127 (line -> while_statement .)
    SET_TYPE        reduce using rule 127 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 127 (line -> while_statement .)
    VOID            reduce using rule 127 (line -> while_statement .)
    RBRACE          reduce using rule 127 (line -> while_statement .)
    $end            reduce using rule 127 (line -> while_statement .)


state 66

    (128) line -> for_statement .

    LINE_BREAK      reduce using rule 128 (line -> for_statement .)
    PRINT           reduce using rule 128 (line -> for_statement .)
    IF              reduce using rule 128 (line -> for_statement .)
    WHILE           reduce using rule 128 (line -> for_statement .)
    FOR             reduce using rule 128 (line -> for_statement .)
    IDENTIFIER      reduce using rule 128 (line -> for_statement .)
    FINAL           reduce using rule 128 (line -> for_statement .)
    CONST           reduce using rule 128 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 128 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 128 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 128 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 128 (line -> for_statement .)
    STRING_TYPE     reduce using rule 128 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 128 (line -> for_statement .)
    VAR             reduce using rule 128 (line -> for_statement .)
    LIST_TYPE       reduce using rule 128 (line -> for_statement .)
    MAP_TYPE        reduce using rule 128 (line -> for_statement .)
    SET_TYPE        reduce using rule 128 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 128 (line -> for_statement .)
    VOID            reduce using rule 128 (line -> for_statement .)
    RBRACE          reduce using rule 128 (line -> for_statement .)
    $end            reduce using rule 128 (line -> for_statement .)


state 67

    (129) line -> function_call .

    LINE_BREAK      reduce using rule 129 (line -> function_call .)
    PRINT           reduce using rule 129 (line -> function_call .)
    IF              reduce using rule 129 (line -> function_call .)
    WHILE           reduce using rule 129 (line -> function_call .)
    FOR             reduce using rule 129 (line -> function_call .)
    IDENTIFIER      reduce using rule 129 (line -> function_call .)
    FINAL           reduce using rule 129 (line -> function_call .)
    CONST           reduce using rule 129 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 129 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 129 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 129 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 129 (line -> function_call .)
    STRING_TYPE     reduce using rule 129 (line -> function_call .)
    ENUM_TYPE       reduce using rule 129 (line -> function_call .)
    VAR             reduce using rule 129 (line -> function_call .)
    LIST_TYPE       reduce using rule 129 (line -> function_call .)
    MAP_TYPE        reduce using rule 129 (line -> function_call .)
    SET_TYPE        reduce using rule 129 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 129 (line -> function_call .)
    VOID            reduce using rule 129 (line -> function_call .)
    RBRACE          reduce using rule 129 (line -> function_call .)
    $end            reduce using rule 129 (line -> function_call .)


state 68

    (130) line -> reassignment .

    LINE_BREAK      reduce using rule 130 (line -> reassignment .)
    PRINT           reduce using rule 130 (line -> reassignment .)
    IF              reduce using rule 130 (line -> reassignment .)
    WHILE           reduce using rule 130 (line -> reassignment .)
    FOR             reduce using rule 130 (line -> reassignment .)
    IDENTIFIER      reduce using rule 130 (line -> reassignment .)
    FINAL           reduce using rule 130 (line -> reassignment .)
    CONST           reduce using rule 130 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 130 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 130 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 130 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 130 (line -> reassignment .)
    STRING_TYPE     reduce using rule 130 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 130 (line -> reassignment .)
    VAR             reduce using rule 130 (line -> reassignment .)
    LIST_TYPE       reduce using rule 130 (line -> reassignment .)
    MAP_TYPE        reduce using rule 130 (line -> reassignment .)
    SET_TYPE        reduce using rule 130 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 130 (line -> reassignment .)
    VOID            reduce using rule 130 (line -> reassignment .)
    RBRACE          reduce using rule 130 (line -> reassignment .)
    $end            reduce using rule 130 (line -> reassignment .)


state 69

    (53) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN values RPAREN
    (55) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER . LPAREN RPAREN
    (40) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (43) reassignment -> IDENTIFIER . INLINE_ARITH number
    (44) reassignment -> IDENTIFIER . INLINE_ARITH

    LPAREN          shift and go to state 87
    ASSIGN          shift and go to state 85
    INLINE_ARITH    shift and go to state 86


state 70

    (75) arithmetic -> arithmetic arith_op . arithmetic
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    arithmetic                     shift and go to state 121
    number                         shift and go to state 122

state 71

    (95) arith_op -> PLUS .

    LPAREN          reduce using rule 95 (arith_op -> PLUS .)
    INTEGER         reduce using rule 95 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 95 (arith_op -> PLUS .)


state 72

    (96) arith_op -> MINUS .

    LPAREN          reduce using rule 96 (arith_op -> MINUS .)
    INTEGER         reduce using rule 96 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 96 (arith_op -> MINUS .)


state 73

    (97) arith_op -> TIMES .

    LPAREN          reduce using rule 97 (arith_op -> TIMES .)
    INTEGER         reduce using rule 97 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 97 (arith_op -> TIMES .)


state 74

    (79) concate -> concate PLUS . concate
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 53

    concate                        shift and go to state 124
    string                         shift and go to state 125

state 75

    (90) logic -> logic logic_op . logic
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 109
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53

    logic                          shift and go to state 127
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56
    number                         shift and go to state 110
    string                         shift and go to state 111

state 76

    (93) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 93 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 93 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 93 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 93 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 93 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 93 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 93 (logic_op -> LOGICAL_AND .)


state 77

    (94) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 94 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 94 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 94 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 94 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 94 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 94 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 94 (logic_op -> LOGICAL_OR .)


state 78

    (12) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 129
    QUESTION_MARK   shift and go to state 84

    nullable                       shift and go to state 128

state 79

    (23) int_assignment -> modifier number_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier number_type . nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> modifier number_type . IDENTIFIER ASSIGN arithmetic SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 131
    QUESTION_MARK   shift and go to state 84

    nullable                       shift and go to state 130

state 80

    (30) string_assignment -> modifier type_string . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier type_string . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> modifier type_string . IDENTIFIER ASSIGN concate SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 133
    QUESTION_MARK   shift and go to state 84

    nullable                       shift and go to state 132

state 81

    (65) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 65 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 65 (type -> MAP_TYPE .)
    COMMA           reduce using rule 65 (type -> MAP_TYPE .)
    GREATER         reduce using rule 65 (type -> MAP_TYPE .)
    COLON           reduce using rule 65 (type -> MAP_TYPE .)
    RBRACE          reduce using rule 65 (type -> MAP_TYPE .)


state 82

    (13) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 134


state 83

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression
    (117) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 135
    LPAREN          shift and go to state 136


state 84

    (45) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 45 (nullable -> QUESTION_MARK .)


state 85

    (40) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    expression                     shift and go to state 138
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 86

    (41) reassignment -> IDENTIFIER INLINE_ARITH . number SEMICOLON
    (42) reassignment -> IDENTIFIER INLINE_ARITH . SEMICOLON
    (43) reassignment -> IDENTIFIER INLINE_ARITH . number
    (44) reassignment -> IDENTIFIER INLINE_ARITH .
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    SEMICOLON       shift and go to state 141
    $end            reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LINE_BREAK      reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    PRINT           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IF              reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    WHILE           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FOR             reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IDENTIFIER      reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FINAL           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    CONST           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER_TYPE    reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DOUBLE_TYPE     reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    BOOLEAN_TYPE    reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    QUEUE_TYPE      reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    STRING_TYPE     reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    ENUM_TYPE       reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VAR             reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LIST_TYPE       reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    MAP_TYPE        reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    SET_TYPE        reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DYNAMIC_TYPE    reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VOID            reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RBRACE          reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RPAREN          reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    number                         shift and go to state 140

state 87

    (53) function_call -> IDENTIFIER LPAREN . values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN . values RPAREN
    (55) function_call -> IDENTIFIER LPAREN . RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER LPAREN . RPAREN
    (104) values -> . value
    (105) values -> . value COMMA values
    (106) value -> . IDENTIFIER
    (107) value -> . number
    (108) value -> . string
    (109) value -> . list
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 144
    IDENTIFIER      shift and go to state 142
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    LSQUARE         shift and go to state 149

    values                         shift and go to state 143
    value                          shift and go to state 145
    number                         shift and go to state 146
    string                         shift and go to state 147
    list                           shift and go to state 148

state 88

    (48) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (49) print -> PRINT LPAREN . RPAREN SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    RPAREN          shift and go to state 151
    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    expression                     shift and go to state 150
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 89

    (76) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 152

state 90

    (80) concate -> LPAREN concate . PLUS concate RPAREN
    (79) concate -> concate . PLUS concate

    PLUS            shift and go to state 153


state 91

    (91) logic -> LPAREN logic . logic_op logic RPAREN
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 154

state 92

    (85) int_comparison -> LPAREN number . comp_op number RPAREN
    (74) arithmetic -> number .
    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 74 (arithmetic -> number .)
    MINUS           reduce using rule 74 (arithmetic -> number .)
    TIMES           reduce using rule 74 (arithmetic -> number .)
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 155

state 93

    (88) string_comparison -> LPAREN string . comp_op string RPAREN
    (78) concate -> string .
    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 78 (concate -> string .)
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 156

state 94

    (50) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 109
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53

    logic                          shift and go to state 157
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56
    number                         shift and go to state 110
    string                         shift and go to state 111

state 95

    (149) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 109
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53

    logic                          shift and go to state 158
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56
    number                         shift and go to state 110
    string                         shift and go to state 111

state 96

    (150) for_statement -> FOR LPAREN . assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

    SEMICOLON       reduce using rule 19 (assignment -> .)
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    assignment                     shift and go to state 159
    modifier                       shift and go to state 17
    type                           shift and go to state 160
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 97

    (118) lines -> line LINE_BREAK . lines
    (121) lines -> LINE_BREAK .
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! reduce/reduce conflict for $end resolved using rule 121 (lines -> LINE_BREAK .)
  ! reduce/reduce conflict for RBRACE resolved using rule 121 (lines -> LINE_BREAK .)
  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 19 (assignment -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    $end            reduce using rule 19 (assignment -> .)
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! $end            [ reduce using rule 121 (lines -> LINE_BREAK .) ]
  ! RBRACE          [ reduce using rule 121 (lines -> LINE_BREAK .) ]
  ! $end            [ reduce using rule 122 (lines -> .) ]
  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    line                           shift and go to state 28
    lines                          shift and go to state 161
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 98

    (119) lines -> line lines .

    $end            reduce using rule 119 (lines -> line lines .)
    RBRACE          reduce using rule 119 (lines -> line lines .)


state 99

    (77) division -> number DIVIDE . number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    number                         shift and go to state 162

state 100

    (84) int_comparison -> number comp_op . number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    number                         shift and go to state 163

state 101

    (98) comp_op -> EQUAL .

    INTEGER         reduce using rule 98 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 98 (comp_op -> EQUAL .)
    STRING          reduce using rule 98 (comp_op -> EQUAL .)


state 102

    (99) comp_op -> NOT_EQUAL .

    INTEGER         reduce using rule 99 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 99 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 99 (comp_op -> NOT_EQUAL .)


state 103

    (100) comp_op -> LESS .

    INTEGER         reduce using rule 100 (comp_op -> LESS .)
    DOUBLE          reduce using rule 100 (comp_op -> LESS .)
    STRING          reduce using rule 100 (comp_op -> LESS .)


state 104

    (101) comp_op -> LESS_EQUAL .

    INTEGER         reduce using rule 101 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 101 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 101 (comp_op -> LESS_EQUAL .)


state 105

    (102) comp_op -> GREATER .

    INTEGER         reduce using rule 102 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 102 (comp_op -> GREATER .)
    STRING          reduce using rule 102 (comp_op -> GREATER .)


state 106

    (103) comp_op -> GREATER_EQUAL .

    INTEGER         reduce using rule 103 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 103 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 103 (comp_op -> GREATER_EQUAL .)


state 107

    (87) string_comparison -> string comp_op . string
    (112) string -> . STRING

    STRING          shift and go to state 53

    string                         shift and go to state 164

state 108

    (92) logic -> LOGICAL_NOT logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    LINE_BREAK      reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    PRINT           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    IF              reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    WHILE           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    FOR             reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    IDENTIFIER      reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    FINAL           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    CONST           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    INTEGER_TYPE    reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    DOUBLE_TYPE     reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    BOOLEAN_TYPE    reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    QUEUE_TYPE      reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    STRING_TYPE     reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    ENUM_TYPE       reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    VAR             reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    LIST_TYPE       reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    MAP_TYPE        reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    SET_TYPE        reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    DYNAMIC_TYPE    reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    VOID            reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    RBRACE          reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

  ! LOGICAL_AND     [ reduce using rule 92 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 75

state 109

    (91) logic -> LPAREN . logic logic_op logic RPAREN
    (85) int_comparison -> LPAREN . number comp_op number RPAREN
    (88) string_comparison -> LPAREN . string comp_op string RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 109
    LOGICAL_NOT     shift and go to state 33
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    logic                          shift and go to state 91
    number                         shift and go to state 165
    string                         shift and go to state 166
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 110

    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 100

state 111

    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 107

state 112

    (137) map -> MAP_TYPE LESS . type COMMA type GREATER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 168
    DOUBLE_TYPE     shift and go to state 169
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 170
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 171
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    type                           shift and go to state 167

state 113

    (21) int_assignment -> number_type IDENTIFIER . ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> number_type IDENTIFIER . ASSIGN arithmetic

    ASSIGN          shift and go to state 172


state 114

    (24) int_assignment -> number_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (26) int_assignment -> number_type nullable . IDENTIFIER ASSIGN arithmetic SEMICOLON

    IDENTIFIER      shift and go to state 173


state 115

    (28) string_assignment -> type_string IDENTIFIER . ASSIGN concate SEMICOLON
    (29) string_assignment -> type_string IDENTIFIER . ASSIGN concate

    ASSIGN          shift and go to state 174


state 116

    (31) string_assignment -> type_string nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (33) string_assignment -> type_string nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 175


state 117

    (139) map_assigment -> map IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> map IDENTIFIER . ASSIGN LBRACE map_values RBRACE SEMICOLON

    ASSIGN          shift and go to state 176


state 118

    (51) if_statement -> if_statement ELSE if_statement .
    (51) if_statement -> if_statement . ELSE if_statement
    (52) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    WHILE           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    FOR             reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    IDENTIFIER      reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 59

  ! ELSE            [ reduce using rule 51 (if_statement -> if_statement ELSE if_statement .) ]


state 119

    (52) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    if_statement                   shift and go to state 64
    lines                          shift and go to state 177
    line                           shift and go to state 28
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 120

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 121

    (75) arithmetic -> arithmetic arith_op arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    $end            reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    LINE_BREAK      reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    PRINT           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    IF              reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    WHILE           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    FOR             reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    IDENTIFIER      reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    FINAL           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    CONST           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER_TYPE    reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE_TYPE     reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    BOOLEAN_TYPE    reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    QUEUE_TYPE      reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING_TYPE     reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    ENUM_TYPE       reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    VAR             reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    LIST_TYPE       reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    MAP_TYPE        reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    SET_TYPE        reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    DYNAMIC_TYPE    reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    VOID            reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    RBRACE          reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

  ! PLUS            [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 70

state 122

    (74) arithmetic -> number .

    PLUS            reduce using rule 74 (arithmetic -> number .)
    MINUS           reduce using rule 74 (arithmetic -> number .)
    TIMES           reduce using rule 74 (arithmetic -> number .)
    $end            reduce using rule 74 (arithmetic -> number .)
    SEMICOLON       reduce using rule 74 (arithmetic -> number .)
    RPAREN          reduce using rule 74 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 74 (arithmetic -> number .)
    PRINT           reduce using rule 74 (arithmetic -> number .)
    IF              reduce using rule 74 (arithmetic -> number .)
    WHILE           reduce using rule 74 (arithmetic -> number .)
    FOR             reduce using rule 74 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 74 (arithmetic -> number .)
    FINAL           reduce using rule 74 (arithmetic -> number .)
    CONST           reduce using rule 74 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 74 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 74 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 74 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 74 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 74 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 74 (arithmetic -> number .)
    VAR             reduce using rule 74 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 74 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 74 (arithmetic -> number .)
    SET_TYPE        reduce using rule 74 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 74 (arithmetic -> number .)
    VOID            reduce using rule 74 (arithmetic -> number .)
    RBRACE          reduce using rule 74 (arithmetic -> number .)


state 123

    (76) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    arithmetic                     shift and go to state 89
    number                         shift and go to state 122

state 124

    (79) concate -> concate PLUS concate .
    (79) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    $end            reduce using rule 79 (concate -> concate PLUS concate .)
    SEMICOLON       reduce using rule 79 (concate -> concate PLUS concate .)
    RPAREN          reduce using rule 79 (concate -> concate PLUS concate .)
    LINE_BREAK      reduce using rule 79 (concate -> concate PLUS concate .)
    PRINT           reduce using rule 79 (concate -> concate PLUS concate .)
    IF              reduce using rule 79 (concate -> concate PLUS concate .)
    WHILE           reduce using rule 79 (concate -> concate PLUS concate .)
    FOR             reduce using rule 79 (concate -> concate PLUS concate .)
    IDENTIFIER      reduce using rule 79 (concate -> concate PLUS concate .)
    FINAL           reduce using rule 79 (concate -> concate PLUS concate .)
    CONST           reduce using rule 79 (concate -> concate PLUS concate .)
    INTEGER_TYPE    reduce using rule 79 (concate -> concate PLUS concate .)
    DOUBLE_TYPE     reduce using rule 79 (concate -> concate PLUS concate .)
    BOOLEAN_TYPE    reduce using rule 79 (concate -> concate PLUS concate .)
    QUEUE_TYPE      reduce using rule 79 (concate -> concate PLUS concate .)
    STRING_TYPE     reduce using rule 79 (concate -> concate PLUS concate .)
    ENUM_TYPE       reduce using rule 79 (concate -> concate PLUS concate .)
    VAR             reduce using rule 79 (concate -> concate PLUS concate .)
    LIST_TYPE       reduce using rule 79 (concate -> concate PLUS concate .)
    MAP_TYPE        reduce using rule 79 (concate -> concate PLUS concate .)
    SET_TYPE        reduce using rule 79 (concate -> concate PLUS concate .)
    DYNAMIC_TYPE    reduce using rule 79 (concate -> concate PLUS concate .)
    VOID            reduce using rule 79 (concate -> concate PLUS concate .)
    RBRACE          reduce using rule 79 (concate -> concate PLUS concate .)
    PLUS            shift and go to state 74

  ! PLUS            [ reduce using rule 79 (concate -> concate PLUS concate .) ]


state 125

    (78) concate -> string .

    PLUS            reduce using rule 78 (concate -> string .)
    $end            reduce using rule 78 (concate -> string .)
    SEMICOLON       reduce using rule 78 (concate -> string .)
    RPAREN          reduce using rule 78 (concate -> string .)
    LINE_BREAK      reduce using rule 78 (concate -> string .)
    PRINT           reduce using rule 78 (concate -> string .)
    IF              reduce using rule 78 (concate -> string .)
    WHILE           reduce using rule 78 (concate -> string .)
    FOR             reduce using rule 78 (concate -> string .)
    IDENTIFIER      reduce using rule 78 (concate -> string .)
    FINAL           reduce using rule 78 (concate -> string .)
    CONST           reduce using rule 78 (concate -> string .)
    INTEGER_TYPE    reduce using rule 78 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 78 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 78 (concate -> string .)
    QUEUE_TYPE      reduce using rule 78 (concate -> string .)
    STRING_TYPE     reduce using rule 78 (concate -> string .)
    ENUM_TYPE       reduce using rule 78 (concate -> string .)
    VAR             reduce using rule 78 (concate -> string .)
    LIST_TYPE       reduce using rule 78 (concate -> string .)
    MAP_TYPE        reduce using rule 78 (concate -> string .)
    SET_TYPE        reduce using rule 78 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 78 (concate -> string .)
    VOID            reduce using rule 78 (concate -> string .)
    RBRACE          reduce using rule 78 (concate -> string .)


state 126

    (80) concate -> LPAREN . concate PLUS concate RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 53

    concate                        shift and go to state 90
    string                         shift and go to state 125

state 127

    (90) logic -> logic logic_op logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 90 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 90 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 90 (logic -> logic logic_op logic .)
    LINE_BREAK      reduce using rule 90 (logic -> logic logic_op logic .)
    PRINT           reduce using rule 90 (logic -> logic logic_op logic .)
    IF              reduce using rule 90 (logic -> logic logic_op logic .)
    WHILE           reduce using rule 90 (logic -> logic logic_op logic .)
    FOR             reduce using rule 90 (logic -> logic logic_op logic .)
    IDENTIFIER      reduce using rule 90 (logic -> logic logic_op logic .)
    FINAL           reduce using rule 90 (logic -> logic logic_op logic .)
    CONST           reduce using rule 90 (logic -> logic logic_op logic .)
    INTEGER_TYPE    reduce using rule 90 (logic -> logic logic_op logic .)
    DOUBLE_TYPE     reduce using rule 90 (logic -> logic logic_op logic .)
    BOOLEAN_TYPE    reduce using rule 90 (logic -> logic logic_op logic .)
    QUEUE_TYPE      reduce using rule 90 (logic -> logic logic_op logic .)
    STRING_TYPE     reduce using rule 90 (logic -> logic logic_op logic .)
    ENUM_TYPE       reduce using rule 90 (logic -> logic logic_op logic .)
    VAR             reduce using rule 90 (logic -> logic logic_op logic .)
    LIST_TYPE       reduce using rule 90 (logic -> logic logic_op logic .)
    MAP_TYPE        reduce using rule 90 (logic -> logic logic_op logic .)
    SET_TYPE        reduce using rule 90 (logic -> logic logic_op logic .)
    DYNAMIC_TYPE    reduce using rule 90 (logic -> logic logic_op logic .)
    VOID            reduce using rule 90 (logic -> logic logic_op logic .)
    RBRACE          reduce using rule 90 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

  ! LOGICAL_AND     [ reduce using rule 90 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 90 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 75

state 128

    (12) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 178


state 129

    (14) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 179


state 130

    (23) int_assignment -> modifier number_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier number_type nullable . IDENTIFIER ASSIGN arithmetic SEMICOLON

    IDENTIFIER      shift and go to state 180


state 131

    (27) int_assignment -> modifier number_type IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 181


state 132

    (30) string_assignment -> modifier type_string nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier type_string nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 182


state 133

    (34) string_assignment -> modifier type_string IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 183


state 134

    (13) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 184


state 135

    (15) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN . expression
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    expression                     shift and go to state 185
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 136

    (117) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (131) parameters -> . VOID
    (132) parameters -> . parameter
    (133) parameters -> . parameter COMMA parameters
    (134) parameters -> .
    (135) parameter -> . type IDENTIFIER
    (136) parameter -> . IDENTIFIER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    VOID            shift and go to state 189
    RPAREN          reduce using rule 134 (parameters -> .)
    IDENTIFIER      shift and go to state 187
    INTEGER_TYPE    shift and go to state 168
    DOUBLE_TYPE     shift and go to state 169
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 170
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 171
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46

    type                           shift and go to state 186
    parameters                     shift and go to state 188
    parameter                      shift and go to state 190

state 137

    (53) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN values RPAREN
    (55) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 87


state 138

    (40) reassignment -> IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 191


state 139

    (72) expression -> function_call .

    SEMICOLON       reduce using rule 72 (expression -> function_call .)
    RPAREN          reduce using rule 72 (expression -> function_call .)
    $end            reduce using rule 72 (expression -> function_call .)
    LINE_BREAK      reduce using rule 72 (expression -> function_call .)
    PRINT           reduce using rule 72 (expression -> function_call .)
    IF              reduce using rule 72 (expression -> function_call .)
    WHILE           reduce using rule 72 (expression -> function_call .)
    FOR             reduce using rule 72 (expression -> function_call .)
    IDENTIFIER      reduce using rule 72 (expression -> function_call .)
    FINAL           reduce using rule 72 (expression -> function_call .)
    CONST           reduce using rule 72 (expression -> function_call .)
    INTEGER_TYPE    reduce using rule 72 (expression -> function_call .)
    DOUBLE_TYPE     reduce using rule 72 (expression -> function_call .)
    BOOLEAN_TYPE    reduce using rule 72 (expression -> function_call .)
    QUEUE_TYPE      reduce using rule 72 (expression -> function_call .)
    STRING_TYPE     reduce using rule 72 (expression -> function_call .)
    ENUM_TYPE       reduce using rule 72 (expression -> function_call .)
    VAR             reduce using rule 72 (expression -> function_call .)
    LIST_TYPE       reduce using rule 72 (expression -> function_call .)
    MAP_TYPE        reduce using rule 72 (expression -> function_call .)
    SET_TYPE        reduce using rule 72 (expression -> function_call .)
    DYNAMIC_TYPE    reduce using rule 72 (expression -> function_call .)
    VOID            reduce using rule 72 (expression -> function_call .)
    RBRACE          reduce using rule 72 (expression -> function_call .)


state 140

    (41) reassignment -> IDENTIFIER INLINE_ARITH number . SEMICOLON
    (43) reassignment -> IDENTIFIER INLINE_ARITH number .

    SEMICOLON       shift and go to state 192
    $end            reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LINE_BREAK      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    PRINT           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IF              reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    WHILE           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FOR             reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IDENTIFIER      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FINAL           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    CONST           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    INTEGER_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DOUBLE_TYPE     reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    BOOLEAN_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    QUEUE_TYPE      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    STRING_TYPE     reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    ENUM_TYPE       reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VAR             reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LIST_TYPE       reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    MAP_TYPE        reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    SET_TYPE        reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DYNAMIC_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VOID            reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RBRACE          reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RPAREN          reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)


state 141

    (42) reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .

    $end            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LINE_BREAK      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    PRINT           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IF              reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    WHILE           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FOR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FINAL           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    CONST           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    INTEGER_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    QUEUE_TYPE      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    STRING_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    ENUM_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VAR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LIST_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    MAP_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    SET_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VOID            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RBRACE          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RPAREN          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)


state 142

    (106) value -> IDENTIFIER .

    COMMA           reduce using rule 106 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 106 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 106 (value -> IDENTIFIER .)


state 143

    (53) function_call -> IDENTIFIER LPAREN values . RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN values . RPAREN

    RPAREN          shift and go to state 193


state 144

    (55) function_call -> IDENTIFIER LPAREN RPAREN . SEMICOLON
    (56) function_call -> IDENTIFIER LPAREN RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 194
    $end            reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LINE_BREAK      reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FINAL           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONST           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER_TYPE    reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE_TYPE     reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BOOLEAN_TYPE    reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    QUEUE_TYPE      reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING_TYPE     reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ENUM_TYPE       reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LIST_TYPE       reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MAP_TYPE        reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SET_TYPE        reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DYNAMIC_TYPE    reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VOID            reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .) ]


state 145

    (104) values -> value .
    (105) values -> value . COMMA values

    RPAREN          reduce using rule 104 (values -> value .)
    RSQUARE         reduce using rule 104 (values -> value .)
    COMMA           shift and go to state 195


state 146

    (107) value -> number .

    COMMA           reduce using rule 107 (value -> number .)
    RPAREN          reduce using rule 107 (value -> number .)
    RSQUARE         reduce using rule 107 (value -> number .)


state 147

    (108) value -> string .

    COMMA           reduce using rule 108 (value -> string .)
    RPAREN          reduce using rule 108 (value -> string .)
    RSQUARE         reduce using rule 108 (value -> string .)


state 148

    (109) value -> list .

    COMMA           reduce using rule 109 (value -> list .)
    RPAREN          reduce using rule 109 (value -> list .)
    RSQUARE         reduce using rule 109 (value -> list .)


state 149

    (115) list -> LSQUARE . RSQUARE
    (116) list -> LSQUARE . values RSQUARE
    (104) values -> . value
    (105) values -> . value COMMA values
    (106) value -> . IDENTIFIER
    (107) value -> . number
    (108) value -> . string
    (109) value -> . list
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 196
    IDENTIFIER      shift and go to state 142
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    LSQUARE         shift and go to state 149

    values                         shift and go to state 197
    value                          shift and go to state 145
    number                         shift and go to state 146
    string                         shift and go to state 147
    list                           shift and go to state 148

state 150

    (48) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 198


state 151

    (49) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 199


state 152

    (76) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (75) arithmetic -> arithmetic arith_op . arithmetic
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    arithmetic                     shift and go to state 200
    number                         shift and go to state 122

state 153

    (80) concate -> LPAREN concate PLUS . concate RPAREN
    (79) concate -> concate PLUS . concate
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 53

    concate                        shift and go to state 201
    string                         shift and go to state 125

state 154

    (91) logic -> LPAREN logic logic_op . logic RPAREN
    (90) logic -> logic logic_op . logic
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 109
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53

    logic                          shift and go to state 202
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56
    number                         shift and go to state 110
    string                         shift and go to state 111

state 155

    (85) int_comparison -> LPAREN number comp_op . number RPAREN
    (84) int_comparison -> number comp_op . number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    number                         shift and go to state 203

state 156

    (88) string_comparison -> LPAREN string comp_op . string RPAREN
    (87) string_comparison -> string comp_op . string
    (112) string -> . STRING

    STRING          shift and go to state 53

    string                         shift and go to state 204

state 157

    (50) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 205
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 158

    (149) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 206
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 159

    (150) for_statement -> FOR LPAREN assignment . SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    SEMICOLON       shift and go to state 207


state 160

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 208
    QUESTION_MARK   shift and go to state 84

    nullable                       shift and go to state 82

state 161

    (118) lines -> line LINE_BREAK lines .

    $end            reduce using rule 118 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 118 (lines -> line LINE_BREAK lines .)


state 162

    (77) division -> number DIVIDE number .

    $end            reduce using rule 77 (division -> number DIVIDE number .)
    SEMICOLON       reduce using rule 77 (division -> number DIVIDE number .)
    RPAREN          reduce using rule 77 (division -> number DIVIDE number .)
    LINE_BREAK      reduce using rule 77 (division -> number DIVIDE number .)
    PRINT           reduce using rule 77 (division -> number DIVIDE number .)
    IF              reduce using rule 77 (division -> number DIVIDE number .)
    WHILE           reduce using rule 77 (division -> number DIVIDE number .)
    FOR             reduce using rule 77 (division -> number DIVIDE number .)
    IDENTIFIER      reduce using rule 77 (division -> number DIVIDE number .)
    FINAL           reduce using rule 77 (division -> number DIVIDE number .)
    CONST           reduce using rule 77 (division -> number DIVIDE number .)
    INTEGER_TYPE    reduce using rule 77 (division -> number DIVIDE number .)
    DOUBLE_TYPE     reduce using rule 77 (division -> number DIVIDE number .)
    BOOLEAN_TYPE    reduce using rule 77 (division -> number DIVIDE number .)
    QUEUE_TYPE      reduce using rule 77 (division -> number DIVIDE number .)
    STRING_TYPE     reduce using rule 77 (division -> number DIVIDE number .)
    ENUM_TYPE       reduce using rule 77 (division -> number DIVIDE number .)
    VAR             reduce using rule 77 (division -> number DIVIDE number .)
    LIST_TYPE       reduce using rule 77 (division -> number DIVIDE number .)
    MAP_TYPE        reduce using rule 77 (division -> number DIVIDE number .)
    SET_TYPE        reduce using rule 77 (division -> number DIVIDE number .)
    DYNAMIC_TYPE    reduce using rule 77 (division -> number DIVIDE number .)
    VOID            reduce using rule 77 (division -> number DIVIDE number .)
    RBRACE          reduce using rule 77 (division -> number DIVIDE number .)


state 163

    (84) int_comparison -> number comp_op number .

    LOGICAL_AND     reduce using rule 84 (int_comparison -> number comp_op number .)
    LOGICAL_OR      reduce using rule 84 (int_comparison -> number comp_op number .)
    $end            reduce using rule 84 (int_comparison -> number comp_op number .)
    SEMICOLON       reduce using rule 84 (int_comparison -> number comp_op number .)
    RPAREN          reduce using rule 84 (int_comparison -> number comp_op number .)
    LINE_BREAK      reduce using rule 84 (int_comparison -> number comp_op number .)
    PRINT           reduce using rule 84 (int_comparison -> number comp_op number .)
    IF              reduce using rule 84 (int_comparison -> number comp_op number .)
    WHILE           reduce using rule 84 (int_comparison -> number comp_op number .)
    FOR             reduce using rule 84 (int_comparison -> number comp_op number .)
    IDENTIFIER      reduce using rule 84 (int_comparison -> number comp_op number .)
    FINAL           reduce using rule 84 (int_comparison -> number comp_op number .)
    CONST           reduce using rule 84 (int_comparison -> number comp_op number .)
    INTEGER_TYPE    reduce using rule 84 (int_comparison -> number comp_op number .)
    DOUBLE_TYPE     reduce using rule 84 (int_comparison -> number comp_op number .)
    BOOLEAN_TYPE    reduce using rule 84 (int_comparison -> number comp_op number .)
    QUEUE_TYPE      reduce using rule 84 (int_comparison -> number comp_op number .)
    STRING_TYPE     reduce using rule 84 (int_comparison -> number comp_op number .)
    ENUM_TYPE       reduce using rule 84 (int_comparison -> number comp_op number .)
    VAR             reduce using rule 84 (int_comparison -> number comp_op number .)
    LIST_TYPE       reduce using rule 84 (int_comparison -> number comp_op number .)
    MAP_TYPE        reduce using rule 84 (int_comparison -> number comp_op number .)
    SET_TYPE        reduce using rule 84 (int_comparison -> number comp_op number .)
    DYNAMIC_TYPE    reduce using rule 84 (int_comparison -> number comp_op number .)
    VOID            reduce using rule 84 (int_comparison -> number comp_op number .)
    RBRACE          reduce using rule 84 (int_comparison -> number comp_op number .)


state 164

    (87) string_comparison -> string comp_op string .

    LOGICAL_AND     reduce using rule 87 (string_comparison -> string comp_op string .)
    LOGICAL_OR      reduce using rule 87 (string_comparison -> string comp_op string .)
    $end            reduce using rule 87 (string_comparison -> string comp_op string .)
    SEMICOLON       reduce using rule 87 (string_comparison -> string comp_op string .)
    RPAREN          reduce using rule 87 (string_comparison -> string comp_op string .)
    LINE_BREAK      reduce using rule 87 (string_comparison -> string comp_op string .)
    PRINT           reduce using rule 87 (string_comparison -> string comp_op string .)
    IF              reduce using rule 87 (string_comparison -> string comp_op string .)
    WHILE           reduce using rule 87 (string_comparison -> string comp_op string .)
    FOR             reduce using rule 87 (string_comparison -> string comp_op string .)
    IDENTIFIER      reduce using rule 87 (string_comparison -> string comp_op string .)
    FINAL           reduce using rule 87 (string_comparison -> string comp_op string .)
    CONST           reduce using rule 87 (string_comparison -> string comp_op string .)
    INTEGER_TYPE    reduce using rule 87 (string_comparison -> string comp_op string .)
    DOUBLE_TYPE     reduce using rule 87 (string_comparison -> string comp_op string .)
    BOOLEAN_TYPE    reduce using rule 87 (string_comparison -> string comp_op string .)
    QUEUE_TYPE      reduce using rule 87 (string_comparison -> string comp_op string .)
    STRING_TYPE     reduce using rule 87 (string_comparison -> string comp_op string .)
    ENUM_TYPE       reduce using rule 87 (string_comparison -> string comp_op string .)
    VAR             reduce using rule 87 (string_comparison -> string comp_op string .)
    LIST_TYPE       reduce using rule 87 (string_comparison -> string comp_op string .)
    MAP_TYPE        reduce using rule 87 (string_comparison -> string comp_op string .)
    SET_TYPE        reduce using rule 87 (string_comparison -> string comp_op string .)
    DYNAMIC_TYPE    reduce using rule 87 (string_comparison -> string comp_op string .)
    VOID            reduce using rule 87 (string_comparison -> string comp_op string .)
    RBRACE          reduce using rule 87 (string_comparison -> string comp_op string .)


state 165

    (85) int_comparison -> LPAREN number . comp_op number RPAREN
    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 155

state 166

    (88) string_comparison -> LPAREN string . comp_op string RPAREN
    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 156

state 167

    (137) map -> MAP_TYPE LESS type . COMMA type GREATER

    COMMA           shift and go to state 209


state 168

    (57) type -> INTEGER_TYPE .

    COMMA           reduce using rule 57 (type -> INTEGER_TYPE .)
    IDENTIFIER      reduce using rule 57 (type -> INTEGER_TYPE .)
    GREATER         reduce using rule 57 (type -> INTEGER_TYPE .)
    COLON           reduce using rule 57 (type -> INTEGER_TYPE .)
    RBRACE          reduce using rule 57 (type -> INTEGER_TYPE .)


state 169

    (58) type -> DOUBLE_TYPE .

    COMMA           reduce using rule 58 (type -> DOUBLE_TYPE .)
    IDENTIFIER      reduce using rule 58 (type -> DOUBLE_TYPE .)
    GREATER         reduce using rule 58 (type -> DOUBLE_TYPE .)
    COLON           reduce using rule 58 (type -> DOUBLE_TYPE .)
    RBRACE          reduce using rule 58 (type -> DOUBLE_TYPE .)


state 170

    (61) type -> STRING_TYPE .

    COMMA           reduce using rule 61 (type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 61 (type -> STRING_TYPE .)
    GREATER         reduce using rule 61 (type -> STRING_TYPE .)
    COLON           reduce using rule 61 (type -> STRING_TYPE .)
    RBRACE          reduce using rule 61 (type -> STRING_TYPE .)


state 171

    (63) type -> VAR .

    COMMA           reduce using rule 63 (type -> VAR .)
    IDENTIFIER      reduce using rule 63 (type -> VAR .)
    GREATER         reduce using rule 63 (type -> VAR .)
    COLON           reduce using rule 63 (type -> VAR .)
    RBRACE          reduce using rule 63 (type -> VAR .)


state 172

    (21) int_assignment -> number_type IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (22) int_assignment -> number_type IDENTIFIER ASSIGN . arithmetic
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    arithmetic                     shift and go to state 210
    number                         shift and go to state 122

state 173

    (24) int_assignment -> number_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (26) int_assignment -> number_type nullable IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 211


state 174

    (28) string_assignment -> type_string IDENTIFIER ASSIGN . concate SEMICOLON
    (29) string_assignment -> type_string IDENTIFIER ASSIGN . concate
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 53

    concate                        shift and go to state 212
    string                         shift and go to state 125

state 175

    (31) string_assignment -> type_string nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (33) string_assignment -> type_string nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 213


state 176

    (139) map_assigment -> map IDENTIFIER ASSIGN . LBRACE RBRACE SEMICOLON
    (140) map_assigment -> map IDENTIFIER ASSIGN . LBRACE map_values RBRACE SEMICOLON

    LBRACE          shift and go to state 214


state 177

    (52) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 215


state 178

    (12) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 216


state 179

    (14) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    expression                     shift and go to state 217
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 180

    (23) int_assignment -> modifier number_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier number_type nullable IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 218


state 181

    (27) int_assignment -> modifier number_type IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    arithmetic                     shift and go to state 219
    number                         shift and go to state 122

state 182

    (30) string_assignment -> modifier type_string nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier type_string nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 220


state 183

    (34) string_assignment -> modifier type_string IDENTIFIER ASSIGN . concate SEMICOLON
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 53

    concate                        shift and go to state 221
    string                         shift and go to state 125

state 184

    (13) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    expression                     shift and go to state 222
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 185

    (15) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN expression .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 223
    $end            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LINE_BREAK      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    PRINT           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FINAL           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    BOOLEAN_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    QUEUE_TYPE      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    ENUM_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LIST_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    MAP_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    SET_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DYNAMIC_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VOID            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)

  ! SEMICOLON       [ reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .) ]


state 186

    (135) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 224


state 187

    (136) parameter -> IDENTIFIER .

    COMMA           reduce using rule 136 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 136 (parameter -> IDENTIFIER .)


state 188

    (117) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 225


state 189

    (131) parameters -> VOID .
    (68) type -> VOID .

    RPAREN          reduce using rule 131 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 68 (type -> VOID .)


state 190

    (132) parameters -> parameter .
    (133) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 132 (parameters -> parameter .)
    COMMA           shift and go to state 226


state 191

    (40) reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 192

    (41) reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .

    $end            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LINE_BREAK      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    PRINT           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IF              reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    WHILE           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FOR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FINAL           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    CONST           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    INTEGER_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    QUEUE_TYPE      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    STRING_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    ENUM_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VAR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LIST_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    MAP_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    SET_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VOID            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RBRACE          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RPAREN          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)


state 193

    (53) function_call -> IDENTIFIER LPAREN values RPAREN . SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 227
    $end            reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LINE_BREAK      reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PRINT           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    WHILE           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FINAL           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    QUEUE_TYPE      reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    ENUM_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LIST_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    MAP_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SET_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DYNAMIC_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VOID            reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RBRACE          reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RPAREN          reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! SEMICOLON       [ reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .) ]


state 194

    (55) function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)


state 195

    (105) values -> value COMMA . values
    (104) values -> . value
    (105) values -> . value COMMA values
    (106) value -> . IDENTIFIER
    (107) value -> . number
    (108) value -> . string
    (109) value -> . list
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 142
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    LSQUARE         shift and go to state 149

    value                          shift and go to state 145
    values                         shift and go to state 228
    number                         shift and go to state 146
    string                         shift and go to state 147
    list                           shift and go to state 148

state 196

    (115) list -> LSQUARE RSQUARE .

    COMMA           reduce using rule 115 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 115 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 115 (list -> LSQUARE RSQUARE .)


state 197

    (116) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 229


state 198

    (48) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 230


state 199

    (49) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 200

    (76) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (75) arithmetic -> arithmetic arith_op arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    RPAREN          shift and go to state 231
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

  ! PLUS            [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 70

state 201

    (80) concate -> LPAREN concate PLUS concate . RPAREN
    (79) concate -> concate PLUS concate .
    (79) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 232
    PLUS            shift and go to state 74

  ! PLUS            [ reduce using rule 79 (concate -> concate PLUS concate .) ]


state 202

    (91) logic -> LPAREN logic logic_op logic . RPAREN
    (90) logic -> logic logic_op logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 233
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

  ! LOGICAL_AND     [ reduce using rule 90 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 90 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 75

state 203

    (85) int_comparison -> LPAREN number comp_op number . RPAREN
    (84) int_comparison -> number comp_op number .

    RPAREN          shift and go to state 234
    LOGICAL_AND     reduce using rule 84 (int_comparison -> number comp_op number .)
    LOGICAL_OR      reduce using rule 84 (int_comparison -> number comp_op number .)


state 204

    (88) string_comparison -> LPAREN string comp_op string . RPAREN
    (87) string_comparison -> string comp_op string .

    RPAREN          shift and go to state 235
    LOGICAL_AND     reduce using rule 87 (string_comparison -> string comp_op string .)
    LOGICAL_OR      reduce using rule 87 (string_comparison -> string comp_op string .)


state 205

    (50) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 236


state 206

    (149) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 237


state 207

    (150) for_statement -> FOR LPAREN assignment SEMICOLON . logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 109
    LOGICAL_NOT     shift and go to state 33
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53

    logic                          shift and go to state 238
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56
    number                         shift and go to state 110
    string                         shift and go to state 111

state 208

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 135


state 209

    (137) map -> MAP_TYPE LESS type COMMA . type GREATER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 168
    DOUBLE_TYPE     shift and go to state 169
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 170
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 171
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    type                           shift and go to state 239

state 210

    (21) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (22) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 240
    $end            reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    LINE_BREAK      reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    PRINT           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    IF              reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    WHILE           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    FOR             reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    IDENTIFIER      reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    FINAL           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    CONST           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    INTEGER_TYPE    reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    DOUBLE_TYPE     reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    BOOLEAN_TYPE    reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    QUEUE_TYPE      reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    STRING_TYPE     reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    ENUM_TYPE       reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    VAR             reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    LIST_TYPE       reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    MAP_TYPE        reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    SET_TYPE        reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    DYNAMIC_TYPE    reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    VOID            reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    RBRACE          reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

  ! SEMICOLON       [ reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .) ]

    arith_op                       shift and go to state 70

state 211

    (24) int_assignment -> number_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (26) int_assignment -> number_type nullable IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    NULL            shift and go to state 241
    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    arithmetic                     shift and go to state 242
    number                         shift and go to state 122

state 212

    (28) string_assignment -> type_string IDENTIFIER ASSIGN concate . SEMICOLON
    (29) string_assignment -> type_string IDENTIFIER ASSIGN concate .
    (79) concate -> concate . PLUS concate

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 243
    $end            reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LINE_BREAK      reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    PRINT           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    IF              reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    WHILE           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    FOR             reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    IDENTIFIER      reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    FINAL           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    CONST           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    INTEGER_TYPE    reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    DOUBLE_TYPE     reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    BOOLEAN_TYPE    reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    QUEUE_TYPE      reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    STRING_TYPE     reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    ENUM_TYPE       reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    VAR             reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LIST_TYPE       reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    MAP_TYPE        reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    SET_TYPE        reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    DYNAMIC_TYPE    reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    VOID            reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    RBRACE          reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    PLUS            shift and go to state 74

  ! SEMICOLON       [ reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .) ]


state 213

    (31) string_assignment -> type_string nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (33) string_assignment -> type_string nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    NULL            shift and go to state 244
    LPAREN          shift and go to state 126
    STRING          shift and go to state 53

    concate                        shift and go to state 245
    string                         shift and go to state 125

state 214

    (139) map_assigment -> map IDENTIFIER ASSIGN LBRACE . RBRACE SEMICOLON
    (140) map_assigment -> map IDENTIFIER ASSIGN LBRACE . map_values RBRACE SEMICOLON
    (141) map_values -> . type COLON type
    (142) map_values -> . type COLON type COMMA map_values
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    RBRACE          shift and go to state 246
    INTEGER_TYPE    shift and go to state 168
    DOUBLE_TYPE     shift and go to state 169
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 170
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 171
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    map_values                     shift and go to state 247
    type                           shift and go to state 248

state 215

    (52) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    WHILE           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FOR             reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 216

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 24
    LOGICAL_NOT     shift and go to state 33
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52
    STRING          shift and go to state 53
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58

    expression                     shift and go to state 249
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 30
    string                         shift and go to state 31
    comparison                     shift and go to state 32
    int_comparison                 shift and go to state 54
    string_comparison              shift and go to state 55
    boolean                        shift and go to state 56

state 217

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 250


state 218

    (23) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (25) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    NULL            shift and go to state 251
    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 51
    DOUBLE          shift and go to state 52

    arithmetic                     shift and go to state 252
    number                         shift and go to state 122

state 219

    (27) int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    SEMICOLON       shift and go to state 253
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 220

    (30) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (32) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    NULL            shift and go to state 254
    LPAREN          shift and go to state 126
    STRING          shift and go to state 53

    concate                        shift and go to state 255
    string                         shift and go to state 125

state 221

    (34) string_assignment -> modifier type_string IDENTIFIER ASSIGN concate . SEMICOLON
    (79) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 256
    PLUS            shift and go to state 74


state 222

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 257


state 223

    (15) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 224

    (135) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 135 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 135 (parameter -> type IDENTIFIER .)


state 225

    (117) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 258


state 226

    (133) parameters -> parameter COMMA . parameters
    (131) parameters -> . VOID
    (132) parameters -> . parameter
    (133) parameters -> . parameter COMMA parameters
    (134) parameters -> .
    (135) parameter -> . type IDENTIFIER
    (136) parameter -> . IDENTIFIER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    VOID            shift and go to state 189
    RPAREN          reduce using rule 134 (parameters -> .)
    IDENTIFIER      shift and go to state 187
    INTEGER_TYPE    shift and go to state 168
    DOUBLE_TYPE     shift and go to state 169
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 170
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 171
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46

    parameter                      shift and go to state 190
    parameters                     shift and go to state 259
    type                           shift and go to state 186

state 227

    (53) function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    WHILE           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FINAL           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    CONST           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VOID            reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RBRACE          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RPAREN          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)


state 228

    (105) values -> value COMMA values .

    RPAREN          reduce using rule 105 (values -> value COMMA values .)
    RSQUARE         reduce using rule 105 (values -> value COMMA values .)


state 229

    (116) list -> LSQUARE values RSQUARE .

    COMMA           reduce using rule 116 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 116 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 116 (list -> LSQUARE values RSQUARE .)


state 230

    (48) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 231

    (76) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LINE_BREAK      reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    PRINT           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IF              reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    WHILE           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FOR             reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FINAL           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    CONST           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER_TYPE    reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE_TYPE     reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    QUEUE_TYPE      reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING_TYPE     reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    ENUM_TYPE       reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VAR             reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LIST_TYPE       reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MAP_TYPE        reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SET_TYPE        reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VOID            reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RBRACE          reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 232

    (80) concate -> LPAREN concate PLUS concate RPAREN .

    PLUS            reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    $end            reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    SEMICOLON       reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    RPAREN          reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    LINE_BREAK      reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    PRINT           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    IF              reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    WHILE           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    FOR             reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    IDENTIFIER      reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    FINAL           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    CONST           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    INTEGER_TYPE    reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    DOUBLE_TYPE     reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    BOOLEAN_TYPE    reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    QUEUE_TYPE      reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    STRING_TYPE     reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    ENUM_TYPE       reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    VAR             reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    LIST_TYPE       reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    MAP_TYPE        reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    SET_TYPE        reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    DYNAMIC_TYPE    reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    VOID            reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    RBRACE          reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)


state 233

    (91) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    LINE_BREAK      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    PRINT           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    IF              reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    WHILE           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    FOR             reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    IDENTIFIER      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    FINAL           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    CONST           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER_TYPE    reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE_TYPE     reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    QUEUE_TYPE      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING_TYPE     reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    ENUM_TYPE       reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    VAR             reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    LIST_TYPE       reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    MAP_TYPE        reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    SET_TYPE        reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    VOID            reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    RBRACE          reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)


state 234

    (85) int_comparison -> LPAREN number comp_op number RPAREN .

    LOGICAL_AND     reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LOGICAL_OR      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    $end            reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    SEMICOLON       reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    RPAREN          reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LINE_BREAK      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    PRINT           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    IF              reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    WHILE           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    FOR             reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    IDENTIFIER      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    FINAL           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    CONST           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    INTEGER_TYPE    reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    DOUBLE_TYPE     reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    BOOLEAN_TYPE    reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    QUEUE_TYPE      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    STRING_TYPE     reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    ENUM_TYPE       reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    VAR             reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LIST_TYPE       reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    MAP_TYPE        reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    SET_TYPE        reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    DYNAMIC_TYPE    reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    VOID            reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    RBRACE          reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)


state 235

    (88) string_comparison -> LPAREN string comp_op string RPAREN .

    LOGICAL_AND     reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LOGICAL_OR      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    $end            reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    SEMICOLON       reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    RPAREN          reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LINE_BREAK      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    PRINT           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    IF              reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    WHILE           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    FOR             reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    IDENTIFIER      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    FINAL           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    CONST           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    INTEGER_TYPE    reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    DOUBLE_TYPE     reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    BOOLEAN_TYPE    reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    QUEUE_TYPE      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    STRING_TYPE     reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    ENUM_TYPE       reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    VAR             reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LIST_TYPE       reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    MAP_TYPE        reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    SET_TYPE        reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    DYNAMIC_TYPE    reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    VOID            reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    RBRACE          reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)


state 236

    (50) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    lines                          shift and go to state 260
    line                           shift and go to state 28
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 237

    (149) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    lines                          shift and go to state 261
    line                           shift and go to state 28
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 238

    (150) for_statement -> FOR LPAREN assignment SEMICOLON logic . SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 262
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 239

    (137) map -> MAP_TYPE LESS type COMMA type . GREATER

    GREATER         shift and go to state 263


state 240

    (21) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 241

    (24) int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 264


state 242

    (26) int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    SEMICOLON       shift and go to state 265
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 243

    (28) string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)


state 244

    (31) string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 266


state 245

    (33) string_assignment -> type_string nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (79) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 267
    PLUS            shift and go to state 74


state 246

    (139) map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 268


state 247

    (140) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values . RBRACE SEMICOLON

    RBRACE          shift and go to state 269


state 248

    (141) map_values -> type . COLON type
    (142) map_values -> type . COLON type COMMA map_values

    COLON           shift and go to state 270


state 249

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 271


state 250

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 251

    (23) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 272


state 252

    (25) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    SEMICOLON       shift and go to state 273
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 253

    (27) int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 254

    (30) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 274


state 255

    (32) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (79) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 275
    PLUS            shift and go to state 74


state 256

    (34) string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)


state 257

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 258

    (117) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    type                           shift and go to state 18
    lines                          shift and go to state 276
    line                           shift and go to state 28
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 259

    (133) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 133 (parameters -> parameter COMMA parameters .)


state 260

    (50) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 277


state 261

    (149) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 278


state 262

    (150) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON . reassignment RPAREN LBRACE lines RBRACE
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH

    IDENTIFIER      shift and go to state 280

    reassignment                   shift and go to state 279

state 263

    (137) map -> MAP_TYPE LESS type COMMA type GREATER .

    IDENTIFIER      reduce using rule 137 (map -> MAP_TYPE LESS type COMMA type GREATER .)


state 264

    (24) int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 265

    (26) int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 266

    (31) string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 267

    (33) string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 268

    (139) map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .

    $end            reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    PRINT           reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IF              reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    WHILE           reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FOR             reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FINAL           reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    CONST           reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VAR             reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VOID            reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    RBRACE          reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 139 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)


state 269

    (140) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 281


state 270

    (141) map_values -> type COLON . type
    (142) map_values -> type COLON . type COMMA map_values
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 168
    DOUBLE_TYPE     shift and go to state 169
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 170
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 171
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    type                           shift and go to state 282

state 271

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 272

    (23) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 273

    (25) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 274

    (30) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 275

    (32) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 276

    (117) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 283


state 277

    (50) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 278

    (149) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 149 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 279

    (150) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 284


state 280

    (40) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (43) reassignment -> IDENTIFIER . INLINE_ARITH number
    (44) reassignment -> IDENTIFIER . INLINE_ARITH

    ASSIGN          shift and go to state 85
    INLINE_ARITH    shift and go to state 86


state 281

    (140) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .

    $end            reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    PRINT           reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IF              reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    WHILE           reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FOR             reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FINAL           reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    CONST           reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VAR             reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VOID            reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    RBRACE          reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 140 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)


state 282

    (141) map_values -> type COLON type .
    (142) map_values -> type COLON type . COMMA map_values

    RBRACE          reduce using rule 141 (map_values -> type COLON type .)
    COMMA           shift and go to state 285


state 283

    (117) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 117 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 284

    (150) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 286


state 285

    (142) map_values -> type COLON type COMMA . map_values
    (141) map_values -> . type COLON type
    (142) map_values -> . type COLON type COMMA map_values
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 168
    DOUBLE_TYPE     shift and go to state 169
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 170
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 171
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 81
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    type                           shift and go to state 248
    map_values                     shift and go to state 287

state 286

    (150) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE . lines RBRACE
    (118) lines -> . line LINE_BREAK lines
    (119) lines -> . line lines
    (120) lines -> . line
    (121) lines -> . LINE_BREAK
    (122) lines -> .
    (123) line -> . print
    (124) line -> . assignment
    (125) line -> . function
    (126) line -> . if_statement
    (127) line -> . while_statement
    (128) line -> . for_statement
    (129) line -> . function_call
    (130) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> .
    (20) assignment -> . map_assigment
    (117) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (149) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (150) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (139) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (140) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (137) map -> . MAP_TYPE LESS type COMMA type GREATER
    (138) map -> . MAP_TYPE

  ! shift/reduce conflict for LINE_BREAK resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (assignment -> .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOLEAN_TYPE resolved as shift
  ! shift/reduce conflict for QUEUE_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for ENUM_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for DYNAMIC_TYPE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LINE_BREAK      shift and go to state 29
    PRINT           shift and go to state 23
    RBRACE          reduce using rule 19 (assignment -> .)
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! RBRACE          [ reduce using rule 122 (lines -> .) ]
  ! LINE_BREAK      [ reduce using rule 19 (assignment -> .) ]
  ! PRINT           [ reduce using rule 19 (assignment -> .) ]
  ! IF              [ reduce using rule 19 (assignment -> .) ]
  ! WHILE           [ reduce using rule 19 (assignment -> .) ]
  ! FOR             [ reduce using rule 19 (assignment -> .) ]
  ! IDENTIFIER      [ reduce using rule 19 (assignment -> .) ]
  ! FINAL           [ reduce using rule 19 (assignment -> .) ]
  ! CONST           [ reduce using rule 19 (assignment -> .) ]
  ! INTEGER_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! QUEUE_TYPE      [ reduce using rule 19 (assignment -> .) ]
  ! STRING_TYPE     [ reduce using rule 19 (assignment -> .) ]
  ! ENUM_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! VAR             [ reduce using rule 19 (assignment -> .) ]
  ! LIST_TYPE       [ reduce using rule 19 (assignment -> .) ]
  ! MAP_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! SET_TYPE        [ reduce using rule 19 (assignment -> .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 19 (assignment -> .) ]
  ! VOID            [ reduce using rule 19 (assignment -> .) ]

    assignment                     shift and go to state 62
    reassignment                   shift and go to state 68
    lines                          shift and go to state 288
    line                           shift and go to state 28
    print                          shift and go to state 61
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    map_assigment                  shift and go to state 22
    number_type                    shift and go to state 48
    type_string                    shift and go to state 49
    map                            shift and go to state 50

state 287

    (142) map_values -> type COLON type COMMA map_values .

    RBRACE          reduce using rule 142 (map_values -> type COLON type COMMA map_values .)


state 288

    (150) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 289


state 289

    (150) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 150 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 0 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 10 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 10 resolved as shift
WARNING: shift/reduce conflict for IF in state 10 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 10 resolved as shift
WARNING: shift/reduce conflict for FOR in state 10 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 10 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 10 resolved as shift
WARNING: shift/reduce conflict for CONST in state 10 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for VAR in state 10 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 10 resolved as shift
WARNING: shift/reduce conflict for VOID in state 10 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 28 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 28 resolved as shift
WARNING: shift/reduce conflict for IF in state 28 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 28 resolved as shift
WARNING: shift/reduce conflict for FOR in state 28 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 28 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 28 resolved as shift
WARNING: shift/reduce conflict for CONST in state 28 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for VAR in state 28 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 28 resolved as shift
WARNING: shift/reduce conflict for VOID in state 28 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 97 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 97 resolved as shift
WARNING: shift/reduce conflict for IF in state 97 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 97 resolved as shift
WARNING: shift/reduce conflict for FOR in state 97 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 97 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 97 resolved as shift
WARNING: shift/reduce conflict for CONST in state 97 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for VAR in state 97 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 97 resolved as shift
WARNING: shift/reduce conflict for VOID in state 97 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 108 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 118 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 119 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 119 resolved as shift
WARNING: shift/reduce conflict for IF in state 119 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 119 resolved as shift
WARNING: shift/reduce conflict for FOR in state 119 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 119 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 119 resolved as shift
WARNING: shift/reduce conflict for CONST in state 119 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for VAR in state 119 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 119 resolved as shift
WARNING: shift/reduce conflict for VOID in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 124 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 127 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 127 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 144 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 185 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 193 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 200 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 200 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 200 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 201 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 202 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 202 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 210 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 212 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 236 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 236 resolved as shift
WARNING: shift/reduce conflict for IF in state 236 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 236 resolved as shift
WARNING: shift/reduce conflict for FOR in state 236 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 236 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 236 resolved as shift
WARNING: shift/reduce conflict for CONST in state 236 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for VAR in state 236 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for VOID in state 236 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 237 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 237 resolved as shift
WARNING: shift/reduce conflict for IF in state 237 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 237 resolved as shift
WARNING: shift/reduce conflict for FOR in state 237 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 237 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 237 resolved as shift
WARNING: shift/reduce conflict for CONST in state 237 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for VAR in state 237 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 237 resolved as shift
WARNING: shift/reduce conflict for VOID in state 237 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 258 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 258 resolved as shift
WARNING: shift/reduce conflict for IF in state 258 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 258 resolved as shift
WARNING: shift/reduce conflict for FOR in state 258 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 258 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 258 resolved as shift
WARNING: shift/reduce conflict for CONST in state 258 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for VAR in state 258 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 258 resolved as shift
WARNING: shift/reduce conflict for VOID in state 258 resolved as shift
WARNING: shift/reduce conflict for LINE_BREAK in state 286 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 286 resolved as shift
WARNING: shift/reduce conflict for IF in state 286 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 286 resolved as shift
WARNING: shift/reduce conflict for FOR in state 286 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 286 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 286 resolved as shift
WARNING: shift/reduce conflict for CONST in state 286 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for QUEUE_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for ENUM_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for VAR in state 286 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for DYNAMIC_TYPE in state 286 resolved as shift
WARNING: shift/reduce conflict for VOID in state 286 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (assignment -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (statement -> while_statement)
WARNING: rejected rule (line -> while_statement) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (statement -> for_statement)
WARNING: rejected rule (line -> for_statement) in state 8
WARNING: reduce/reduce conflict in state 10 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 10
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> reassignment)
WARNING: rejected rule (line -> reassignment) in state 11
WARNING: reduce/reduce conflict in state 15 resolved using rule (expression -> function_call)
WARNING: rejected rule (line -> function_call) in state 15
WARNING: reduce/reduce conflict in state 28 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 28
WARNING: reduce/reduce conflict in state 28 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> line) in state 28
WARNING: reduce/reduce conflict in state 36 resolved using rule (number_type -> INTEGER_TYPE)
WARNING: rejected rule (type -> INTEGER_TYPE) in state 36
WARNING: reduce/reduce conflict in state 37 resolved using rule (number_type -> DOUBLE_TYPE)
WARNING: rejected rule (type -> DOUBLE_TYPE) in state 37
WARNING: reduce/reduce conflict in state 40 resolved using rule (type_string -> STRING_TYPE)
WARNING: rejected rule (type -> STRING_TYPE) in state 40
WARNING: reduce/reduce conflict in state 42 resolved using rule (number_type -> VAR)
WARNING: rejected rule (type -> VAR) in state 42
WARNING: reduce/reduce conflict in state 42 resolved using rule (number_type -> VAR)
WARNING: rejected rule (type_string -> VAR) in state 42
WARNING: reduce/reduce conflict in state 44 resolved using rule (type -> MAP_TYPE)
WARNING: rejected rule (map -> MAP_TYPE) in state 44
WARNING: reduce/reduce conflict in state 56 resolved using rule (int_comparison -> boolean)
WARNING: rejected rule (string_comparison -> boolean) in state 56
WARNING: reduce/reduce conflict in state 97 resolved using rule (lines -> LINE_BREAK)
WARNING: rejected rule (lines -> <empty>) in state 97
WARNING: reduce/reduce conflict in state 97 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> LINE_BREAK) in state 97
WARNING: reduce/reduce conflict in state 119 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 119
WARNING: reduce/reduce conflict in state 236 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 236
WARNING: reduce/reduce conflict in state 237 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 237
WARNING: reduce/reduce conflict in state 258 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 258
WARNING: reduce/reduce conflict in state 286 resolved using rule (assignment -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 286
WARNING: Rule (lines -> <empty>) is never reduced
WARNING: Rule (lines -> line) is never reduced
WARNING: Rule (type_string -> VAR) is never reduced
WARNING: Rule (map -> MAP_TYPE) is never reduced
WARNING: Rule (string_comparison -> boolean) is never reduced
