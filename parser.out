Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOT
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FINALLY
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    IN
    INTERFACE
    IS
    KEYWORD
    LIBRARY
    NULL
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> reassignment
Rule 11    statement -> <empty>
Rule 12    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 16    assignment -> type IDENTIFIER ASSIGN expression
Rule 17    reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 18    reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 19    reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 20    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 21    reassignment -> IDENTIFIER INLINE_ARITH
Rule 22    nullable -> QUESTION_MARK
Rule 23    modifier -> LATE
Rule 24    modifier -> FINAL
Rule 25    modifier -> CONST
Rule 26    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 27    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 28    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 29    if_statement -> if_statement ELSE if_statement
Rule 30    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 31    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 32    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 33    function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON
Rule 34    function_call -> IDENTIFIER LPAREN RPAREN
Rule 35    type -> INTEGER_TYPE
Rule 36    type -> DOUBLE_TYPE
Rule 37    type -> BOOLEAN_TYPE
Rule 38    type -> QUEUE_TYPE
Rule 39    type -> STRING_TYPE
Rule 40    type -> ENUM_TYPE
Rule 41    type -> VAR
Rule 42    type -> LIST_TYPE
Rule 43    type -> MAP_TYPE
Rule 44    type -> SET_TYPE
Rule 45    type -> DYNAMIC_TYPE
Rule 46    type -> VOID
Rule 47    expression -> arithmetic
Rule 48    expression -> logic
Rule 49    expression -> function_call
Rule 50    arithmetic -> value
Rule 51    arithmetic -> arithmetic arith_op arithmetic
Rule 52    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 53    comparison -> value
Rule 54    comparison -> boolean
Rule 55    comparison -> comparison comp_op comparison
Rule 56    comparison -> LPAREN comparison comp_op comparison RPAREN
Rule 57    logic -> comparison
Rule 58    logic -> logic logic_op logic
Rule 59    logic -> LPAREN logic logic_op logic RPAREN
Rule 60    logic -> LOGICAL_NOT logic
Rule 61    logic_op -> LOGICAL_AND
Rule 62    logic_op -> LOGICAL_OR
Rule 63    arith_op -> PLUS
Rule 64    arith_op -> MINUS
Rule 65    arith_op -> TIMES
Rule 66    arith_op -> DIVIDE
Rule 67    comp_op -> EQUAL
Rule 68    comp_op -> NOT_EQUAL
Rule 69    comp_op -> LESS
Rule 70    comp_op -> LESS_EQUAL
Rule 71    comp_op -> GREATER
Rule 72    comp_op -> GREATER_EQUAL
Rule 73    values -> value
Rule 74    values -> value COMMA values
Rule 75    value -> IDENTIFIER
Rule 76    value -> number
Rule 77    value -> string
Rule 78    value -> list
Rule 79    number -> INTEGER
Rule 80    number -> DOUBLE
Rule 81    string -> STRING
Rule 82    boolean -> TRUE
Rule 83    boolean -> FALSE
Rule 84    list -> LSQUARE RSQUARE
Rule 85    list -> LSQUARE values RSQUARE
Rule 86    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 87    lines -> line LINE_BREAK lines
Rule 88    lines -> line lines
Rule 89    lines -> line
Rule 90    lines -> LINE_BREAK
Rule 91    lines -> <empty>
Rule 92    line -> print
Rule 93    line -> assignment
Rule 94    line -> function
Rule 95    line -> if_statement
Rule 96    line -> while_statement
Rule 97    line -> for_statement
Rule 98    line -> function_call
Rule 99    line -> reassignment
Rule 100   parameters -> VOID
Rule 101   parameters -> parameter
Rule 102   parameters -> parameter COMMA parameters
Rule 103   parameters -> <empty>
Rule 104   parameter -> type IDENTIFIER
Rule 105   parameter -> IDENTIFIER
Rule 106   map -> MAP_TYPE LESS type COMMA type GREATER
Rule 107   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE values RSQUARE
Rule 108   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE RSQUARE
Rule 109   set -> SET_TYPE LESS type GREATER
Rule 110   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 111   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 112   queue -> QUEUE_TYPE LESS type GREATER
Rule 113   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 114   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 115   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 116   for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
AS                   : 
ASSERT               : 
ASSIGN               : 12 13 14 15 16 17
ASYNC                : 
AWAIT                : 
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 37
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 74 102 106 107 108
COMMENT              : 
CONST                : 25
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 66
DO                   : 
DOT                  : 
DOUBLE               : 80
DOUBLE_TYPE          : 36
DYNAMIC_TYPE         : 45
ELSE                 : 29 30
ENUM                 : 
ENUM_TYPE            : 40
EQUAL                : 67
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FALSE                : 83
FINAL                : 24
FINALLY              : 
FOR                  : 116
GET                  : 
GREATER              : 71 106 107 108 109 110 111 112 113 114
GREATER_EQUAL        : 72
HIDE                 : 
IDENTIFIER           : 12 13 14 15 16 17 18 19 20 21 31 32 33 34 75 86 104 105
IF                   : 28
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INLINE_ARITH         : 18 19 20 21
INTEGER              : 79
INTEGER_TYPE         : 35
INTERFACE            : 
IS                   : 
KEYWORD              : 
LATE                 : 23
LBRACE               : 9 28 30 86 115 116
LESS                 : 69 106 107 108 109 110 111 112 113 114
LESS_EQUAL           : 70
LIBRARY              : 
LINE_BREAK           : 87 90
LIST_TYPE            : 42
LOGICAL_AND          : 61
LOGICAL_NOT          : 60
LOGICAL_OR           : 62
LPAREN               : 26 27 28 31 32 33 34 52 56 59 86 115 116
LSQUARE              : 84 85 107 108 110 111 113 114
MAP_TYPE             : 43 106 107 108
MINUS                : 64
NOT_EQUAL            : 68
NULL                 : 
ON                   : 
OPERATOR             : 
PART                 : 
PLUS                 : 63
PRINT                : 26 27
QUESTION_MARK        : 22
QUEUE_TYPE           : 38 112 113 114
RBRACE               : 9 28 30 86 115 116
RETHROW              : 
RETURN               : 
RPAREN               : 26 27 28 31 32 33 34 52 56 59 86 115 116
RSQUARE              : 84 85 107 108 110 111 113 114
SEMICOLON            : 12 13 14 15 17 18 19 26 27 31 33 116
SET                  : 
SET_TYPE             : 44 109 110 111
SHOW                 : 
STATIC               : 
STRING               : 81
STRING_TYPE          : 39
SUPER                : 
SWITCH               : 
SYNC                 : 
THROW                : 
TIMES                : 65
TRUE                 : 82
TRY                  : 
TYPEDEF              : 
VAR                  : 41
VOID                 : 46 100
WHILE                : 115
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 51 52
arithmetic           : 47 51 51 52 52
assignment           : 2 93 116
boolean              : 54
comp_op              : 55 56
comparison           : 55 55 56 56 57
expression           : 1 12 13 14 15 16 17 26
for_statement        : 7 97
function             : 4 94
function_call        : 49 98
if_statement         : 5 29 29 30 95
line                 : 87 88 89
lines                : 8 9 28 30 86 87 88 115 116
list                 : 78
logic                : 28 48 58 58 59 59 60 115 116
logic_op             : 58 59
map                  : 
modifier             : 12 14
nullable             : 12 13
number               : 18 20 76
parameter            : 101 102
parameters           : 86 102
print                : 3 92
queue                : 
reassignment         : 10 99 116
set                  : 
statement            : 0
string               : 77
type                 : 12 13 14 15 16 86 104 106 106 107 107 108 108 109 110 111 112 113 114
value                : 50 53 73 74
values               : 31 32 74 85 107 110 113
while_statement      : 6 96

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> . reassignment
    (11) statement -> .
    (47) expression -> . arithmetic
    (48) expression -> . logic
    (49) expression -> . function_call
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE

  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
    LBRACE          shift and go to state 10
    $end            reduce using rule 11 (statement -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    LINE_BREAK      shift and go to state 24
    IDENTIFIER      shift and go to state 17
    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

  ! $end            [ reduce using rule 91 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    reassignment                   shift and go to state 11
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 14
    modifier                       shift and go to state 15
    type                           shift and go to state 16
    line                           shift and go to state 23
    number                         shift and go to state 25
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (93) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 93 (line -> assignment .)
    PRINT           reduce using rule 93 (line -> assignment .)
    IF              reduce using rule 93 (line -> assignment .)
    WHILE           reduce using rule 93 (line -> assignment .)
    FOR             reduce using rule 93 (line -> assignment .)
    IDENTIFIER      reduce using rule 93 (line -> assignment .)
    LATE            reduce using rule 93 (line -> assignment .)
    FINAL           reduce using rule 93 (line -> assignment .)
    CONST           reduce using rule 93 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 93 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 93 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 93 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 93 (line -> assignment .)
    STRING_TYPE     reduce using rule 93 (line -> assignment .)
    ENUM_TYPE       reduce using rule 93 (line -> assignment .)
    VAR             reduce using rule 93 (line -> assignment .)
    LIST_TYPE       reduce using rule 93 (line -> assignment .)
    MAP_TYPE        reduce using rule 93 (line -> assignment .)
    SET_TYPE        reduce using rule 93 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 93 (line -> assignment .)
    VOID            reduce using rule 93 (line -> assignment .)

  ! $end            [ reduce using rule 93 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (92) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 92 (line -> print .)
    PRINT           reduce using rule 92 (line -> print .)
    IF              reduce using rule 92 (line -> print .)
    WHILE           reduce using rule 92 (line -> print .)
    FOR             reduce using rule 92 (line -> print .)
    IDENTIFIER      reduce using rule 92 (line -> print .)
    LATE            reduce using rule 92 (line -> print .)
    FINAL           reduce using rule 92 (line -> print .)
    CONST           reduce using rule 92 (line -> print .)
    INTEGER_TYPE    reduce using rule 92 (line -> print .)
    DOUBLE_TYPE     reduce using rule 92 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 92 (line -> print .)
    QUEUE_TYPE      reduce using rule 92 (line -> print .)
    STRING_TYPE     reduce using rule 92 (line -> print .)
    ENUM_TYPE       reduce using rule 92 (line -> print .)
    VAR             reduce using rule 92 (line -> print .)
    LIST_TYPE       reduce using rule 92 (line -> print .)
    MAP_TYPE        reduce using rule 92 (line -> print .)
    SET_TYPE        reduce using rule 92 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 92 (line -> print .)
    VOID            reduce using rule 92 (line -> print .)

  ! $end            [ reduce using rule 92 (line -> print .) ]


state 5

    (4) statement -> function .
    (94) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 94 (line -> function .)
    PRINT           reduce using rule 94 (line -> function .)
    IF              reduce using rule 94 (line -> function .)
    WHILE           reduce using rule 94 (line -> function .)
    FOR             reduce using rule 94 (line -> function .)
    IDENTIFIER      reduce using rule 94 (line -> function .)
    LATE            reduce using rule 94 (line -> function .)
    FINAL           reduce using rule 94 (line -> function .)
    CONST           reduce using rule 94 (line -> function .)
    INTEGER_TYPE    reduce using rule 94 (line -> function .)
    DOUBLE_TYPE     reduce using rule 94 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 94 (line -> function .)
    QUEUE_TYPE      reduce using rule 94 (line -> function .)
    STRING_TYPE     reduce using rule 94 (line -> function .)
    ENUM_TYPE       reduce using rule 94 (line -> function .)
    VAR             reduce using rule 94 (line -> function .)
    LIST_TYPE       reduce using rule 94 (line -> function .)
    MAP_TYPE        reduce using rule 94 (line -> function .)
    SET_TYPE        reduce using rule 94 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 94 (line -> function .)
    VOID            reduce using rule 94 (line -> function .)

  ! $end            [ reduce using rule 94 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (29) if_statement -> if_statement . ELSE if_statement
    (30) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (95) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 53
    LINE_BREAK      reduce using rule 95 (line -> if_statement .)
    PRINT           reduce using rule 95 (line -> if_statement .)
    IF              reduce using rule 95 (line -> if_statement .)
    WHILE           reduce using rule 95 (line -> if_statement .)
    FOR             reduce using rule 95 (line -> if_statement .)
    IDENTIFIER      reduce using rule 95 (line -> if_statement .)
    LATE            reduce using rule 95 (line -> if_statement .)
    FINAL           reduce using rule 95 (line -> if_statement .)
    CONST           reduce using rule 95 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 95 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 95 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 95 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 95 (line -> if_statement .)
    STRING_TYPE     reduce using rule 95 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 95 (line -> if_statement .)
    VAR             reduce using rule 95 (line -> if_statement .)
    LIST_TYPE       reduce using rule 95 (line -> if_statement .)
    MAP_TYPE        reduce using rule 95 (line -> if_statement .)
    SET_TYPE        reduce using rule 95 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 95 (line -> if_statement .)
    VOID            reduce using rule 95 (line -> if_statement .)

  ! $end            [ reduce using rule 95 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .
    (96) line -> while_statement .

  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> while_statement .)
    $end            reduce using rule 6 (statement -> while_statement .)
    LINE_BREAK      reduce using rule 96 (line -> while_statement .)
    PRINT           reduce using rule 96 (line -> while_statement .)
    IF              reduce using rule 96 (line -> while_statement .)
    WHILE           reduce using rule 96 (line -> while_statement .)
    FOR             reduce using rule 96 (line -> while_statement .)
    IDENTIFIER      reduce using rule 96 (line -> while_statement .)
    LATE            reduce using rule 96 (line -> while_statement .)
    FINAL           reduce using rule 96 (line -> while_statement .)
    CONST           reduce using rule 96 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 96 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 96 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 96 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 96 (line -> while_statement .)
    STRING_TYPE     reduce using rule 96 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 96 (line -> while_statement .)
    VAR             reduce using rule 96 (line -> while_statement .)
    LIST_TYPE       reduce using rule 96 (line -> while_statement .)
    MAP_TYPE        reduce using rule 96 (line -> while_statement .)
    SET_TYPE        reduce using rule 96 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 96 (line -> while_statement .)
    VOID            reduce using rule 96 (line -> while_statement .)

  ! $end            [ reduce using rule 96 (line -> while_statement .) ]


state 8

    (7) statement -> for_statement .
    (97) line -> for_statement .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    LINE_BREAK      reduce using rule 97 (line -> for_statement .)
    PRINT           reduce using rule 97 (line -> for_statement .)
    IF              reduce using rule 97 (line -> for_statement .)
    WHILE           reduce using rule 97 (line -> for_statement .)
    FOR             reduce using rule 97 (line -> for_statement .)
    IDENTIFIER      reduce using rule 97 (line -> for_statement .)
    LATE            reduce using rule 97 (line -> for_statement .)
    FINAL           reduce using rule 97 (line -> for_statement .)
    CONST           reduce using rule 97 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 97 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 97 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 97 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 97 (line -> for_statement .)
    STRING_TYPE     reduce using rule 97 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 97 (line -> for_statement .)
    VAR             reduce using rule 97 (line -> for_statement .)
    LIST_TYPE       reduce using rule 97 (line -> for_statement .)
    MAP_TYPE        reduce using rule 97 (line -> for_statement .)
    SET_TYPE        reduce using rule 97 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 97 (line -> for_statement .)
    VOID            reduce using rule 97 (line -> for_statement .)

  ! $end            [ reduce using rule 97 (line -> for_statement .) ]


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 91 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    lines                          shift and go to state 54
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 11

    (10) statement -> reassignment .
    (99) line -> reassignment .

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> reassignment .)
    $end            reduce using rule 10 (statement -> reassignment .)
    LINE_BREAK      reduce using rule 99 (line -> reassignment .)
    PRINT           reduce using rule 99 (line -> reassignment .)
    IF              reduce using rule 99 (line -> reassignment .)
    WHILE           reduce using rule 99 (line -> reassignment .)
    FOR             reduce using rule 99 (line -> reassignment .)
    IDENTIFIER      reduce using rule 99 (line -> reassignment .)
    LATE            reduce using rule 99 (line -> reassignment .)
    FINAL           reduce using rule 99 (line -> reassignment .)
    CONST           reduce using rule 99 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 99 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 99 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 99 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 99 (line -> reassignment .)
    STRING_TYPE     reduce using rule 99 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 99 (line -> reassignment .)
    VAR             reduce using rule 99 (line -> reassignment .)
    LIST_TYPE       reduce using rule 99 (line -> reassignment .)
    MAP_TYPE        reduce using rule 99 (line -> reassignment .)
    SET_TYPE        reduce using rule 99 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 99 (line -> reassignment .)
    VOID            reduce using rule 99 (line -> reassignment .)

  ! $end            [ reduce using rule 99 (line -> reassignment .) ]


state 12

    (47) expression -> arithmetic .
    (51) arithmetic -> arithmetic . arith_op arithmetic
    (63) arith_op -> . PLUS
    (64) arith_op -> . MINUS
    (65) arith_op -> . TIMES
    (66) arith_op -> . DIVIDE

    $end            reduce using rule 47 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 47 (expression -> arithmetic .)
    RPAREN          reduce using rule 47 (expression -> arithmetic .)
    LINE_BREAK      reduce using rule 47 (expression -> arithmetic .)
    PRINT           reduce using rule 47 (expression -> arithmetic .)
    IF              reduce using rule 47 (expression -> arithmetic .)
    WHILE           reduce using rule 47 (expression -> arithmetic .)
    FOR             reduce using rule 47 (expression -> arithmetic .)
    IDENTIFIER      reduce using rule 47 (expression -> arithmetic .)
    LATE            reduce using rule 47 (expression -> arithmetic .)
    FINAL           reduce using rule 47 (expression -> arithmetic .)
    CONST           reduce using rule 47 (expression -> arithmetic .)
    INTEGER_TYPE    reduce using rule 47 (expression -> arithmetic .)
    DOUBLE_TYPE     reduce using rule 47 (expression -> arithmetic .)
    BOOLEAN_TYPE    reduce using rule 47 (expression -> arithmetic .)
    QUEUE_TYPE      reduce using rule 47 (expression -> arithmetic .)
    STRING_TYPE     reduce using rule 47 (expression -> arithmetic .)
    ENUM_TYPE       reduce using rule 47 (expression -> arithmetic .)
    VAR             reduce using rule 47 (expression -> arithmetic .)
    LIST_TYPE       reduce using rule 47 (expression -> arithmetic .)
    MAP_TYPE        reduce using rule 47 (expression -> arithmetic .)
    SET_TYPE        reduce using rule 47 (expression -> arithmetic .)
    DYNAMIC_TYPE    reduce using rule 47 (expression -> arithmetic .)
    VOID            reduce using rule 47 (expression -> arithmetic .)
    RBRACE          reduce using rule 47 (expression -> arithmetic .)
    LPAREN          reduce using rule 47 (expression -> arithmetic .)
    LOGICAL_NOT     reduce using rule 47 (expression -> arithmetic .)
    TRUE            reduce using rule 47 (expression -> arithmetic .)
    FALSE           reduce using rule 47 (expression -> arithmetic .)
    INTEGER         reduce using rule 47 (expression -> arithmetic .)
    DOUBLE          reduce using rule 47 (expression -> arithmetic .)
    STRING          reduce using rule 47 (expression -> arithmetic .)
    LSQUARE         reduce using rule 47 (expression -> arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

    arith_op                       shift and go to state 64

state 13

    (48) expression -> logic .
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

    $end            reduce using rule 48 (expression -> logic .)
    SEMICOLON       reduce using rule 48 (expression -> logic .)
    RPAREN          reduce using rule 48 (expression -> logic .)
    LINE_BREAK      reduce using rule 48 (expression -> logic .)
    PRINT           reduce using rule 48 (expression -> logic .)
    IF              reduce using rule 48 (expression -> logic .)
    WHILE           reduce using rule 48 (expression -> logic .)
    FOR             reduce using rule 48 (expression -> logic .)
    IDENTIFIER      reduce using rule 48 (expression -> logic .)
    LATE            reduce using rule 48 (expression -> logic .)
    FINAL           reduce using rule 48 (expression -> logic .)
    CONST           reduce using rule 48 (expression -> logic .)
    INTEGER_TYPE    reduce using rule 48 (expression -> logic .)
    DOUBLE_TYPE     reduce using rule 48 (expression -> logic .)
    BOOLEAN_TYPE    reduce using rule 48 (expression -> logic .)
    QUEUE_TYPE      reduce using rule 48 (expression -> logic .)
    STRING_TYPE     reduce using rule 48 (expression -> logic .)
    ENUM_TYPE       reduce using rule 48 (expression -> logic .)
    VAR             reduce using rule 48 (expression -> logic .)
    LIST_TYPE       reduce using rule 48 (expression -> logic .)
    MAP_TYPE        reduce using rule 48 (expression -> logic .)
    SET_TYPE        reduce using rule 48 (expression -> logic .)
    DYNAMIC_TYPE    reduce using rule 48 (expression -> logic .)
    VOID            reduce using rule 48 (expression -> logic .)
    RBRACE          reduce using rule 48 (expression -> logic .)
    LPAREN          reduce using rule 48 (expression -> logic .)
    LOGICAL_NOT     reduce using rule 48 (expression -> logic .)
    TRUE            reduce using rule 48 (expression -> logic .)
    FALSE           reduce using rule 48 (expression -> logic .)
    INTEGER         reduce using rule 48 (expression -> logic .)
    DOUBLE          reduce using rule 48 (expression -> logic .)
    STRING          reduce using rule 48 (expression -> logic .)
    LSQUARE         reduce using rule 48 (expression -> logic .)
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 14

    (49) expression -> function_call .
    (98) line -> function_call .

  ! reduce/reduce conflict for $end resolved using rule 49 (expression -> function_call .)
    $end            reduce using rule 49 (expression -> function_call .)
    LINE_BREAK      reduce using rule 98 (line -> function_call .)
    PRINT           reduce using rule 98 (line -> function_call .)
    IF              reduce using rule 98 (line -> function_call .)
    WHILE           reduce using rule 98 (line -> function_call .)
    FOR             reduce using rule 98 (line -> function_call .)
    IDENTIFIER      reduce using rule 98 (line -> function_call .)
    LATE            reduce using rule 98 (line -> function_call .)
    FINAL           reduce using rule 98 (line -> function_call .)
    CONST           reduce using rule 98 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 98 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 98 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 98 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 98 (line -> function_call .)
    STRING_TYPE     reduce using rule 98 (line -> function_call .)
    ENUM_TYPE       reduce using rule 98 (line -> function_call .)
    VAR             reduce using rule 98 (line -> function_call .)
    LIST_TYPE       reduce using rule 98 (line -> function_call .)
    MAP_TYPE        reduce using rule 98 (line -> function_call .)
    SET_TYPE        reduce using rule 98 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 98 (line -> function_call .)
    VOID            reduce using rule 98 (line -> function_call .)

  ! $end            [ reduce using rule 98 (line -> function_call .) ]


state 15

    (12) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    type                           shift and go to state 72

state 16

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (86) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (22) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 74
    QUESTION_MARK   shift and go to state 75

    nullable                       shift and go to state 73

state 17

    (17) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (20) reassignment -> IDENTIFIER . INLINE_ARITH number
    (21) reassignment -> IDENTIFIER . INLINE_ARITH
    (31) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER . LPAREN values RPAREN
    (33) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER . LPAREN RPAREN
    (75) value -> IDENTIFIER .

    ASSIGN          shift and go to state 76
    INLINE_ARITH    shift and go to state 77
    LPAREN          shift and go to state 78
    PLUS            reduce using rule 75 (value -> IDENTIFIER .)
    MINUS           reduce using rule 75 (value -> IDENTIFIER .)
    TIMES           reduce using rule 75 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 75 (value -> IDENTIFIER .)
    $end            reduce using rule 75 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 75 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 75 (value -> IDENTIFIER .)
    LESS            reduce using rule 75 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 75 (value -> IDENTIFIER .)
    GREATER         reduce using rule 75 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 75 (value -> IDENTIFIER .)


state 18

    (26) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (27) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 79


state 19

    (52) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (59) logic -> LPAREN . logic logic_op logic RPAREN
    (56) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 80
    logic                          shift and go to state 81
    comparison                     shift and go to state 82
    value                          shift and go to state 26
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 20

    (28) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 84


state 21

    (115) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 85


state 22

    (116) for_statement -> FOR . LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 86


state 23

    (87) lines -> line . LINE_BREAK lines
    (88) lines -> line . lines
    (89) lines -> line .
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 89 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 89 (lines -> line .)
    LINE_BREAK      shift and go to state 87
    $end            reduce using rule 89 (lines -> line .)
    RBRACE          reduce using rule 89 (lines -> line .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

  ! $end            [ reduce using rule 91 (lines -> .) ]
  ! RBRACE          [ reduce using rule 91 (lines -> .) ]

    line                           shift and go to state 23
    lines                          shift and go to state 88
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 24

    (90) lines -> LINE_BREAK .

    $end            reduce using rule 90 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 90 (lines -> LINE_BREAK .)


state 25

    (76) value -> number .

    PLUS            reduce using rule 76 (value -> number .)
    MINUS           reduce using rule 76 (value -> number .)
    TIMES           reduce using rule 76 (value -> number .)
    DIVIDE          reduce using rule 76 (value -> number .)
    $end            reduce using rule 76 (value -> number .)
    EQUAL           reduce using rule 76 (value -> number .)
    NOT_EQUAL       reduce using rule 76 (value -> number .)
    LESS            reduce using rule 76 (value -> number .)
    LESS_EQUAL      reduce using rule 76 (value -> number .)
    GREATER         reduce using rule 76 (value -> number .)
    GREATER_EQUAL   reduce using rule 76 (value -> number .)
    LOGICAL_AND     reduce using rule 76 (value -> number .)
    LOGICAL_OR      reduce using rule 76 (value -> number .)
    SEMICOLON       reduce using rule 76 (value -> number .)
    RPAREN          reduce using rule 76 (value -> number .)
    LINE_BREAK      reduce using rule 76 (value -> number .)
    PRINT           reduce using rule 76 (value -> number .)
    IF              reduce using rule 76 (value -> number .)
    WHILE           reduce using rule 76 (value -> number .)
    FOR             reduce using rule 76 (value -> number .)
    IDENTIFIER      reduce using rule 76 (value -> number .)
    LATE            reduce using rule 76 (value -> number .)
    FINAL           reduce using rule 76 (value -> number .)
    CONST           reduce using rule 76 (value -> number .)
    INTEGER_TYPE    reduce using rule 76 (value -> number .)
    DOUBLE_TYPE     reduce using rule 76 (value -> number .)
    BOOLEAN_TYPE    reduce using rule 76 (value -> number .)
    QUEUE_TYPE      reduce using rule 76 (value -> number .)
    STRING_TYPE     reduce using rule 76 (value -> number .)
    ENUM_TYPE       reduce using rule 76 (value -> number .)
    VAR             reduce using rule 76 (value -> number .)
    LIST_TYPE       reduce using rule 76 (value -> number .)
    MAP_TYPE        reduce using rule 76 (value -> number .)
    SET_TYPE        reduce using rule 76 (value -> number .)
    DYNAMIC_TYPE    reduce using rule 76 (value -> number .)
    VOID            reduce using rule 76 (value -> number .)
    RBRACE          reduce using rule 76 (value -> number .)
    LPAREN          reduce using rule 76 (value -> number .)
    LOGICAL_NOT     reduce using rule 76 (value -> number .)
    TRUE            reduce using rule 76 (value -> number .)
    FALSE           reduce using rule 76 (value -> number .)
    INTEGER         reduce using rule 76 (value -> number .)
    DOUBLE          reduce using rule 76 (value -> number .)
    STRING          reduce using rule 76 (value -> number .)
    LSQUARE         reduce using rule 76 (value -> number .)
    COMMA           reduce using rule 76 (value -> number .)
    RSQUARE         reduce using rule 76 (value -> number .)


state 26

    (50) arithmetic -> value .
    (53) comparison -> value .

  ! reduce/reduce conflict for $end resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for PRINT resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for IF resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for WHILE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for FOR resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for LATE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for FINAL resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for CONST resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for VAR resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for VOID resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for RBRACE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for LPAREN resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for LOGICAL_NOT resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for TRUE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for FALSE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for INTEGER resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for STRING resolved using rule 50 (arithmetic -> value .)
  ! reduce/reduce conflict for LSQUARE resolved using rule 50 (arithmetic -> value .)
    PLUS            reduce using rule 50 (arithmetic -> value .)
    MINUS           reduce using rule 50 (arithmetic -> value .)
    TIMES           reduce using rule 50 (arithmetic -> value .)
    DIVIDE          reduce using rule 50 (arithmetic -> value .)
    $end            reduce using rule 50 (arithmetic -> value .)
    SEMICOLON       reduce using rule 50 (arithmetic -> value .)
    RPAREN          reduce using rule 50 (arithmetic -> value .)
    LINE_BREAK      reduce using rule 50 (arithmetic -> value .)
    PRINT           reduce using rule 50 (arithmetic -> value .)
    IF              reduce using rule 50 (arithmetic -> value .)
    WHILE           reduce using rule 50 (arithmetic -> value .)
    FOR             reduce using rule 50 (arithmetic -> value .)
    IDENTIFIER      reduce using rule 50 (arithmetic -> value .)
    LATE            reduce using rule 50 (arithmetic -> value .)
    FINAL           reduce using rule 50 (arithmetic -> value .)
    CONST           reduce using rule 50 (arithmetic -> value .)
    INTEGER_TYPE    reduce using rule 50 (arithmetic -> value .)
    DOUBLE_TYPE     reduce using rule 50 (arithmetic -> value .)
    BOOLEAN_TYPE    reduce using rule 50 (arithmetic -> value .)
    QUEUE_TYPE      reduce using rule 50 (arithmetic -> value .)
    STRING_TYPE     reduce using rule 50 (arithmetic -> value .)
    ENUM_TYPE       reduce using rule 50 (arithmetic -> value .)
    VAR             reduce using rule 50 (arithmetic -> value .)
    LIST_TYPE       reduce using rule 50 (arithmetic -> value .)
    MAP_TYPE        reduce using rule 50 (arithmetic -> value .)
    SET_TYPE        reduce using rule 50 (arithmetic -> value .)
    DYNAMIC_TYPE    reduce using rule 50 (arithmetic -> value .)
    VOID            reduce using rule 50 (arithmetic -> value .)
    RBRACE          reduce using rule 50 (arithmetic -> value .)
    LPAREN          reduce using rule 50 (arithmetic -> value .)
    LOGICAL_NOT     reduce using rule 50 (arithmetic -> value .)
    TRUE            reduce using rule 50 (arithmetic -> value .)
    FALSE           reduce using rule 50 (arithmetic -> value .)
    INTEGER         reduce using rule 50 (arithmetic -> value .)
    DOUBLE          reduce using rule 50 (arithmetic -> value .)
    STRING          reduce using rule 50 (arithmetic -> value .)
    LSQUARE         reduce using rule 50 (arithmetic -> value .)
    EQUAL           reduce using rule 53 (comparison -> value .)
    NOT_EQUAL       reduce using rule 53 (comparison -> value .)
    LESS            reduce using rule 53 (comparison -> value .)
    LESS_EQUAL      reduce using rule 53 (comparison -> value .)
    GREATER         reduce using rule 53 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 53 (comparison -> value .)
    LOGICAL_AND     reduce using rule 53 (comparison -> value .)
    LOGICAL_OR      reduce using rule 53 (comparison -> value .)

  ! $end            [ reduce using rule 53 (comparison -> value .) ]
  ! SEMICOLON       [ reduce using rule 53 (comparison -> value .) ]
  ! RPAREN          [ reduce using rule 53 (comparison -> value .) ]
  ! LINE_BREAK      [ reduce using rule 53 (comparison -> value .) ]
  ! PRINT           [ reduce using rule 53 (comparison -> value .) ]
  ! IF              [ reduce using rule 53 (comparison -> value .) ]
  ! WHILE           [ reduce using rule 53 (comparison -> value .) ]
  ! FOR             [ reduce using rule 53 (comparison -> value .) ]
  ! IDENTIFIER      [ reduce using rule 53 (comparison -> value .) ]
  ! LATE            [ reduce using rule 53 (comparison -> value .) ]
  ! FINAL           [ reduce using rule 53 (comparison -> value .) ]
  ! CONST           [ reduce using rule 53 (comparison -> value .) ]
  ! INTEGER_TYPE    [ reduce using rule 53 (comparison -> value .) ]
  ! DOUBLE_TYPE     [ reduce using rule 53 (comparison -> value .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 53 (comparison -> value .) ]
  ! QUEUE_TYPE      [ reduce using rule 53 (comparison -> value .) ]
  ! STRING_TYPE     [ reduce using rule 53 (comparison -> value .) ]
  ! ENUM_TYPE       [ reduce using rule 53 (comparison -> value .) ]
  ! VAR             [ reduce using rule 53 (comparison -> value .) ]
  ! LIST_TYPE       [ reduce using rule 53 (comparison -> value .) ]
  ! MAP_TYPE        [ reduce using rule 53 (comparison -> value .) ]
  ! SET_TYPE        [ reduce using rule 53 (comparison -> value .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 53 (comparison -> value .) ]
  ! VOID            [ reduce using rule 53 (comparison -> value .) ]
  ! RBRACE          [ reduce using rule 53 (comparison -> value .) ]
  ! LPAREN          [ reduce using rule 53 (comparison -> value .) ]
  ! LOGICAL_NOT     [ reduce using rule 53 (comparison -> value .) ]
  ! TRUE            [ reduce using rule 53 (comparison -> value .) ]
  ! FALSE           [ reduce using rule 53 (comparison -> value .) ]
  ! INTEGER         [ reduce using rule 53 (comparison -> value .) ]
  ! DOUBLE          [ reduce using rule 53 (comparison -> value .) ]
  ! STRING          [ reduce using rule 53 (comparison -> value .) ]
  ! LSQUARE         [ reduce using rule 53 (comparison -> value .) ]


state 27

    (57) logic -> comparison .
    (55) comparison -> comparison . comp_op comparison
    (67) comp_op -> . EQUAL
    (68) comp_op -> . NOT_EQUAL
    (69) comp_op -> . LESS
    (70) comp_op -> . LESS_EQUAL
    (71) comp_op -> . GREATER
    (72) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 57 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 57 (logic -> comparison .)
    $end            reduce using rule 57 (logic -> comparison .)
    SEMICOLON       reduce using rule 57 (logic -> comparison .)
    RPAREN          reduce using rule 57 (logic -> comparison .)
    LINE_BREAK      reduce using rule 57 (logic -> comparison .)
    PRINT           reduce using rule 57 (logic -> comparison .)
    IF              reduce using rule 57 (logic -> comparison .)
    WHILE           reduce using rule 57 (logic -> comparison .)
    FOR             reduce using rule 57 (logic -> comparison .)
    IDENTIFIER      reduce using rule 57 (logic -> comparison .)
    LATE            reduce using rule 57 (logic -> comparison .)
    FINAL           reduce using rule 57 (logic -> comparison .)
    CONST           reduce using rule 57 (logic -> comparison .)
    INTEGER_TYPE    reduce using rule 57 (logic -> comparison .)
    DOUBLE_TYPE     reduce using rule 57 (logic -> comparison .)
    BOOLEAN_TYPE    reduce using rule 57 (logic -> comparison .)
    QUEUE_TYPE      reduce using rule 57 (logic -> comparison .)
    STRING_TYPE     reduce using rule 57 (logic -> comparison .)
    ENUM_TYPE       reduce using rule 57 (logic -> comparison .)
    VAR             reduce using rule 57 (logic -> comparison .)
    LIST_TYPE       reduce using rule 57 (logic -> comparison .)
    MAP_TYPE        reduce using rule 57 (logic -> comparison .)
    SET_TYPE        reduce using rule 57 (logic -> comparison .)
    DYNAMIC_TYPE    reduce using rule 57 (logic -> comparison .)
    VOID            reduce using rule 57 (logic -> comparison .)
    RBRACE          reduce using rule 57 (logic -> comparison .)
    LPAREN          reduce using rule 57 (logic -> comparison .)
    LOGICAL_NOT     reduce using rule 57 (logic -> comparison .)
    TRUE            reduce using rule 57 (logic -> comparison .)
    FALSE           reduce using rule 57 (logic -> comparison .)
    INTEGER         reduce using rule 57 (logic -> comparison .)
    DOUBLE          reduce using rule 57 (logic -> comparison .)
    STRING          reduce using rule 57 (logic -> comparison .)
    LSQUARE         reduce using rule 57 (logic -> comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

    comp_op                        shift and go to state 89

state 28

    (60) logic -> LOGICAL_NOT . logic
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 96
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 29

    (23) modifier -> LATE .

    INTEGER_TYPE    reduce using rule 23 (modifier -> LATE .)
    DOUBLE_TYPE     reduce using rule 23 (modifier -> LATE .)
    BOOLEAN_TYPE    reduce using rule 23 (modifier -> LATE .)
    QUEUE_TYPE      reduce using rule 23 (modifier -> LATE .)
    STRING_TYPE     reduce using rule 23 (modifier -> LATE .)
    ENUM_TYPE       reduce using rule 23 (modifier -> LATE .)
    VAR             reduce using rule 23 (modifier -> LATE .)
    LIST_TYPE       reduce using rule 23 (modifier -> LATE .)
    MAP_TYPE        reduce using rule 23 (modifier -> LATE .)
    SET_TYPE        reduce using rule 23 (modifier -> LATE .)
    DYNAMIC_TYPE    reduce using rule 23 (modifier -> LATE .)
    VOID            reduce using rule 23 (modifier -> LATE .)


state 30

    (24) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 24 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 24 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 24 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 24 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 24 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 24 (modifier -> FINAL .)
    VAR             reduce using rule 24 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 24 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 24 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 24 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 24 (modifier -> FINAL .)
    VOID            reduce using rule 24 (modifier -> FINAL .)


state 31

    (25) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 25 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 25 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 25 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 25 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 25 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 25 (modifier -> CONST .)
    VAR             reduce using rule 25 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 25 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 25 (modifier -> CONST .)
    SET_TYPE        reduce using rule 25 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 25 (modifier -> CONST .)
    VOID            reduce using rule 25 (modifier -> CONST .)


state 32

    (35) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 35 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 35 (type -> INTEGER_TYPE .)


state 33

    (36) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 36 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 36 (type -> DOUBLE_TYPE .)


state 34

    (37) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 37 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 37 (type -> BOOLEAN_TYPE .)


state 35

    (38) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 38 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 38 (type -> QUEUE_TYPE .)


state 36

    (39) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 39 (type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 39 (type -> STRING_TYPE .)


state 37

    (40) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 40 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 40 (type -> ENUM_TYPE .)


state 38

    (41) type -> VAR .

    IDENTIFIER      reduce using rule 41 (type -> VAR .)
    QUESTION_MARK   reduce using rule 41 (type -> VAR .)


state 39

    (42) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 42 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 42 (type -> LIST_TYPE .)


state 40

    (43) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 43 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 43 (type -> MAP_TYPE .)


state 41

    (44) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 44 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 44 (type -> SET_TYPE .)


state 42

    (45) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 45 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 45 (type -> DYNAMIC_TYPE .)


state 43

    (46) type -> VOID .

    IDENTIFIER      reduce using rule 46 (type -> VOID .)
    QUESTION_MARK   reduce using rule 46 (type -> VOID .)


state 44

    (77) value -> string .

    PLUS            reduce using rule 77 (value -> string .)
    MINUS           reduce using rule 77 (value -> string .)
    TIMES           reduce using rule 77 (value -> string .)
    DIVIDE          reduce using rule 77 (value -> string .)
    $end            reduce using rule 77 (value -> string .)
    EQUAL           reduce using rule 77 (value -> string .)
    NOT_EQUAL       reduce using rule 77 (value -> string .)
    LESS            reduce using rule 77 (value -> string .)
    LESS_EQUAL      reduce using rule 77 (value -> string .)
    GREATER         reduce using rule 77 (value -> string .)
    GREATER_EQUAL   reduce using rule 77 (value -> string .)
    LOGICAL_AND     reduce using rule 77 (value -> string .)
    LOGICAL_OR      reduce using rule 77 (value -> string .)
    SEMICOLON       reduce using rule 77 (value -> string .)
    RPAREN          reduce using rule 77 (value -> string .)
    LINE_BREAK      reduce using rule 77 (value -> string .)
    PRINT           reduce using rule 77 (value -> string .)
    IF              reduce using rule 77 (value -> string .)
    WHILE           reduce using rule 77 (value -> string .)
    FOR             reduce using rule 77 (value -> string .)
    IDENTIFIER      reduce using rule 77 (value -> string .)
    LATE            reduce using rule 77 (value -> string .)
    FINAL           reduce using rule 77 (value -> string .)
    CONST           reduce using rule 77 (value -> string .)
    INTEGER_TYPE    reduce using rule 77 (value -> string .)
    DOUBLE_TYPE     reduce using rule 77 (value -> string .)
    BOOLEAN_TYPE    reduce using rule 77 (value -> string .)
    QUEUE_TYPE      reduce using rule 77 (value -> string .)
    STRING_TYPE     reduce using rule 77 (value -> string .)
    ENUM_TYPE       reduce using rule 77 (value -> string .)
    VAR             reduce using rule 77 (value -> string .)
    LIST_TYPE       reduce using rule 77 (value -> string .)
    MAP_TYPE        reduce using rule 77 (value -> string .)
    SET_TYPE        reduce using rule 77 (value -> string .)
    DYNAMIC_TYPE    reduce using rule 77 (value -> string .)
    VOID            reduce using rule 77 (value -> string .)
    RBRACE          reduce using rule 77 (value -> string .)
    LPAREN          reduce using rule 77 (value -> string .)
    LOGICAL_NOT     reduce using rule 77 (value -> string .)
    TRUE            reduce using rule 77 (value -> string .)
    FALSE           reduce using rule 77 (value -> string .)
    INTEGER         reduce using rule 77 (value -> string .)
    DOUBLE          reduce using rule 77 (value -> string .)
    STRING          reduce using rule 77 (value -> string .)
    LSQUARE         reduce using rule 77 (value -> string .)
    COMMA           reduce using rule 77 (value -> string .)
    RSQUARE         reduce using rule 77 (value -> string .)


state 45

    (78) value -> list .

    PLUS            reduce using rule 78 (value -> list .)
    MINUS           reduce using rule 78 (value -> list .)
    TIMES           reduce using rule 78 (value -> list .)
    DIVIDE          reduce using rule 78 (value -> list .)
    $end            reduce using rule 78 (value -> list .)
    EQUAL           reduce using rule 78 (value -> list .)
    NOT_EQUAL       reduce using rule 78 (value -> list .)
    LESS            reduce using rule 78 (value -> list .)
    LESS_EQUAL      reduce using rule 78 (value -> list .)
    GREATER         reduce using rule 78 (value -> list .)
    GREATER_EQUAL   reduce using rule 78 (value -> list .)
    LOGICAL_AND     reduce using rule 78 (value -> list .)
    LOGICAL_OR      reduce using rule 78 (value -> list .)
    SEMICOLON       reduce using rule 78 (value -> list .)
    RPAREN          reduce using rule 78 (value -> list .)
    LINE_BREAK      reduce using rule 78 (value -> list .)
    PRINT           reduce using rule 78 (value -> list .)
    IF              reduce using rule 78 (value -> list .)
    WHILE           reduce using rule 78 (value -> list .)
    FOR             reduce using rule 78 (value -> list .)
    IDENTIFIER      reduce using rule 78 (value -> list .)
    LATE            reduce using rule 78 (value -> list .)
    FINAL           reduce using rule 78 (value -> list .)
    CONST           reduce using rule 78 (value -> list .)
    INTEGER_TYPE    reduce using rule 78 (value -> list .)
    DOUBLE_TYPE     reduce using rule 78 (value -> list .)
    BOOLEAN_TYPE    reduce using rule 78 (value -> list .)
    QUEUE_TYPE      reduce using rule 78 (value -> list .)
    STRING_TYPE     reduce using rule 78 (value -> list .)
    ENUM_TYPE       reduce using rule 78 (value -> list .)
    VAR             reduce using rule 78 (value -> list .)
    LIST_TYPE       reduce using rule 78 (value -> list .)
    MAP_TYPE        reduce using rule 78 (value -> list .)
    SET_TYPE        reduce using rule 78 (value -> list .)
    DYNAMIC_TYPE    reduce using rule 78 (value -> list .)
    VOID            reduce using rule 78 (value -> list .)
    RBRACE          reduce using rule 78 (value -> list .)
    LPAREN          reduce using rule 78 (value -> list .)
    LOGICAL_NOT     reduce using rule 78 (value -> list .)
    TRUE            reduce using rule 78 (value -> list .)
    FALSE           reduce using rule 78 (value -> list .)
    INTEGER         reduce using rule 78 (value -> list .)
    DOUBLE          reduce using rule 78 (value -> list .)
    STRING          reduce using rule 78 (value -> list .)
    LSQUARE         reduce using rule 78 (value -> list .)
    COMMA           reduce using rule 78 (value -> list .)
    RSQUARE         reduce using rule 78 (value -> list .)


state 46

    (54) comparison -> boolean .

    EQUAL           reduce using rule 54 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 54 (comparison -> boolean .)
    LESS            reduce using rule 54 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 54 (comparison -> boolean .)
    GREATER         reduce using rule 54 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 54 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 54 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 54 (comparison -> boolean .)
    $end            reduce using rule 54 (comparison -> boolean .)
    SEMICOLON       reduce using rule 54 (comparison -> boolean .)
    RPAREN          reduce using rule 54 (comparison -> boolean .)
    LINE_BREAK      reduce using rule 54 (comparison -> boolean .)
    PRINT           reduce using rule 54 (comparison -> boolean .)
    IF              reduce using rule 54 (comparison -> boolean .)
    WHILE           reduce using rule 54 (comparison -> boolean .)
    FOR             reduce using rule 54 (comparison -> boolean .)
    IDENTIFIER      reduce using rule 54 (comparison -> boolean .)
    LATE            reduce using rule 54 (comparison -> boolean .)
    FINAL           reduce using rule 54 (comparison -> boolean .)
    CONST           reduce using rule 54 (comparison -> boolean .)
    INTEGER_TYPE    reduce using rule 54 (comparison -> boolean .)
    DOUBLE_TYPE     reduce using rule 54 (comparison -> boolean .)
    BOOLEAN_TYPE    reduce using rule 54 (comparison -> boolean .)
    QUEUE_TYPE      reduce using rule 54 (comparison -> boolean .)
    STRING_TYPE     reduce using rule 54 (comparison -> boolean .)
    ENUM_TYPE       reduce using rule 54 (comparison -> boolean .)
    VAR             reduce using rule 54 (comparison -> boolean .)
    LIST_TYPE       reduce using rule 54 (comparison -> boolean .)
    MAP_TYPE        reduce using rule 54 (comparison -> boolean .)
    SET_TYPE        reduce using rule 54 (comparison -> boolean .)
    DYNAMIC_TYPE    reduce using rule 54 (comparison -> boolean .)
    VOID            reduce using rule 54 (comparison -> boolean .)
    RBRACE          reduce using rule 54 (comparison -> boolean .)
    LPAREN          reduce using rule 54 (comparison -> boolean .)
    LOGICAL_NOT     reduce using rule 54 (comparison -> boolean .)
    TRUE            reduce using rule 54 (comparison -> boolean .)
    FALSE           reduce using rule 54 (comparison -> boolean .)
    INTEGER         reduce using rule 54 (comparison -> boolean .)
    DOUBLE          reduce using rule 54 (comparison -> boolean .)
    STRING          reduce using rule 54 (comparison -> boolean .)
    LSQUARE         reduce using rule 54 (comparison -> boolean .)


state 47

    (79) number -> INTEGER .

    PLUS            reduce using rule 79 (number -> INTEGER .)
    MINUS           reduce using rule 79 (number -> INTEGER .)
    TIMES           reduce using rule 79 (number -> INTEGER .)
    DIVIDE          reduce using rule 79 (number -> INTEGER .)
    $end            reduce using rule 79 (number -> INTEGER .)
    EQUAL           reduce using rule 79 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 79 (number -> INTEGER .)
    LESS            reduce using rule 79 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 79 (number -> INTEGER .)
    GREATER         reduce using rule 79 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 79 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 79 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 79 (number -> INTEGER .)
    SEMICOLON       reduce using rule 79 (number -> INTEGER .)
    RPAREN          reduce using rule 79 (number -> INTEGER .)
    LINE_BREAK      reduce using rule 79 (number -> INTEGER .)
    PRINT           reduce using rule 79 (number -> INTEGER .)
    IF              reduce using rule 79 (number -> INTEGER .)
    WHILE           reduce using rule 79 (number -> INTEGER .)
    FOR             reduce using rule 79 (number -> INTEGER .)
    IDENTIFIER      reduce using rule 79 (number -> INTEGER .)
    LATE            reduce using rule 79 (number -> INTEGER .)
    FINAL           reduce using rule 79 (number -> INTEGER .)
    CONST           reduce using rule 79 (number -> INTEGER .)
    INTEGER_TYPE    reduce using rule 79 (number -> INTEGER .)
    DOUBLE_TYPE     reduce using rule 79 (number -> INTEGER .)
    BOOLEAN_TYPE    reduce using rule 79 (number -> INTEGER .)
    QUEUE_TYPE      reduce using rule 79 (number -> INTEGER .)
    STRING_TYPE     reduce using rule 79 (number -> INTEGER .)
    ENUM_TYPE       reduce using rule 79 (number -> INTEGER .)
    VAR             reduce using rule 79 (number -> INTEGER .)
    LIST_TYPE       reduce using rule 79 (number -> INTEGER .)
    MAP_TYPE        reduce using rule 79 (number -> INTEGER .)
    SET_TYPE        reduce using rule 79 (number -> INTEGER .)
    DYNAMIC_TYPE    reduce using rule 79 (number -> INTEGER .)
    VOID            reduce using rule 79 (number -> INTEGER .)
    RBRACE          reduce using rule 79 (number -> INTEGER .)
    LPAREN          reduce using rule 79 (number -> INTEGER .)
    LOGICAL_NOT     reduce using rule 79 (number -> INTEGER .)
    TRUE            reduce using rule 79 (number -> INTEGER .)
    FALSE           reduce using rule 79 (number -> INTEGER .)
    INTEGER         reduce using rule 79 (number -> INTEGER .)
    DOUBLE          reduce using rule 79 (number -> INTEGER .)
    STRING          reduce using rule 79 (number -> INTEGER .)
    LSQUARE         reduce using rule 79 (number -> INTEGER .)
    COMMA           reduce using rule 79 (number -> INTEGER .)
    RSQUARE         reduce using rule 79 (number -> INTEGER .)


state 48

    (80) number -> DOUBLE .

    PLUS            reduce using rule 80 (number -> DOUBLE .)
    MINUS           reduce using rule 80 (number -> DOUBLE .)
    TIMES           reduce using rule 80 (number -> DOUBLE .)
    DIVIDE          reduce using rule 80 (number -> DOUBLE .)
    $end            reduce using rule 80 (number -> DOUBLE .)
    EQUAL           reduce using rule 80 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 80 (number -> DOUBLE .)
    LESS            reduce using rule 80 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 80 (number -> DOUBLE .)
    GREATER         reduce using rule 80 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 80 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 80 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 80 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 80 (number -> DOUBLE .)
    RPAREN          reduce using rule 80 (number -> DOUBLE .)
    LINE_BREAK      reduce using rule 80 (number -> DOUBLE .)
    PRINT           reduce using rule 80 (number -> DOUBLE .)
    IF              reduce using rule 80 (number -> DOUBLE .)
    WHILE           reduce using rule 80 (number -> DOUBLE .)
    FOR             reduce using rule 80 (number -> DOUBLE .)
    IDENTIFIER      reduce using rule 80 (number -> DOUBLE .)
    LATE            reduce using rule 80 (number -> DOUBLE .)
    FINAL           reduce using rule 80 (number -> DOUBLE .)
    CONST           reduce using rule 80 (number -> DOUBLE .)
    INTEGER_TYPE    reduce using rule 80 (number -> DOUBLE .)
    DOUBLE_TYPE     reduce using rule 80 (number -> DOUBLE .)
    BOOLEAN_TYPE    reduce using rule 80 (number -> DOUBLE .)
    QUEUE_TYPE      reduce using rule 80 (number -> DOUBLE .)
    STRING_TYPE     reduce using rule 80 (number -> DOUBLE .)
    ENUM_TYPE       reduce using rule 80 (number -> DOUBLE .)
    VAR             reduce using rule 80 (number -> DOUBLE .)
    LIST_TYPE       reduce using rule 80 (number -> DOUBLE .)
    MAP_TYPE        reduce using rule 80 (number -> DOUBLE .)
    SET_TYPE        reduce using rule 80 (number -> DOUBLE .)
    DYNAMIC_TYPE    reduce using rule 80 (number -> DOUBLE .)
    VOID            reduce using rule 80 (number -> DOUBLE .)
    RBRACE          reduce using rule 80 (number -> DOUBLE .)
    LPAREN          reduce using rule 80 (number -> DOUBLE .)
    LOGICAL_NOT     reduce using rule 80 (number -> DOUBLE .)
    TRUE            reduce using rule 80 (number -> DOUBLE .)
    FALSE           reduce using rule 80 (number -> DOUBLE .)
    INTEGER         reduce using rule 80 (number -> DOUBLE .)
    DOUBLE          reduce using rule 80 (number -> DOUBLE .)
    STRING          reduce using rule 80 (number -> DOUBLE .)
    LSQUARE         reduce using rule 80 (number -> DOUBLE .)
    COMMA           reduce using rule 80 (number -> DOUBLE .)
    RSQUARE         reduce using rule 80 (number -> DOUBLE .)


state 49

    (81) string -> STRING .

    PLUS            reduce using rule 81 (string -> STRING .)
    MINUS           reduce using rule 81 (string -> STRING .)
    TIMES           reduce using rule 81 (string -> STRING .)
    DIVIDE          reduce using rule 81 (string -> STRING .)
    $end            reduce using rule 81 (string -> STRING .)
    EQUAL           reduce using rule 81 (string -> STRING .)
    NOT_EQUAL       reduce using rule 81 (string -> STRING .)
    LESS            reduce using rule 81 (string -> STRING .)
    LESS_EQUAL      reduce using rule 81 (string -> STRING .)
    GREATER         reduce using rule 81 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 81 (string -> STRING .)
    LOGICAL_AND     reduce using rule 81 (string -> STRING .)
    LOGICAL_OR      reduce using rule 81 (string -> STRING .)
    SEMICOLON       reduce using rule 81 (string -> STRING .)
    RPAREN          reduce using rule 81 (string -> STRING .)
    LINE_BREAK      reduce using rule 81 (string -> STRING .)
    PRINT           reduce using rule 81 (string -> STRING .)
    IF              reduce using rule 81 (string -> STRING .)
    WHILE           reduce using rule 81 (string -> STRING .)
    FOR             reduce using rule 81 (string -> STRING .)
    IDENTIFIER      reduce using rule 81 (string -> STRING .)
    LATE            reduce using rule 81 (string -> STRING .)
    FINAL           reduce using rule 81 (string -> STRING .)
    CONST           reduce using rule 81 (string -> STRING .)
    INTEGER_TYPE    reduce using rule 81 (string -> STRING .)
    DOUBLE_TYPE     reduce using rule 81 (string -> STRING .)
    BOOLEAN_TYPE    reduce using rule 81 (string -> STRING .)
    QUEUE_TYPE      reduce using rule 81 (string -> STRING .)
    STRING_TYPE     reduce using rule 81 (string -> STRING .)
    ENUM_TYPE       reduce using rule 81 (string -> STRING .)
    VAR             reduce using rule 81 (string -> STRING .)
    LIST_TYPE       reduce using rule 81 (string -> STRING .)
    MAP_TYPE        reduce using rule 81 (string -> STRING .)
    SET_TYPE        reduce using rule 81 (string -> STRING .)
    DYNAMIC_TYPE    reduce using rule 81 (string -> STRING .)
    VOID            reduce using rule 81 (string -> STRING .)
    RBRACE          reduce using rule 81 (string -> STRING .)
    LPAREN          reduce using rule 81 (string -> STRING .)
    LOGICAL_NOT     reduce using rule 81 (string -> STRING .)
    TRUE            reduce using rule 81 (string -> STRING .)
    FALSE           reduce using rule 81 (string -> STRING .)
    INTEGER         reduce using rule 81 (string -> STRING .)
    DOUBLE          reduce using rule 81 (string -> STRING .)
    STRING          reduce using rule 81 (string -> STRING .)
    LSQUARE         reduce using rule 81 (string -> STRING .)
    COMMA           reduce using rule 81 (string -> STRING .)
    RSQUARE         reduce using rule 81 (string -> STRING .)


state 50

    (84) list -> LSQUARE . RSQUARE
    (85) list -> LSQUARE . values RSQUARE
    (73) values -> . value
    (74) values -> . value COMMA values
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 99
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    values                         shift and go to state 100
    value                          shift and go to state 101
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 51

    (82) boolean -> TRUE .

    EQUAL           reduce using rule 82 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 82 (boolean -> TRUE .)
    LESS            reduce using rule 82 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 82 (boolean -> TRUE .)
    GREATER         reduce using rule 82 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 82 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 82 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 82 (boolean -> TRUE .)
    $end            reduce using rule 82 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 82 (boolean -> TRUE .)
    RPAREN          reduce using rule 82 (boolean -> TRUE .)
    LINE_BREAK      reduce using rule 82 (boolean -> TRUE .)
    PRINT           reduce using rule 82 (boolean -> TRUE .)
    IF              reduce using rule 82 (boolean -> TRUE .)
    WHILE           reduce using rule 82 (boolean -> TRUE .)
    FOR             reduce using rule 82 (boolean -> TRUE .)
    IDENTIFIER      reduce using rule 82 (boolean -> TRUE .)
    LATE            reduce using rule 82 (boolean -> TRUE .)
    FINAL           reduce using rule 82 (boolean -> TRUE .)
    CONST           reduce using rule 82 (boolean -> TRUE .)
    INTEGER_TYPE    reduce using rule 82 (boolean -> TRUE .)
    DOUBLE_TYPE     reduce using rule 82 (boolean -> TRUE .)
    BOOLEAN_TYPE    reduce using rule 82 (boolean -> TRUE .)
    QUEUE_TYPE      reduce using rule 82 (boolean -> TRUE .)
    STRING_TYPE     reduce using rule 82 (boolean -> TRUE .)
    ENUM_TYPE       reduce using rule 82 (boolean -> TRUE .)
    VAR             reduce using rule 82 (boolean -> TRUE .)
    LIST_TYPE       reduce using rule 82 (boolean -> TRUE .)
    MAP_TYPE        reduce using rule 82 (boolean -> TRUE .)
    SET_TYPE        reduce using rule 82 (boolean -> TRUE .)
    DYNAMIC_TYPE    reduce using rule 82 (boolean -> TRUE .)
    VOID            reduce using rule 82 (boolean -> TRUE .)
    RBRACE          reduce using rule 82 (boolean -> TRUE .)
    LPAREN          reduce using rule 82 (boolean -> TRUE .)
    LOGICAL_NOT     reduce using rule 82 (boolean -> TRUE .)
    TRUE            reduce using rule 82 (boolean -> TRUE .)
    FALSE           reduce using rule 82 (boolean -> TRUE .)
    INTEGER         reduce using rule 82 (boolean -> TRUE .)
    DOUBLE          reduce using rule 82 (boolean -> TRUE .)
    STRING          reduce using rule 82 (boolean -> TRUE .)
    LSQUARE         reduce using rule 82 (boolean -> TRUE .)


state 52

    (83) boolean -> FALSE .

    EQUAL           reduce using rule 83 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 83 (boolean -> FALSE .)
    LESS            reduce using rule 83 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 83 (boolean -> FALSE .)
    GREATER         reduce using rule 83 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 83 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 83 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 83 (boolean -> FALSE .)
    $end            reduce using rule 83 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 83 (boolean -> FALSE .)
    RPAREN          reduce using rule 83 (boolean -> FALSE .)
    LINE_BREAK      reduce using rule 83 (boolean -> FALSE .)
    PRINT           reduce using rule 83 (boolean -> FALSE .)
    IF              reduce using rule 83 (boolean -> FALSE .)
    WHILE           reduce using rule 83 (boolean -> FALSE .)
    FOR             reduce using rule 83 (boolean -> FALSE .)
    IDENTIFIER      reduce using rule 83 (boolean -> FALSE .)
    LATE            reduce using rule 83 (boolean -> FALSE .)
    FINAL           reduce using rule 83 (boolean -> FALSE .)
    CONST           reduce using rule 83 (boolean -> FALSE .)
    INTEGER_TYPE    reduce using rule 83 (boolean -> FALSE .)
    DOUBLE_TYPE     reduce using rule 83 (boolean -> FALSE .)
    BOOLEAN_TYPE    reduce using rule 83 (boolean -> FALSE .)
    QUEUE_TYPE      reduce using rule 83 (boolean -> FALSE .)
    STRING_TYPE     reduce using rule 83 (boolean -> FALSE .)
    ENUM_TYPE       reduce using rule 83 (boolean -> FALSE .)
    VAR             reduce using rule 83 (boolean -> FALSE .)
    LIST_TYPE       reduce using rule 83 (boolean -> FALSE .)
    MAP_TYPE        reduce using rule 83 (boolean -> FALSE .)
    SET_TYPE        reduce using rule 83 (boolean -> FALSE .)
    DYNAMIC_TYPE    reduce using rule 83 (boolean -> FALSE .)
    VOID            reduce using rule 83 (boolean -> FALSE .)
    RBRACE          reduce using rule 83 (boolean -> FALSE .)
    LPAREN          reduce using rule 83 (boolean -> FALSE .)
    LOGICAL_NOT     reduce using rule 83 (boolean -> FALSE .)
    TRUE            reduce using rule 83 (boolean -> FALSE .)
    FALSE           reduce using rule 83 (boolean -> FALSE .)
    INTEGER         reduce using rule 83 (boolean -> FALSE .)
    DOUBLE          reduce using rule 83 (boolean -> FALSE .)
    STRING          reduce using rule 83 (boolean -> FALSE .)
    LSQUARE         reduce using rule 83 (boolean -> FALSE .)


state 53

    (29) if_statement -> if_statement ELSE . if_statement
    (30) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 103
    IF              shift and go to state 20

    if_statement                   shift and go to state 102

state 54

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 104


state 55

    (92) line -> print .

    LINE_BREAK      reduce using rule 92 (line -> print .)
    PRINT           reduce using rule 92 (line -> print .)
    IF              reduce using rule 92 (line -> print .)
    WHILE           reduce using rule 92 (line -> print .)
    FOR             reduce using rule 92 (line -> print .)
    IDENTIFIER      reduce using rule 92 (line -> print .)
    LATE            reduce using rule 92 (line -> print .)
    FINAL           reduce using rule 92 (line -> print .)
    CONST           reduce using rule 92 (line -> print .)
    INTEGER_TYPE    reduce using rule 92 (line -> print .)
    DOUBLE_TYPE     reduce using rule 92 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 92 (line -> print .)
    QUEUE_TYPE      reduce using rule 92 (line -> print .)
    STRING_TYPE     reduce using rule 92 (line -> print .)
    ENUM_TYPE       reduce using rule 92 (line -> print .)
    VAR             reduce using rule 92 (line -> print .)
    LIST_TYPE       reduce using rule 92 (line -> print .)
    MAP_TYPE        reduce using rule 92 (line -> print .)
    SET_TYPE        reduce using rule 92 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 92 (line -> print .)
    VOID            reduce using rule 92 (line -> print .)
    RBRACE          reduce using rule 92 (line -> print .)
    $end            reduce using rule 92 (line -> print .)


state 56

    (93) line -> assignment .

    LINE_BREAK      reduce using rule 93 (line -> assignment .)
    PRINT           reduce using rule 93 (line -> assignment .)
    IF              reduce using rule 93 (line -> assignment .)
    WHILE           reduce using rule 93 (line -> assignment .)
    FOR             reduce using rule 93 (line -> assignment .)
    IDENTIFIER      reduce using rule 93 (line -> assignment .)
    LATE            reduce using rule 93 (line -> assignment .)
    FINAL           reduce using rule 93 (line -> assignment .)
    CONST           reduce using rule 93 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 93 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 93 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 93 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 93 (line -> assignment .)
    STRING_TYPE     reduce using rule 93 (line -> assignment .)
    ENUM_TYPE       reduce using rule 93 (line -> assignment .)
    VAR             reduce using rule 93 (line -> assignment .)
    LIST_TYPE       reduce using rule 93 (line -> assignment .)
    MAP_TYPE        reduce using rule 93 (line -> assignment .)
    SET_TYPE        reduce using rule 93 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 93 (line -> assignment .)
    VOID            reduce using rule 93 (line -> assignment .)
    RBRACE          reduce using rule 93 (line -> assignment .)
    $end            reduce using rule 93 (line -> assignment .)


state 57

    (94) line -> function .

    LINE_BREAK      reduce using rule 94 (line -> function .)
    PRINT           reduce using rule 94 (line -> function .)
    IF              reduce using rule 94 (line -> function .)
    WHILE           reduce using rule 94 (line -> function .)
    FOR             reduce using rule 94 (line -> function .)
    IDENTIFIER      reduce using rule 94 (line -> function .)
    LATE            reduce using rule 94 (line -> function .)
    FINAL           reduce using rule 94 (line -> function .)
    CONST           reduce using rule 94 (line -> function .)
    INTEGER_TYPE    reduce using rule 94 (line -> function .)
    DOUBLE_TYPE     reduce using rule 94 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 94 (line -> function .)
    QUEUE_TYPE      reduce using rule 94 (line -> function .)
    STRING_TYPE     reduce using rule 94 (line -> function .)
    ENUM_TYPE       reduce using rule 94 (line -> function .)
    VAR             reduce using rule 94 (line -> function .)
    LIST_TYPE       reduce using rule 94 (line -> function .)
    MAP_TYPE        reduce using rule 94 (line -> function .)
    SET_TYPE        reduce using rule 94 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 94 (line -> function .)
    VOID            reduce using rule 94 (line -> function .)
    RBRACE          reduce using rule 94 (line -> function .)
    $end            reduce using rule 94 (line -> function .)


state 58

    (95) line -> if_statement .
    (29) if_statement -> if_statement . ELSE if_statement
    (30) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 95 (line -> if_statement .)
    PRINT           reduce using rule 95 (line -> if_statement .)
    IF              reduce using rule 95 (line -> if_statement .)
    WHILE           reduce using rule 95 (line -> if_statement .)
    FOR             reduce using rule 95 (line -> if_statement .)
    IDENTIFIER      reduce using rule 95 (line -> if_statement .)
    LATE            reduce using rule 95 (line -> if_statement .)
    FINAL           reduce using rule 95 (line -> if_statement .)
    CONST           reduce using rule 95 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 95 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 95 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 95 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 95 (line -> if_statement .)
    STRING_TYPE     reduce using rule 95 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 95 (line -> if_statement .)
    VAR             reduce using rule 95 (line -> if_statement .)
    LIST_TYPE       reduce using rule 95 (line -> if_statement .)
    MAP_TYPE        reduce using rule 95 (line -> if_statement .)
    SET_TYPE        reduce using rule 95 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 95 (line -> if_statement .)
    VOID            reduce using rule 95 (line -> if_statement .)
    RBRACE          reduce using rule 95 (line -> if_statement .)
    $end            reduce using rule 95 (line -> if_statement .)
    ELSE            shift and go to state 53


state 59

    (96) line -> while_statement .

    LINE_BREAK      reduce using rule 96 (line -> while_statement .)
    PRINT           reduce using rule 96 (line -> while_statement .)
    IF              reduce using rule 96 (line -> while_statement .)
    WHILE           reduce using rule 96 (line -> while_statement .)
    FOR             reduce using rule 96 (line -> while_statement .)
    IDENTIFIER      reduce using rule 96 (line -> while_statement .)
    LATE            reduce using rule 96 (line -> while_statement .)
    FINAL           reduce using rule 96 (line -> while_statement .)
    CONST           reduce using rule 96 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 96 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 96 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 96 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 96 (line -> while_statement .)
    STRING_TYPE     reduce using rule 96 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 96 (line -> while_statement .)
    VAR             reduce using rule 96 (line -> while_statement .)
    LIST_TYPE       reduce using rule 96 (line -> while_statement .)
    MAP_TYPE        reduce using rule 96 (line -> while_statement .)
    SET_TYPE        reduce using rule 96 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 96 (line -> while_statement .)
    VOID            reduce using rule 96 (line -> while_statement .)
    RBRACE          reduce using rule 96 (line -> while_statement .)
    $end            reduce using rule 96 (line -> while_statement .)


state 60

    (97) line -> for_statement .

    LINE_BREAK      reduce using rule 97 (line -> for_statement .)
    PRINT           reduce using rule 97 (line -> for_statement .)
    IF              reduce using rule 97 (line -> for_statement .)
    WHILE           reduce using rule 97 (line -> for_statement .)
    FOR             reduce using rule 97 (line -> for_statement .)
    IDENTIFIER      reduce using rule 97 (line -> for_statement .)
    LATE            reduce using rule 97 (line -> for_statement .)
    FINAL           reduce using rule 97 (line -> for_statement .)
    CONST           reduce using rule 97 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 97 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 97 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 97 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 97 (line -> for_statement .)
    STRING_TYPE     reduce using rule 97 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 97 (line -> for_statement .)
    VAR             reduce using rule 97 (line -> for_statement .)
    LIST_TYPE       reduce using rule 97 (line -> for_statement .)
    MAP_TYPE        reduce using rule 97 (line -> for_statement .)
    SET_TYPE        reduce using rule 97 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 97 (line -> for_statement .)
    VOID            reduce using rule 97 (line -> for_statement .)
    RBRACE          reduce using rule 97 (line -> for_statement .)
    $end            reduce using rule 97 (line -> for_statement .)


state 61

    (98) line -> function_call .

    LINE_BREAK      reduce using rule 98 (line -> function_call .)
    PRINT           reduce using rule 98 (line -> function_call .)
    IF              reduce using rule 98 (line -> function_call .)
    WHILE           reduce using rule 98 (line -> function_call .)
    FOR             reduce using rule 98 (line -> function_call .)
    IDENTIFIER      reduce using rule 98 (line -> function_call .)
    LATE            reduce using rule 98 (line -> function_call .)
    FINAL           reduce using rule 98 (line -> function_call .)
    CONST           reduce using rule 98 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 98 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 98 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 98 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 98 (line -> function_call .)
    STRING_TYPE     reduce using rule 98 (line -> function_call .)
    ENUM_TYPE       reduce using rule 98 (line -> function_call .)
    VAR             reduce using rule 98 (line -> function_call .)
    LIST_TYPE       reduce using rule 98 (line -> function_call .)
    MAP_TYPE        reduce using rule 98 (line -> function_call .)
    SET_TYPE        reduce using rule 98 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 98 (line -> function_call .)
    VOID            reduce using rule 98 (line -> function_call .)
    RBRACE          reduce using rule 98 (line -> function_call .)
    $end            reduce using rule 98 (line -> function_call .)


state 62

    (99) line -> reassignment .

    LINE_BREAK      reduce using rule 99 (line -> reassignment .)
    PRINT           reduce using rule 99 (line -> reassignment .)
    IF              reduce using rule 99 (line -> reassignment .)
    WHILE           reduce using rule 99 (line -> reassignment .)
    FOR             reduce using rule 99 (line -> reassignment .)
    IDENTIFIER      reduce using rule 99 (line -> reassignment .)
    LATE            reduce using rule 99 (line -> reassignment .)
    FINAL           reduce using rule 99 (line -> reassignment .)
    CONST           reduce using rule 99 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 99 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 99 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 99 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 99 (line -> reassignment .)
    STRING_TYPE     reduce using rule 99 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 99 (line -> reassignment .)
    VAR             reduce using rule 99 (line -> reassignment .)
    LIST_TYPE       reduce using rule 99 (line -> reassignment .)
    MAP_TYPE        reduce using rule 99 (line -> reassignment .)
    SET_TYPE        reduce using rule 99 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 99 (line -> reassignment .)
    VOID            reduce using rule 99 (line -> reassignment .)
    RBRACE          reduce using rule 99 (line -> reassignment .)
    $end            reduce using rule 99 (line -> reassignment .)


state 63

    (31) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER . LPAREN values RPAREN
    (33) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER . LPAREN RPAREN
    (17) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (20) reassignment -> IDENTIFIER . INLINE_ARITH number
    (21) reassignment -> IDENTIFIER . INLINE_ARITH

    LPAREN          shift and go to state 78
    ASSIGN          shift and go to state 76
    INLINE_ARITH    shift and go to state 77


state 64

    (51) arithmetic -> arithmetic arith_op . arithmetic
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 105
    value                          shift and go to state 106
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 65

    (63) arith_op -> PLUS .

    LPAREN          reduce using rule 63 (arith_op -> PLUS .)
    IDENTIFIER      reduce using rule 63 (arith_op -> PLUS .)
    INTEGER         reduce using rule 63 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 63 (arith_op -> PLUS .)
    STRING          reduce using rule 63 (arith_op -> PLUS .)
    LSQUARE         reduce using rule 63 (arith_op -> PLUS .)


state 66

    (64) arith_op -> MINUS .

    LPAREN          reduce using rule 64 (arith_op -> MINUS .)
    IDENTIFIER      reduce using rule 64 (arith_op -> MINUS .)
    INTEGER         reduce using rule 64 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 64 (arith_op -> MINUS .)
    STRING          reduce using rule 64 (arith_op -> MINUS .)
    LSQUARE         reduce using rule 64 (arith_op -> MINUS .)


state 67

    (65) arith_op -> TIMES .

    LPAREN          reduce using rule 65 (arith_op -> TIMES .)
    IDENTIFIER      reduce using rule 65 (arith_op -> TIMES .)
    INTEGER         reduce using rule 65 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 65 (arith_op -> TIMES .)
    STRING          reduce using rule 65 (arith_op -> TIMES .)
    LSQUARE         reduce using rule 65 (arith_op -> TIMES .)


state 68

    (66) arith_op -> DIVIDE .

    LPAREN          reduce using rule 66 (arith_op -> DIVIDE .)
    IDENTIFIER      reduce using rule 66 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 66 (arith_op -> DIVIDE .)
    DOUBLE          reduce using rule 66 (arith_op -> DIVIDE .)
    STRING          reduce using rule 66 (arith_op -> DIVIDE .)
    LSQUARE         reduce using rule 66 (arith_op -> DIVIDE .)


state 69

    (58) logic -> logic logic_op . logic
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 108
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 70

    (61) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 61 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 61 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 61 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 61 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 61 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 61 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 61 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 61 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 61 (logic_op -> LOGICAL_AND .)


state 71

    (62) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 62 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 62 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 62 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 62 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 62 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 62 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 62 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 62 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 62 (logic_op -> LOGICAL_OR .)


state 72

    (12) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (22) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 110
    QUESTION_MARK   shift and go to state 75

    nullable                       shift and go to state 109

state 73

    (13) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 111


state 74

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression
    (86) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 112
    LPAREN          shift and go to state 113


state 75

    (22) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 22 (nullable -> QUESTION_MARK .)


state 76

    (17) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . logic
    (49) expression -> . function_call
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 115
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 77

    (18) reassignment -> IDENTIFIER INLINE_ARITH . number SEMICOLON
    (19) reassignment -> IDENTIFIER INLINE_ARITH . SEMICOLON
    (20) reassignment -> IDENTIFIER INLINE_ARITH . number
    (21) reassignment -> IDENTIFIER INLINE_ARITH .
    (79) number -> . INTEGER
    (80) number -> . DOUBLE

    SEMICOLON       shift and go to state 118
    $end            reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LINE_BREAK      reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    PRINT           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IF              reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    WHILE           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FOR             reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IDENTIFIER      reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LATE            reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FINAL           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    CONST           reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER_TYPE    reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DOUBLE_TYPE     reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    BOOLEAN_TYPE    reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    QUEUE_TYPE      reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    STRING_TYPE     reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    ENUM_TYPE       reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VAR             reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LIST_TYPE       reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    MAP_TYPE        reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    SET_TYPE        reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DYNAMIC_TYPE    reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VOID            reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RBRACE          reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RPAREN          reduce using rule 21 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48

    number                         shift and go to state 117

state 78

    (31) function_call -> IDENTIFIER LPAREN . values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER LPAREN . values RPAREN
    (33) function_call -> IDENTIFIER LPAREN . RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER LPAREN . RPAREN
    (73) values -> . value
    (74) values -> . value COMMA values
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 120
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    values                         shift and go to state 119
    value                          shift and go to state 101
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 79

    (26) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (27) print -> PRINT LPAREN . RPAREN SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . logic
    (49) expression -> . function_call
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE

    RPAREN          shift and go to state 122
    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 121
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 80

    (52) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (51) arithmetic -> arithmetic . arith_op arithmetic
    (63) arith_op -> . PLUS
    (64) arith_op -> . MINUS
    (65) arith_op -> . TIMES
    (66) arith_op -> . DIVIDE

    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

    arith_op                       shift and go to state 123

state 81

    (59) logic -> LPAREN logic . logic_op logic RPAREN
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 124

state 82

    (56) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (57) logic -> comparison .
    (55) comparison -> comparison . comp_op comparison
    (67) comp_op -> . EQUAL
    (68) comp_op -> . NOT_EQUAL
    (69) comp_op -> . LESS
    (70) comp_op -> . LESS_EQUAL
    (71) comp_op -> . GREATER
    (72) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 57 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 57 (logic -> comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

    comp_op                        shift and go to state 125

state 83

    (75) value -> IDENTIFIER .

    PLUS            reduce using rule 75 (value -> IDENTIFIER .)
    MINUS           reduce using rule 75 (value -> IDENTIFIER .)
    TIMES           reduce using rule 75 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 75 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 75 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 75 (value -> IDENTIFIER .)
    LESS            reduce using rule 75 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 75 (value -> IDENTIFIER .)
    GREATER         reduce using rule 75 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 75 (value -> IDENTIFIER .)
    $end            reduce using rule 75 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 75 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 75 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 75 (value -> IDENTIFIER .)
    PRINT           reduce using rule 75 (value -> IDENTIFIER .)
    IF              reduce using rule 75 (value -> IDENTIFIER .)
    WHILE           reduce using rule 75 (value -> IDENTIFIER .)
    FOR             reduce using rule 75 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 75 (value -> IDENTIFIER .)
    LATE            reduce using rule 75 (value -> IDENTIFIER .)
    FINAL           reduce using rule 75 (value -> IDENTIFIER .)
    CONST           reduce using rule 75 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 75 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 75 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 75 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 75 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 75 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 75 (value -> IDENTIFIER .)
    VAR             reduce using rule 75 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 75 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 75 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 75 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 75 (value -> IDENTIFIER .)
    VOID            reduce using rule 75 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 75 (value -> IDENTIFIER .)
    LPAREN          reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 75 (value -> IDENTIFIER .)
    TRUE            reduce using rule 75 (value -> IDENTIFIER .)
    FALSE           reduce using rule 75 (value -> IDENTIFIER .)
    INTEGER         reduce using rule 75 (value -> IDENTIFIER .)
    DOUBLE          reduce using rule 75 (value -> IDENTIFIER .)
    STRING          reduce using rule 75 (value -> IDENTIFIER .)
    LSQUARE         reduce using rule 75 (value -> IDENTIFIER .)
    COMMA           reduce using rule 75 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 75 (value -> IDENTIFIER .)


state 84

    (28) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 126
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 85

    (115) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 127
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 86

    (116) for_statement -> FOR LPAREN . assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    assignment                     shift and go to state 128
    modifier                       shift and go to state 15
    type                           shift and go to state 129

state 87

    (87) lines -> line LINE_BREAK . lines
    (90) lines -> LINE_BREAK .
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 90 (lines -> LINE_BREAK .)
  ! reduce/reduce conflict for RBRACE resolved using rule 90 (lines -> LINE_BREAK .)
    $end            reduce using rule 90 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 90 (lines -> LINE_BREAK .)
    LINE_BREAK      shift and go to state 24
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

  ! $end            [ reduce using rule 91 (lines -> .) ]
  ! RBRACE          [ reduce using rule 91 (lines -> .) ]

    line                           shift and go to state 23
    lines                          shift and go to state 130
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 88

    (88) lines -> line lines .

    $end            reduce using rule 88 (lines -> line lines .)
    RBRACE          reduce using rule 88 (lines -> line lines .)


state 89

    (55) comparison -> comparison comp_op . comparison
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 132
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    comparison                     shift and go to state 131
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 90

    (67) comp_op -> EQUAL .

    LPAREN          reduce using rule 67 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 67 (comp_op -> EQUAL .)
    TRUE            reduce using rule 67 (comp_op -> EQUAL .)
    FALSE           reduce using rule 67 (comp_op -> EQUAL .)
    INTEGER         reduce using rule 67 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 67 (comp_op -> EQUAL .)
    STRING          reduce using rule 67 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 67 (comp_op -> EQUAL .)


state 91

    (68) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 68 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 68 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 68 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 68 (comp_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 68 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 68 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 68 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 68 (comp_op -> NOT_EQUAL .)


state 92

    (69) comp_op -> LESS .

    LPAREN          reduce using rule 69 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 69 (comp_op -> LESS .)
    TRUE            reduce using rule 69 (comp_op -> LESS .)
    FALSE           reduce using rule 69 (comp_op -> LESS .)
    INTEGER         reduce using rule 69 (comp_op -> LESS .)
    DOUBLE          reduce using rule 69 (comp_op -> LESS .)
    STRING          reduce using rule 69 (comp_op -> LESS .)
    LSQUARE         reduce using rule 69 (comp_op -> LESS .)


state 93

    (70) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 70 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 70 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 70 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 70 (comp_op -> LESS_EQUAL .)
    INTEGER         reduce using rule 70 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 70 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 70 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 70 (comp_op -> LESS_EQUAL .)


state 94

    (71) comp_op -> GREATER .

    LPAREN          reduce using rule 71 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 71 (comp_op -> GREATER .)
    TRUE            reduce using rule 71 (comp_op -> GREATER .)
    FALSE           reduce using rule 71 (comp_op -> GREATER .)
    INTEGER         reduce using rule 71 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 71 (comp_op -> GREATER .)
    STRING          reduce using rule 71 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 71 (comp_op -> GREATER .)


state 95

    (72) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 72 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 72 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 72 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 72 (comp_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 72 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 72 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 72 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 72 (comp_op -> GREATER_EQUAL .)


state 96

    (60) logic -> LOGICAL_NOT logic .
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    LINE_BREAK      reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    PRINT           reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    IF              reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    WHILE           reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    FOR             reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    IDENTIFIER      reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    LATE            reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    FINAL           reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    CONST           reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    INTEGER_TYPE    reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    DOUBLE_TYPE     reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    BOOLEAN_TYPE    reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    QUEUE_TYPE      reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    STRING_TYPE     reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    ENUM_TYPE       reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    VAR             reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    LIST_TYPE       reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    MAP_TYPE        reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    SET_TYPE        reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    DYNAMIC_TYPE    reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    VOID            reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    RBRACE          reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    LPAREN          reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    LOGICAL_NOT     reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    TRUE            reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    FALSE           reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    INTEGER         reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    DOUBLE          reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    STRING          reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    LSQUARE         reduce using rule 60 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

  ! LOGICAL_AND     [ reduce using rule 60 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 60 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 69

state 97

    (59) logic -> LPAREN . logic logic_op logic RPAREN
    (56) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 81
    comparison                     shift and go to state 82
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 98

    (53) comparison -> value .

    EQUAL           reduce using rule 53 (comparison -> value .)
    NOT_EQUAL       reduce using rule 53 (comparison -> value .)
    LESS            reduce using rule 53 (comparison -> value .)
    LESS_EQUAL      reduce using rule 53 (comparison -> value .)
    GREATER         reduce using rule 53 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 53 (comparison -> value .)
    LOGICAL_AND     reduce using rule 53 (comparison -> value .)
    LOGICAL_OR      reduce using rule 53 (comparison -> value .)
    $end            reduce using rule 53 (comparison -> value .)
    SEMICOLON       reduce using rule 53 (comparison -> value .)
    RPAREN          reduce using rule 53 (comparison -> value .)
    LINE_BREAK      reduce using rule 53 (comparison -> value .)
    PRINT           reduce using rule 53 (comparison -> value .)
    IF              reduce using rule 53 (comparison -> value .)
    WHILE           reduce using rule 53 (comparison -> value .)
    FOR             reduce using rule 53 (comparison -> value .)
    IDENTIFIER      reduce using rule 53 (comparison -> value .)
    LATE            reduce using rule 53 (comparison -> value .)
    FINAL           reduce using rule 53 (comparison -> value .)
    CONST           reduce using rule 53 (comparison -> value .)
    INTEGER_TYPE    reduce using rule 53 (comparison -> value .)
    DOUBLE_TYPE     reduce using rule 53 (comparison -> value .)
    BOOLEAN_TYPE    reduce using rule 53 (comparison -> value .)
    QUEUE_TYPE      reduce using rule 53 (comparison -> value .)
    STRING_TYPE     reduce using rule 53 (comparison -> value .)
    ENUM_TYPE       reduce using rule 53 (comparison -> value .)
    VAR             reduce using rule 53 (comparison -> value .)
    LIST_TYPE       reduce using rule 53 (comparison -> value .)
    MAP_TYPE        reduce using rule 53 (comparison -> value .)
    SET_TYPE        reduce using rule 53 (comparison -> value .)
    DYNAMIC_TYPE    reduce using rule 53 (comparison -> value .)
    VOID            reduce using rule 53 (comparison -> value .)
    RBRACE          reduce using rule 53 (comparison -> value .)
    LPAREN          reduce using rule 53 (comparison -> value .)
    LOGICAL_NOT     reduce using rule 53 (comparison -> value .)
    TRUE            reduce using rule 53 (comparison -> value .)
    FALSE           reduce using rule 53 (comparison -> value .)
    INTEGER         reduce using rule 53 (comparison -> value .)
    DOUBLE          reduce using rule 53 (comparison -> value .)
    STRING          reduce using rule 53 (comparison -> value .)
    LSQUARE         reduce using rule 53 (comparison -> value .)


state 99

    (84) list -> LSQUARE RSQUARE .

    PLUS            reduce using rule 84 (list -> LSQUARE RSQUARE .)
    MINUS           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    TIMES           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    DIVIDE          reduce using rule 84 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 84 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 84 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 84 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 84 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 84 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LINE_BREAK      reduce using rule 84 (list -> LSQUARE RSQUARE .)
    PRINT           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    IF              reduce using rule 84 (list -> LSQUARE RSQUARE .)
    WHILE           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    FOR             reduce using rule 84 (list -> LSQUARE RSQUARE .)
    IDENTIFIER      reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LATE            reduce using rule 84 (list -> LSQUARE RSQUARE .)
    FINAL           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    CONST           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    INTEGER_TYPE    reduce using rule 84 (list -> LSQUARE RSQUARE .)
    DOUBLE_TYPE     reduce using rule 84 (list -> LSQUARE RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 84 (list -> LSQUARE RSQUARE .)
    QUEUE_TYPE      reduce using rule 84 (list -> LSQUARE RSQUARE .)
    STRING_TYPE     reduce using rule 84 (list -> LSQUARE RSQUARE .)
    ENUM_TYPE       reduce using rule 84 (list -> LSQUARE RSQUARE .)
    VAR             reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LIST_TYPE       reduce using rule 84 (list -> LSQUARE RSQUARE .)
    MAP_TYPE        reduce using rule 84 (list -> LSQUARE RSQUARE .)
    SET_TYPE        reduce using rule 84 (list -> LSQUARE RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 84 (list -> LSQUARE RSQUARE .)
    VOID            reduce using rule 84 (list -> LSQUARE RSQUARE .)
    RBRACE          reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LPAREN          reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LOGICAL_NOT     reduce using rule 84 (list -> LSQUARE RSQUARE .)
    TRUE            reduce using rule 84 (list -> LSQUARE RSQUARE .)
    FALSE           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    INTEGER         reduce using rule 84 (list -> LSQUARE RSQUARE .)
    DOUBLE          reduce using rule 84 (list -> LSQUARE RSQUARE .)
    STRING          reduce using rule 84 (list -> LSQUARE RSQUARE .)
    LSQUARE         reduce using rule 84 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 84 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 84 (list -> LSQUARE RSQUARE .)


state 100

    (85) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 133


state 101

    (73) values -> value .
    (74) values -> value . COMMA values

    RSQUARE         reduce using rule 73 (values -> value .)
    RPAREN          reduce using rule 73 (values -> value .)
    COMMA           shift and go to state 134


state 102

    (29) if_statement -> if_statement ELSE if_statement .
    (29) if_statement -> if_statement . ELSE if_statement
    (30) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    WHILE           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    FOR             reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    IDENTIFIER      reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    LATE            reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 29 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 53

  ! ELSE            [ reduce using rule 29 (if_statement -> if_statement ELSE if_statement .) ]


state 103

    (30) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 91 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    if_statement                   shift and go to state 58
    lines                          shift and go to state 135
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 104

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 105

    (51) arithmetic -> arithmetic arith_op arithmetic .
    (51) arithmetic -> arithmetic . arith_op arithmetic
    (63) arith_op -> . PLUS
    (64) arith_op -> . MINUS
    (65) arith_op -> . TIMES
    (66) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    $end            reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    LINE_BREAK      reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    PRINT           reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    IF              reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    WHILE           reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    FOR             reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    IDENTIFIER      reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    LATE            reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    FINAL           reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    CONST           reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER_TYPE    reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE_TYPE     reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    BOOLEAN_TYPE    reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    QUEUE_TYPE      reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING_TYPE     reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    ENUM_TYPE       reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    VAR             reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    LIST_TYPE       reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    MAP_TYPE        reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    SET_TYPE        reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    DYNAMIC_TYPE    reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    VOID            reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    RBRACE          reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    LPAREN          reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    LOGICAL_NOT     reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    TRUE            reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    FALSE           reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER         reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE          reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING          reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    LSQUARE         reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 64

state 106

    (50) arithmetic -> value .

    PLUS            reduce using rule 50 (arithmetic -> value .)
    MINUS           reduce using rule 50 (arithmetic -> value .)
    TIMES           reduce using rule 50 (arithmetic -> value .)
    DIVIDE          reduce using rule 50 (arithmetic -> value .)
    $end            reduce using rule 50 (arithmetic -> value .)
    SEMICOLON       reduce using rule 50 (arithmetic -> value .)
    RPAREN          reduce using rule 50 (arithmetic -> value .)
    LINE_BREAK      reduce using rule 50 (arithmetic -> value .)
    PRINT           reduce using rule 50 (arithmetic -> value .)
    IF              reduce using rule 50 (arithmetic -> value .)
    WHILE           reduce using rule 50 (arithmetic -> value .)
    FOR             reduce using rule 50 (arithmetic -> value .)
    IDENTIFIER      reduce using rule 50 (arithmetic -> value .)
    LATE            reduce using rule 50 (arithmetic -> value .)
    FINAL           reduce using rule 50 (arithmetic -> value .)
    CONST           reduce using rule 50 (arithmetic -> value .)
    INTEGER_TYPE    reduce using rule 50 (arithmetic -> value .)
    DOUBLE_TYPE     reduce using rule 50 (arithmetic -> value .)
    BOOLEAN_TYPE    reduce using rule 50 (arithmetic -> value .)
    QUEUE_TYPE      reduce using rule 50 (arithmetic -> value .)
    STRING_TYPE     reduce using rule 50 (arithmetic -> value .)
    ENUM_TYPE       reduce using rule 50 (arithmetic -> value .)
    VAR             reduce using rule 50 (arithmetic -> value .)
    LIST_TYPE       reduce using rule 50 (arithmetic -> value .)
    MAP_TYPE        reduce using rule 50 (arithmetic -> value .)
    SET_TYPE        reduce using rule 50 (arithmetic -> value .)
    DYNAMIC_TYPE    reduce using rule 50 (arithmetic -> value .)
    VOID            reduce using rule 50 (arithmetic -> value .)
    RBRACE          reduce using rule 50 (arithmetic -> value .)
    LPAREN          reduce using rule 50 (arithmetic -> value .)
    LOGICAL_NOT     reduce using rule 50 (arithmetic -> value .)
    TRUE            reduce using rule 50 (arithmetic -> value .)
    FALSE           reduce using rule 50 (arithmetic -> value .)
    INTEGER         reduce using rule 50 (arithmetic -> value .)
    DOUBLE          reduce using rule 50 (arithmetic -> value .)
    STRING          reduce using rule 50 (arithmetic -> value .)
    LSQUARE         reduce using rule 50 (arithmetic -> value .)


state 107

    (52) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 80
    value                          shift and go to state 106
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 108

    (58) logic -> logic logic_op logic .
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 58 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 58 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 58 (logic -> logic logic_op logic .)
    LINE_BREAK      reduce using rule 58 (logic -> logic logic_op logic .)
    PRINT           reduce using rule 58 (logic -> logic logic_op logic .)
    IF              reduce using rule 58 (logic -> logic logic_op logic .)
    WHILE           reduce using rule 58 (logic -> logic logic_op logic .)
    FOR             reduce using rule 58 (logic -> logic logic_op logic .)
    IDENTIFIER      reduce using rule 58 (logic -> logic logic_op logic .)
    LATE            reduce using rule 58 (logic -> logic logic_op logic .)
    FINAL           reduce using rule 58 (logic -> logic logic_op logic .)
    CONST           reduce using rule 58 (logic -> logic logic_op logic .)
    INTEGER_TYPE    reduce using rule 58 (logic -> logic logic_op logic .)
    DOUBLE_TYPE     reduce using rule 58 (logic -> logic logic_op logic .)
    BOOLEAN_TYPE    reduce using rule 58 (logic -> logic logic_op logic .)
    QUEUE_TYPE      reduce using rule 58 (logic -> logic logic_op logic .)
    STRING_TYPE     reduce using rule 58 (logic -> logic logic_op logic .)
    ENUM_TYPE       reduce using rule 58 (logic -> logic logic_op logic .)
    VAR             reduce using rule 58 (logic -> logic logic_op logic .)
    LIST_TYPE       reduce using rule 58 (logic -> logic logic_op logic .)
    MAP_TYPE        reduce using rule 58 (logic -> logic logic_op logic .)
    SET_TYPE        reduce using rule 58 (logic -> logic logic_op logic .)
    DYNAMIC_TYPE    reduce using rule 58 (logic -> logic logic_op logic .)
    VOID            reduce using rule 58 (logic -> logic logic_op logic .)
    RBRACE          reduce using rule 58 (logic -> logic logic_op logic .)
    LPAREN          reduce using rule 58 (logic -> logic logic_op logic .)
    LOGICAL_NOT     reduce using rule 58 (logic -> logic logic_op logic .)
    TRUE            reduce using rule 58 (logic -> logic logic_op logic .)
    FALSE           reduce using rule 58 (logic -> logic logic_op logic .)
    INTEGER         reduce using rule 58 (logic -> logic logic_op logic .)
    DOUBLE          reduce using rule 58 (logic -> logic logic_op logic .)
    STRING          reduce using rule 58 (logic -> logic logic_op logic .)
    LSQUARE         reduce using rule 58 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

  ! LOGICAL_AND     [ reduce using rule 58 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 58 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 69

state 109

    (12) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 136


state 110

    (14) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 137


state 111

    (13) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 138


state 112

    (15) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN . expression
    (47) expression -> . arithmetic
    (48) expression -> . logic
    (49) expression -> . function_call
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 139
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 113

    (86) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (100) parameters -> . VOID
    (101) parameters -> . parameter
    (102) parameters -> . parameter COMMA parameters
    (103) parameters -> .
    (104) parameter -> . type IDENTIFIER
    (105) parameter -> . IDENTIFIER
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    VOID            shift and go to state 143
    RPAREN          reduce using rule 103 (parameters -> .)
    IDENTIFIER      shift and go to state 141
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42

    type                           shift and go to state 140
    parameters                     shift and go to state 142
    parameter                      shift and go to state 144

state 114

    (31) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER . LPAREN values RPAREN
    (33) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (34) function_call -> IDENTIFIER . LPAREN RPAREN
    (75) value -> IDENTIFIER .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 78
    PLUS            reduce using rule 75 (value -> IDENTIFIER .)
    MINUS           reduce using rule 75 (value -> IDENTIFIER .)
    TIMES           reduce using rule 75 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 75 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 75 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 75 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 75 (value -> IDENTIFIER .)
    LESS            reduce using rule 75 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 75 (value -> IDENTIFIER .)
    GREATER         reduce using rule 75 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 75 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 75 (value -> IDENTIFIER .)
    $end            reduce using rule 75 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 75 (value -> IDENTIFIER .)
    PRINT           reduce using rule 75 (value -> IDENTIFIER .)
    IF              reduce using rule 75 (value -> IDENTIFIER .)
    WHILE           reduce using rule 75 (value -> IDENTIFIER .)
    FOR             reduce using rule 75 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 75 (value -> IDENTIFIER .)
    LATE            reduce using rule 75 (value -> IDENTIFIER .)
    FINAL           reduce using rule 75 (value -> IDENTIFIER .)
    CONST           reduce using rule 75 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 75 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 75 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 75 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 75 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 75 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 75 (value -> IDENTIFIER .)
    VAR             reduce using rule 75 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 75 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 75 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 75 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 75 (value -> IDENTIFIER .)
    VOID            reduce using rule 75 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 75 (value -> IDENTIFIER .)
    LOGICAL_NOT     reduce using rule 75 (value -> IDENTIFIER .)
    TRUE            reduce using rule 75 (value -> IDENTIFIER .)
    FALSE           reduce using rule 75 (value -> IDENTIFIER .)
    INTEGER         reduce using rule 75 (value -> IDENTIFIER .)
    DOUBLE          reduce using rule 75 (value -> IDENTIFIER .)
    STRING          reduce using rule 75 (value -> IDENTIFIER .)
    LSQUARE         reduce using rule 75 (value -> IDENTIFIER .)

  ! LPAREN          [ reduce using rule 75 (value -> IDENTIFIER .) ]


state 115

    (17) reassignment -> IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 145


state 116

    (49) expression -> function_call .

    SEMICOLON       reduce using rule 49 (expression -> function_call .)
    RPAREN          reduce using rule 49 (expression -> function_call .)
    $end            reduce using rule 49 (expression -> function_call .)
    LINE_BREAK      reduce using rule 49 (expression -> function_call .)
    PRINT           reduce using rule 49 (expression -> function_call .)
    IF              reduce using rule 49 (expression -> function_call .)
    WHILE           reduce using rule 49 (expression -> function_call .)
    FOR             reduce using rule 49 (expression -> function_call .)
    IDENTIFIER      reduce using rule 49 (expression -> function_call .)
    LATE            reduce using rule 49 (expression -> function_call .)
    FINAL           reduce using rule 49 (expression -> function_call .)
    CONST           reduce using rule 49 (expression -> function_call .)
    INTEGER_TYPE    reduce using rule 49 (expression -> function_call .)
    DOUBLE_TYPE     reduce using rule 49 (expression -> function_call .)
    BOOLEAN_TYPE    reduce using rule 49 (expression -> function_call .)
    QUEUE_TYPE      reduce using rule 49 (expression -> function_call .)
    STRING_TYPE     reduce using rule 49 (expression -> function_call .)
    ENUM_TYPE       reduce using rule 49 (expression -> function_call .)
    VAR             reduce using rule 49 (expression -> function_call .)
    LIST_TYPE       reduce using rule 49 (expression -> function_call .)
    MAP_TYPE        reduce using rule 49 (expression -> function_call .)
    SET_TYPE        reduce using rule 49 (expression -> function_call .)
    DYNAMIC_TYPE    reduce using rule 49 (expression -> function_call .)
    VOID            reduce using rule 49 (expression -> function_call .)
    RBRACE          reduce using rule 49 (expression -> function_call .)
    LPAREN          reduce using rule 49 (expression -> function_call .)
    LOGICAL_NOT     reduce using rule 49 (expression -> function_call .)
    TRUE            reduce using rule 49 (expression -> function_call .)
    FALSE           reduce using rule 49 (expression -> function_call .)
    INTEGER         reduce using rule 49 (expression -> function_call .)
    DOUBLE          reduce using rule 49 (expression -> function_call .)
    STRING          reduce using rule 49 (expression -> function_call .)
    LSQUARE         reduce using rule 49 (expression -> function_call .)


state 117

    (18) reassignment -> IDENTIFIER INLINE_ARITH number . SEMICOLON
    (20) reassignment -> IDENTIFIER INLINE_ARITH number .

    SEMICOLON       shift and go to state 146
    $end            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LINE_BREAK      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    PRINT           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IF              reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    WHILE           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FOR             reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IDENTIFIER      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LATE            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FINAL           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    CONST           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    INTEGER_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DOUBLE_TYPE     reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    BOOLEAN_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    QUEUE_TYPE      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    STRING_TYPE     reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    ENUM_TYPE       reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VAR             reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LIST_TYPE       reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    MAP_TYPE        reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    SET_TYPE        reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DYNAMIC_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VOID            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RBRACE          reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RPAREN          reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH number .)


state 118

    (19) reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .

    $end            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LINE_BREAK      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    PRINT           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IF              reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    WHILE           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FOR             reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IDENTIFIER      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LATE            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FINAL           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    CONST           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    INTEGER_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    QUEUE_TYPE      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    STRING_TYPE     reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    ENUM_TYPE       reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VAR             reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LIST_TYPE       reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    MAP_TYPE        reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    SET_TYPE        reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VOID            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RBRACE          reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RPAREN          reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)


state 119

    (31) function_call -> IDENTIFIER LPAREN values . RPAREN SEMICOLON
    (32) function_call -> IDENTIFIER LPAREN values . RPAREN

    RPAREN          shift and go to state 147


state 120

    (33) function_call -> IDENTIFIER LPAREN RPAREN . SEMICOLON
    (34) function_call -> IDENTIFIER LPAREN RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 148
    $end            reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LINE_BREAK      reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LATE            reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FINAL           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONST           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER_TYPE    reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE_TYPE     reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BOOLEAN_TYPE    reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    QUEUE_TYPE      reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING_TYPE     reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ENUM_TYPE       reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LIST_TYPE       reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MAP_TYPE        reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SET_TYPE        reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DYNAMIC_TYPE    reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VOID            reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LPAREN          reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LOGICAL_NOT     reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    TRUE            reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FALSE           reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER         reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE          reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING          reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LSQUARE         reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 34 (function_call -> IDENTIFIER LPAREN RPAREN .) ]


state 121

    (26) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 149


state 122

    (27) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 150


state 123

    (52) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (51) arithmetic -> arithmetic arith_op . arithmetic
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 151
    value                          shift and go to state 106
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 124

    (59) logic -> LPAREN logic logic_op . logic RPAREN
    (58) logic -> logic logic_op . logic
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 152
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 125

    (56) comparison -> LPAREN comparison comp_op . comparison RPAREN
    (55) comparison -> comparison comp_op . comparison
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 132
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    comparison                     shift and go to state 153
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 126

    (28) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 154
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 127

    (115) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 155
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 128

    (116) for_statement -> FOR LPAREN assignment . logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 156
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 129

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (22) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 157
    QUESTION_MARK   shift and go to state 75

    nullable                       shift and go to state 73

state 130

    (87) lines -> line LINE_BREAK lines .

    $end            reduce using rule 87 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 87 (lines -> line LINE_BREAK lines .)


state 131

    (55) comparison -> comparison comp_op comparison .
    (55) comparison -> comparison . comp_op comparison
    (67) comp_op -> . EQUAL
    (68) comp_op -> . NOT_EQUAL
    (69) comp_op -> . LESS
    (70) comp_op -> . LESS_EQUAL
    (71) comp_op -> . GREATER
    (72) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 55 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 55 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 55 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LINE_BREAK      reduce using rule 55 (comparison -> comparison comp_op comparison .)
    PRINT           reduce using rule 55 (comparison -> comparison comp_op comparison .)
    IF              reduce using rule 55 (comparison -> comparison comp_op comparison .)
    WHILE           reduce using rule 55 (comparison -> comparison comp_op comparison .)
    FOR             reduce using rule 55 (comparison -> comparison comp_op comparison .)
    IDENTIFIER      reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LATE            reduce using rule 55 (comparison -> comparison comp_op comparison .)
    FINAL           reduce using rule 55 (comparison -> comparison comp_op comparison .)
    CONST           reduce using rule 55 (comparison -> comparison comp_op comparison .)
    INTEGER_TYPE    reduce using rule 55 (comparison -> comparison comp_op comparison .)
    DOUBLE_TYPE     reduce using rule 55 (comparison -> comparison comp_op comparison .)
    BOOLEAN_TYPE    reduce using rule 55 (comparison -> comparison comp_op comparison .)
    QUEUE_TYPE      reduce using rule 55 (comparison -> comparison comp_op comparison .)
    STRING_TYPE     reduce using rule 55 (comparison -> comparison comp_op comparison .)
    ENUM_TYPE       reduce using rule 55 (comparison -> comparison comp_op comparison .)
    VAR             reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LIST_TYPE       reduce using rule 55 (comparison -> comparison comp_op comparison .)
    MAP_TYPE        reduce using rule 55 (comparison -> comparison comp_op comparison .)
    SET_TYPE        reduce using rule 55 (comparison -> comparison comp_op comparison .)
    DYNAMIC_TYPE    reduce using rule 55 (comparison -> comparison comp_op comparison .)
    VOID            reduce using rule 55 (comparison -> comparison comp_op comparison .)
    RBRACE          reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LPAREN          reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LOGICAL_NOT     reduce using rule 55 (comparison -> comparison comp_op comparison .)
    TRUE            reduce using rule 55 (comparison -> comparison comp_op comparison .)
    FALSE           reduce using rule 55 (comparison -> comparison comp_op comparison .)
    INTEGER         reduce using rule 55 (comparison -> comparison comp_op comparison .)
    DOUBLE          reduce using rule 55 (comparison -> comparison comp_op comparison .)
    STRING          reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LSQUARE         reduce using rule 55 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

  ! EQUAL           [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 89

state 132

    (56) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 132
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    comparison                     shift and go to state 158
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 133

    (85) list -> LSQUARE values RSQUARE .

    PLUS            reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    MINUS           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    TIMES           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    DIVIDE          reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LINE_BREAK      reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    PRINT           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    IF              reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    WHILE           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    FOR             reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    IDENTIFIER      reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LATE            reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    FINAL           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    CONST           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    INTEGER_TYPE    reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    DOUBLE_TYPE     reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    QUEUE_TYPE      reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    STRING_TYPE     reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    ENUM_TYPE       reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    VAR             reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LIST_TYPE       reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    MAP_TYPE        reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    SET_TYPE        reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    VOID            reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    RBRACE          reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LPAREN          reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LOGICAL_NOT     reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    TRUE            reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    FALSE           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    INTEGER         reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    DOUBLE          reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    STRING          reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    LSQUARE         reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 85 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 85 (list -> LSQUARE values RSQUARE .)


state 134

    (74) values -> value COMMA . values
    (73) values -> . value
    (74) values -> . value COMMA values
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    value                          shift and go to state 101
    values                         shift and go to state 159
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 135

    (30) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 160


state 136

    (12) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 161


state 137

    (14) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . logic
    (49) expression -> . function_call
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 162
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 138

    (13) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . logic
    (49) expression -> . function_call
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 163
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 139

    (15) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN expression .

    SEMICOLON       shift and go to state 164
    $end            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LINE_BREAK      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    PRINT           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LATE            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FINAL           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    BOOLEAN_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    QUEUE_TYPE      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    ENUM_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LIST_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    MAP_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    SET_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DYNAMIC_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VOID            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LOGICAL_NOT     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    TRUE            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FALSE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER         reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LSQUARE         reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)


state 140

    (104) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 165


state 141

    (105) parameter -> IDENTIFIER .

    COMMA           reduce using rule 105 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 105 (parameter -> IDENTIFIER .)


state 142

    (86) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 166


state 143

    (100) parameters -> VOID .
    (46) type -> VOID .

    RPAREN          reduce using rule 100 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 46 (type -> VOID .)


state 144

    (101) parameters -> parameter .
    (102) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 101 (parameters -> parameter .)
    COMMA           shift and go to state 167


state 145

    (17) reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 17 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 146

    (18) reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .

    $end            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LINE_BREAK      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    PRINT           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IF              reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    WHILE           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FOR             reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IDENTIFIER      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LATE            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FINAL           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    CONST           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    INTEGER_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    QUEUE_TYPE      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    STRING_TYPE     reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    ENUM_TYPE       reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VAR             reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LIST_TYPE       reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    MAP_TYPE        reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    SET_TYPE        reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VOID            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RBRACE          reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RPAREN          reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)


state 147

    (31) function_call -> IDENTIFIER LPAREN values RPAREN . SEMICOLON
    (32) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 168
    $end            reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LINE_BREAK      reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PRINT           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    WHILE           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LATE            reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FINAL           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER_TYPE    reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE_TYPE     reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN_TYPE    reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    QUEUE_TYPE      reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING_TYPE     reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    ENUM_TYPE       reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LIST_TYPE       reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    MAP_TYPE        reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SET_TYPE        reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DYNAMIC_TYPE    reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VOID            reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RBRACE          reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RPAREN          reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LPAREN          reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LOGICAL_NOT     reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    TRUE            reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FALSE           reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER         reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE          reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING          reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LSQUARE         reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! SEMICOLON       [ reduce using rule 32 (function_call -> IDENTIFIER LPAREN values RPAREN .) ]


state 148

    (33) function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LATE            reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER         reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LSQUARE         reduce using rule 33 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)


state 149

    (26) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 169


state 150

    (27) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LATE            reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 27 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 151

    (52) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (51) arithmetic -> arithmetic arith_op arithmetic .
    (51) arithmetic -> arithmetic . arith_op arithmetic
    (63) arith_op -> . PLUS
    (64) arith_op -> . MINUS
    (65) arith_op -> . TIMES
    (66) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    RPAREN          shift and go to state 170
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 51 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 64

state 152

    (59) logic -> LPAREN logic logic_op logic . RPAREN
    (58) logic -> logic logic_op logic .
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 171
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

  ! LOGICAL_AND     [ reduce using rule 58 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 58 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 69

state 153

    (56) comparison -> LPAREN comparison comp_op comparison . RPAREN
    (55) comparison -> comparison comp_op comparison .
    (55) comparison -> comparison . comp_op comparison
    (67) comp_op -> . EQUAL
    (68) comp_op -> . NOT_EQUAL
    (69) comp_op -> . LESS
    (70) comp_op -> . LESS_EQUAL
    (71) comp_op -> . GREATER
    (72) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    RPAREN          shift and go to state 172
    LOGICAL_AND     reduce using rule 55 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 55 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

  ! EQUAL           [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 55 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 89

state 154

    (28) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 173


state 155

    (115) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 174


state 156

    (116) for_statement -> FOR LPAREN assignment logic . SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (58) logic -> logic . logic_op logic
    (61) logic_op -> . LOGICAL_AND
    (62) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 175
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 157

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 112


state 158

    (56) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (55) comparison -> comparison . comp_op comparison
    (67) comp_op -> . EQUAL
    (68) comp_op -> . NOT_EQUAL
    (69) comp_op -> . LESS
    (70) comp_op -> . LESS_EQUAL
    (71) comp_op -> . GREATER
    (72) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

    comp_op                        shift and go to state 125

state 159

    (74) values -> value COMMA values .

    RSQUARE         reduce using rule 74 (values -> value COMMA values .)
    RPAREN          reduce using rule 74 (values -> value COMMA values .)


state 160

    (30) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    WHILE           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FOR             reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LATE            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 30 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 161

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (47) expression -> . arithmetic
    (48) expression -> . logic
    (49) expression -> . function_call
    (50) arithmetic -> . value
    (51) arithmetic -> . arithmetic arith_op arithmetic
    (52) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (57) logic -> . comparison
    (58) logic -> . logic logic_op logic
    (59) logic -> . LPAREN logic logic_op logic RPAREN
    (60) logic -> . LOGICAL_NOT logic
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) value -> . IDENTIFIER
    (76) value -> . number
    (77) value -> . string
    (78) value -> . list
    (53) comparison -> . value
    (54) comparison -> . boolean
    (55) comparison -> . comparison comp_op comparison
    (56) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (79) number -> . INTEGER
    (80) number -> . DOUBLE
    (81) string -> . STRING
    (84) list -> . LSQUARE RSQUARE
    (85) list -> . LSQUARE values RSQUARE
    (82) boolean -> . TRUE
    (83) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 176
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 162

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 177


state 163

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 178


state 164

    (15) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 165

    (104) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 104 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 104 (parameter -> type IDENTIFIER .)


state 166

    (86) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 179


state 167

    (102) parameters -> parameter COMMA . parameters
    (100) parameters -> . VOID
    (101) parameters -> . parameter
    (102) parameters -> . parameter COMMA parameters
    (103) parameters -> .
    (104) parameter -> . type IDENTIFIER
    (105) parameter -> . IDENTIFIER
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    VOID            shift and go to state 143
    RPAREN          reduce using rule 103 (parameters -> .)
    IDENTIFIER      shift and go to state 141
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42

    parameter                      shift and go to state 144
    parameters                     shift and go to state 180
    type                           shift and go to state 140

state 168

    (31) function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    WHILE           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LATE            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FINAL           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    CONST           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VOID            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RBRACE          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RPAREN          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LPAREN          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LOGICAL_NOT     reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    TRUE            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FALSE           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER         reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LSQUARE         reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)


state 169

    (26) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LATE            reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 26 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 170

    (52) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DIVIDE          reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LINE_BREAK      reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    PRINT           reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IF              reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    WHILE           reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FOR             reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LATE            reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FINAL           reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    CONST           reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER_TYPE    reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE_TYPE     reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    QUEUE_TYPE      reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING_TYPE     reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    ENUM_TYPE       reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VAR             reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LIST_TYPE       reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MAP_TYPE        reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SET_TYPE        reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VOID            reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RBRACE          reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LPAREN          reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LOGICAL_NOT     reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TRUE            reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FALSE           reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER         reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE          reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING          reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LSQUARE         reduce using rule 52 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 171

    (59) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    LINE_BREAK      reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    PRINT           reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    IF              reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    WHILE           reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    FOR             reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    IDENTIFIER      reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    LATE            reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    FINAL           reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    CONST           reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER_TYPE    reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE_TYPE     reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    QUEUE_TYPE      reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING_TYPE     reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    ENUM_TYPE       reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    VAR             reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    LIST_TYPE       reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    MAP_TYPE        reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    SET_TYPE        reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    VOID            reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    RBRACE          reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    LPAREN          reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_NOT     reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    TRUE            reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    FALSE           reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER         reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE          reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING          reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)
    LSQUARE         reduce using rule 59 (logic -> LPAREN logic logic_op logic RPAREN .)


state 172

    (56) comparison -> LPAREN comparison comp_op comparison RPAREN .

    EQUAL           reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    NOT_EQUAL       reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS            reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS_EQUAL      reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER         reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER_EQUAL   reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_AND     reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_OR      reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    $end            reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SEMICOLON       reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RPAREN          reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LINE_BREAK      reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    PRINT           reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    IF              reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    WHILE           reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    FOR             reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    IDENTIFIER      reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LATE            reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    FINAL           reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    CONST           reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    INTEGER_TYPE    reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    DOUBLE_TYPE     reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    BOOLEAN_TYPE    reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    QUEUE_TYPE      reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    STRING_TYPE     reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    ENUM_TYPE       reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    VAR             reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LIST_TYPE       reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    MAP_TYPE        reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SET_TYPE        reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    DYNAMIC_TYPE    reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    VOID            reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RBRACE          reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LPAREN          reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_NOT     reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    TRUE            reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    FALSE           reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    INTEGER         reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    DOUBLE          reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    STRING          reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LSQUARE         reduce using rule 56 (comparison -> LPAREN comparison comp_op comparison RPAREN .)


state 173

    (28) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 91 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    lines                          shift and go to state 181
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 174

    (115) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 91 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    lines                          shift and go to state 182
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 175

    (116) for_statement -> FOR LPAREN assignment logic SEMICOLON . reassignment RPAREN LBRACE lines RBRACE
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH

    IDENTIFIER      shift and go to state 184

    reassignment                   shift and go to state 183

state 176

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 185


state 177

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 178

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 179

    (86) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 91 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    type                           shift and go to state 16
    lines                          shift and go to state 186
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15

state 180

    (102) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 102 (parameters -> parameter COMMA parameters .)


state 181

    (28) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 187


state 182

    (115) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 188


state 183

    (116) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 189


state 184

    (17) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (20) reassignment -> IDENTIFIER . INLINE_ARITH number
    (21) reassignment -> IDENTIFIER . INLINE_ARITH

    ASSIGN          shift and go to state 76
    INLINE_ARITH    shift and go to state 77


state 185

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LOGICAL_NOT     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 186

    (86) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 190


state 187

    (28) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 28 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 188

    (115) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 115 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 189

    (116) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 191


state 190

    (86) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 86 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 191

    (116) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE . lines RBRACE
    (87) lines -> . line LINE_BREAK lines
    (88) lines -> . line lines
    (89) lines -> . line
    (90) lines -> . LINE_BREAK
    (91) lines -> .
    (92) line -> . print
    (93) line -> . assignment
    (94) line -> . function
    (95) line -> . if_statement
    (96) line -> . while_statement
    (97) line -> . for_statement
    (98) line -> . function_call
    (99) line -> . reassignment
    (26) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (86) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (28) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (29) if_statement -> . if_statement ELSE if_statement
    (30) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (115) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (116) for_statement -> . FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (32) function_call -> . IDENTIFIER LPAREN values RPAREN
    (33) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (34) function_call -> . IDENTIFIER LPAREN RPAREN
    (17) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (20) reassignment -> . IDENTIFIER INLINE_ARITH number
    (21) reassignment -> . IDENTIFIER INLINE_ARITH
    (23) modifier -> . LATE
    (24) modifier -> . FINAL
    (25) modifier -> . CONST
    (35) type -> . INTEGER_TYPE
    (36) type -> . DOUBLE_TYPE
    (37) type -> . BOOLEAN_TYPE
    (38) type -> . QUEUE_TYPE
    (39) type -> . STRING_TYPE
    (40) type -> . ENUM_TYPE
    (41) type -> . VAR
    (42) type -> . LIST_TYPE
    (43) type -> . MAP_TYPE
    (44) type -> . SET_TYPE
    (45) type -> . DYNAMIC_TYPE
    (46) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 91 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    assignment                     shift and go to state 56
    reassignment                   shift and go to state 62
    lines                          shift and go to state 192
    line                           shift and go to state 23
    print                          shift and go to state 55
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 192

    (116) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 193


state 193

    (116) for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 116 (for_statement -> FOR LPAREN assignment logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 96 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 96 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 102 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 108 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 114 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for LESS in state 131 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 131 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 152 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 152 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 153 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 153 resolved as shift
WARNING: shift/reduce conflict for LESS in state 153 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 153 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 153 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 153 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (statement -> while_statement)
WARNING: rejected rule (line -> while_statement) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (statement -> for_statement)
WARNING: rejected rule (line -> for_statement) in state 8
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> reassignment)
WARNING: rejected rule (line -> reassignment) in state 11
WARNING: reduce/reduce conflict in state 14 resolved using rule (expression -> function_call)
WARNING: rejected rule (line -> function_call) in state 14
WARNING: reduce/reduce conflict in state 23 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 23
WARNING: reduce/reduce conflict in state 26 resolved using rule (arithmetic -> value)
WARNING: rejected rule (comparison -> value) in state 26
WARNING: reduce/reduce conflict in state 87 resolved using rule (lines -> LINE_BREAK)
WARNING: rejected rule (lines -> <empty>) in state 87
