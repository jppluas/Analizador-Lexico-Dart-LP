Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOT
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FINALLY
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    IN
    INTERFACE
    IS
    KEYWORD
    LIBRARY
    NULL
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> reassignment
Rule 11    statement -> <empty>
Rule 12    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 16    reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 17    reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 18    reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 19    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 20    reassignment -> IDENTIFIER INLINE_ARITH
Rule 21    nullable -> QUESTION_MARK
Rule 22    modifier -> LATE
Rule 23    modifier -> FINAL
Rule 24    modifier -> CONST
Rule 25    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 26    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 27    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 28    if_statement -> if_statement ELSE if_statement
Rule 29    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 30    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 31    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 32    type -> INTEGER_TYPE
Rule 33    type -> DOUBLE_TYPE
Rule 34    type -> BOOLEAN_TYPE
Rule 35    type -> QUEUE_TYPE
Rule 36    type -> STRING_TYPE
Rule 37    type -> ENUM_TYPE
Rule 38    type -> VAR
Rule 39    type -> LIST_TYPE
Rule 40    type -> MAP_TYPE
Rule 41    type -> SET_TYPE
Rule 42    type -> DYNAMIC_TYPE
Rule 43    type -> VOID
Rule 44    expression -> arithmetic
Rule 45    expression -> logic
Rule 46    expression -> function_call
Rule 47    arithmetic -> value
Rule 48    arithmetic -> arithmetic arith_op arithmetic
Rule 49    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 50    comparison -> value
Rule 51    comparison -> boolean
Rule 52    comparison -> comparison comp_op comparison
Rule 53    comparison -> LPAREN comparison comp_op comparison RPAREN
Rule 54    logic -> comparison
Rule 55    logic -> logic logic_op logic
Rule 56    logic -> LPAREN logic logic_op logic RPAREN
Rule 57    logic -> LOGICAL_NOT logic
Rule 58    logic_op -> LOGICAL_AND
Rule 59    logic_op -> LOGICAL_OR
Rule 60    arith_op -> PLUS
Rule 61    arith_op -> MINUS
Rule 62    arith_op -> TIMES
Rule 63    arith_op -> DIVIDE
Rule 64    comp_op -> EQUAL
Rule 65    comp_op -> NOT_EQUAL
Rule 66    comp_op -> LESS
Rule 67    comp_op -> LESS_EQUAL
Rule 68    comp_op -> GREATER
Rule 69    comp_op -> GREATER_EQUAL
Rule 70    values -> value
Rule 71    values -> value COMMA values
Rule 72    value -> IDENTIFIER
Rule 73    value -> number
Rule 74    value -> string
Rule 75    value -> list
Rule 76    number -> INTEGER
Rule 77    number -> DOUBLE
Rule 78    string -> STRING
Rule 79    boolean -> TRUE
Rule 80    boolean -> FALSE
Rule 81    list -> LSQUARE RSQUARE
Rule 82    list -> LSQUARE values RSQUARE
Rule 83    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 84    lines -> line LINE_BREAK lines
Rule 85    lines -> line lines
Rule 86    lines -> line
Rule 87    lines -> LINE_BREAK
Rule 88    lines -> <empty>
Rule 89    line -> print
Rule 90    line -> assignment
Rule 91    line -> function
Rule 92    line -> if_statement
Rule 93    line -> while_statement
Rule 94    line -> for_statement
Rule 95    line -> function_call
Rule 96    line -> reassignment
Rule 97    parameters -> VOID
Rule 98    parameters -> parameter
Rule 99    parameters -> parameter COMMA parameters
Rule 100   parameters -> <empty>
Rule 101   parameter -> type IDENTIFIER
Rule 102   parameter -> IDENTIFIER
Rule 103   map -> MAP_TYPE LESS type COMMA type GREATER
Rule 104   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE values RSQUARE
Rule 105   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE RSQUARE
Rule 106   set -> SET_TYPE LESS type GREATER
Rule 107   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 108   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 109   queue -> QUEUE_TYPE LESS type GREATER
Rule 110   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 111   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 112   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 113   for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
AS                   : 
ASSERT               : 
ASSIGN               : 12 13 14 15 16
ASYNC                : 
AWAIT                : 
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 34
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 71 99 103 104 105
COMMENT              : 
CONST                : 24
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 63
DO                   : 
DOT                  : 
DOUBLE               : 77
DOUBLE_TYPE          : 33
DYNAMIC_TYPE         : 42
ELSE                 : 28 29
ENUM                 : 
ENUM_TYPE            : 37
EQUAL                : 64
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FALSE                : 80
FINAL                : 23
FINALLY              : 
FOR                  : 113
GET                  : 
GREATER              : 68 103 104 105 106 107 108 109 110 111
GREATER_EQUAL        : 69
HIDE                 : 
IDENTIFIER           : 12 13 14 15 16 17 18 19 20 30 31 72 83 101 102
IF                   : 27
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INLINE_ARITH         : 17 18 19 20
INTEGER              : 76
INTEGER_TYPE         : 32
INTERFACE            : 
IS                   : 
KEYWORD              : 
LATE                 : 22
LBRACE               : 9 27 29 83 112 113
LESS                 : 66 103 104 105 106 107 108 109 110 111
LESS_EQUAL           : 67
LIBRARY              : 
LINE_BREAK           : 84 87
LIST_TYPE            : 39
LOGICAL_AND          : 58
LOGICAL_NOT          : 57
LOGICAL_OR           : 59
LPAREN               : 25 26 27 30 31 49 53 56 83 112 113
LSQUARE              : 81 82 104 105 107 108 110 111
MAP_TYPE             : 40 103 104 105
MINUS                : 61
NOT_EQUAL            : 65
NULL                 : 
ON                   : 
OPERATOR             : 
PART                 : 
PLUS                 : 60
PRINT                : 25 26
QUESTION_MARK        : 21
QUEUE_TYPE           : 35 109 110 111
RBRACE               : 9 27 29 83 112 113
RETHROW              : 
RETURN               : 
RPAREN               : 25 26 27 30 31 49 53 56 83 112 113
RSQUARE              : 81 82 104 105 107 108 110 111
SEMICOLON            : 12 13 14 15 16 17 18 25 26 30 113 113
SET                  : 
SET_TYPE             : 41 106 107 108
SHOW                 : 
STATIC               : 
STRING               : 78
STRING_TYPE          : 36
SUPER                : 
SWITCH               : 
SYNC                 : 
THROW                : 
TIMES                : 62
TRUE                 : 79
TRY                  : 
TYPEDEF              : 
VAR                  : 38
VOID                 : 43 97
WHILE                : 112
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 48 49
arithmetic           : 44 48 48 49 49
assignment           : 2 90 113
boolean              : 51
comp_op              : 52 53
comparison           : 52 52 53 53 54
expression           : 1 12 13 14 15 16 25
for_statement        : 7 94
function             : 4 91
function_call        : 46 95
if_statement         : 5 28 28 29 92
line                 : 84 85 86
lines                : 8 9 27 29 83 84 85 112 113
list                 : 75
logic                : 27 45 55 55 56 56 57 112 113
logic_op             : 55 56
map                  : 
modifier             : 12 14
nullable             : 12 13
number               : 17 19 73
parameter            : 98 99
parameters           : 83 99
print                : 3 89
queue                : 
reassignment         : 10 96 113
set                  : 
statement            : 0
string               : 74
type                 : 12 13 14 15 83 101 103 103 104 104 105 105 106 107 108 109 110 111
value                : 47 50 70 71
values               : 30 31 71 82 104 107 110
while_statement      : 6 93

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> . reassignment
    (11) statement -> .
    (44) expression -> . arithmetic
    (45) expression -> . logic
    (46) expression -> . function_call
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE

  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
    LBRACE          shift and go to state 10
    $end            reduce using rule 11 (statement -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    LINE_BREAK      shift and go to state 24
    IDENTIFIER      shift and go to state 17
    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

  ! $end            [ reduce using rule 88 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    reassignment                   shift and go to state 11
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 14
    modifier                       shift and go to state 15
    type                           shift and go to state 16
    line                           shift and go to state 23
    number                         shift and go to state 25
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (90) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 90 (line -> assignment .)
    PRINT           reduce using rule 90 (line -> assignment .)
    IF              reduce using rule 90 (line -> assignment .)
    WHILE           reduce using rule 90 (line -> assignment .)
    FOR             reduce using rule 90 (line -> assignment .)
    IDENTIFIER      reduce using rule 90 (line -> assignment .)
    LATE            reduce using rule 90 (line -> assignment .)
    FINAL           reduce using rule 90 (line -> assignment .)
    CONST           reduce using rule 90 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 90 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 90 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 90 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 90 (line -> assignment .)
    STRING_TYPE     reduce using rule 90 (line -> assignment .)
    ENUM_TYPE       reduce using rule 90 (line -> assignment .)
    VAR             reduce using rule 90 (line -> assignment .)
    LIST_TYPE       reduce using rule 90 (line -> assignment .)
    MAP_TYPE        reduce using rule 90 (line -> assignment .)
    SET_TYPE        reduce using rule 90 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 90 (line -> assignment .)
    VOID            reduce using rule 90 (line -> assignment .)

  ! $end            [ reduce using rule 90 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (89) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 89 (line -> print .)
    PRINT           reduce using rule 89 (line -> print .)
    IF              reduce using rule 89 (line -> print .)
    WHILE           reduce using rule 89 (line -> print .)
    FOR             reduce using rule 89 (line -> print .)
    IDENTIFIER      reduce using rule 89 (line -> print .)
    LATE            reduce using rule 89 (line -> print .)
    FINAL           reduce using rule 89 (line -> print .)
    CONST           reduce using rule 89 (line -> print .)
    INTEGER_TYPE    reduce using rule 89 (line -> print .)
    DOUBLE_TYPE     reduce using rule 89 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 89 (line -> print .)
    QUEUE_TYPE      reduce using rule 89 (line -> print .)
    STRING_TYPE     reduce using rule 89 (line -> print .)
    ENUM_TYPE       reduce using rule 89 (line -> print .)
    VAR             reduce using rule 89 (line -> print .)
    LIST_TYPE       reduce using rule 89 (line -> print .)
    MAP_TYPE        reduce using rule 89 (line -> print .)
    SET_TYPE        reduce using rule 89 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 89 (line -> print .)
    VOID            reduce using rule 89 (line -> print .)

  ! $end            [ reduce using rule 89 (line -> print .) ]


state 5

    (4) statement -> function .
    (91) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 91 (line -> function .)
    PRINT           reduce using rule 91 (line -> function .)
    IF              reduce using rule 91 (line -> function .)
    WHILE           reduce using rule 91 (line -> function .)
    FOR             reduce using rule 91 (line -> function .)
    IDENTIFIER      reduce using rule 91 (line -> function .)
    LATE            reduce using rule 91 (line -> function .)
    FINAL           reduce using rule 91 (line -> function .)
    CONST           reduce using rule 91 (line -> function .)
    INTEGER_TYPE    reduce using rule 91 (line -> function .)
    DOUBLE_TYPE     reduce using rule 91 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 91 (line -> function .)
    QUEUE_TYPE      reduce using rule 91 (line -> function .)
    STRING_TYPE     reduce using rule 91 (line -> function .)
    ENUM_TYPE       reduce using rule 91 (line -> function .)
    VAR             reduce using rule 91 (line -> function .)
    LIST_TYPE       reduce using rule 91 (line -> function .)
    MAP_TYPE        reduce using rule 91 (line -> function .)
    SET_TYPE        reduce using rule 91 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 91 (line -> function .)
    VOID            reduce using rule 91 (line -> function .)

  ! $end            [ reduce using rule 91 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (28) if_statement -> if_statement . ELSE if_statement
    (29) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (92) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 53
    LINE_BREAK      reduce using rule 92 (line -> if_statement .)
    PRINT           reduce using rule 92 (line -> if_statement .)
    IF              reduce using rule 92 (line -> if_statement .)
    WHILE           reduce using rule 92 (line -> if_statement .)
    FOR             reduce using rule 92 (line -> if_statement .)
    IDENTIFIER      reduce using rule 92 (line -> if_statement .)
    LATE            reduce using rule 92 (line -> if_statement .)
    FINAL           reduce using rule 92 (line -> if_statement .)
    CONST           reduce using rule 92 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 92 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 92 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 92 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 92 (line -> if_statement .)
    STRING_TYPE     reduce using rule 92 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 92 (line -> if_statement .)
    VAR             reduce using rule 92 (line -> if_statement .)
    LIST_TYPE       reduce using rule 92 (line -> if_statement .)
    MAP_TYPE        reduce using rule 92 (line -> if_statement .)
    SET_TYPE        reduce using rule 92 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 92 (line -> if_statement .)
    VOID            reduce using rule 92 (line -> if_statement .)

  ! $end            [ reduce using rule 92 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .
    (93) line -> while_statement .

  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> while_statement .)
    $end            reduce using rule 6 (statement -> while_statement .)
    LINE_BREAK      reduce using rule 93 (line -> while_statement .)
    PRINT           reduce using rule 93 (line -> while_statement .)
    IF              reduce using rule 93 (line -> while_statement .)
    WHILE           reduce using rule 93 (line -> while_statement .)
    FOR             reduce using rule 93 (line -> while_statement .)
    IDENTIFIER      reduce using rule 93 (line -> while_statement .)
    LATE            reduce using rule 93 (line -> while_statement .)
    FINAL           reduce using rule 93 (line -> while_statement .)
    CONST           reduce using rule 93 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 93 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 93 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 93 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 93 (line -> while_statement .)
    STRING_TYPE     reduce using rule 93 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 93 (line -> while_statement .)
    VAR             reduce using rule 93 (line -> while_statement .)
    LIST_TYPE       reduce using rule 93 (line -> while_statement .)
    MAP_TYPE        reduce using rule 93 (line -> while_statement .)
    SET_TYPE        reduce using rule 93 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 93 (line -> while_statement .)
    VOID            reduce using rule 93 (line -> while_statement .)

  ! $end            [ reduce using rule 93 (line -> while_statement .) ]


state 8

    (7) statement -> for_statement .
    (94) line -> for_statement .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    LINE_BREAK      reduce using rule 94 (line -> for_statement .)
    PRINT           reduce using rule 94 (line -> for_statement .)
    IF              reduce using rule 94 (line -> for_statement .)
    WHILE           reduce using rule 94 (line -> for_statement .)
    FOR             reduce using rule 94 (line -> for_statement .)
    IDENTIFIER      reduce using rule 94 (line -> for_statement .)
    LATE            reduce using rule 94 (line -> for_statement .)
    FINAL           reduce using rule 94 (line -> for_statement .)
    CONST           reduce using rule 94 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 94 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 94 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 94 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 94 (line -> for_statement .)
    STRING_TYPE     reduce using rule 94 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 94 (line -> for_statement .)
    VAR             reduce using rule 94 (line -> for_statement .)
    LIST_TYPE       reduce using rule 94 (line -> for_statement .)
    MAP_TYPE        reduce using rule 94 (line -> for_statement .)
    SET_TYPE        reduce using rule 94 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 94 (line -> for_statement .)
    VOID            reduce using rule 94 (line -> for_statement .)

  ! $end            [ reduce using rule 94 (line -> for_statement .) ]


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 88 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    lines                          shift and go to state 54
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 11

    (10) statement -> reassignment .
    (96) line -> reassignment .

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> reassignment .)
    $end            reduce using rule 10 (statement -> reassignment .)
    LINE_BREAK      reduce using rule 96 (line -> reassignment .)
    PRINT           reduce using rule 96 (line -> reassignment .)
    IF              reduce using rule 96 (line -> reassignment .)
    WHILE           reduce using rule 96 (line -> reassignment .)
    FOR             reduce using rule 96 (line -> reassignment .)
    IDENTIFIER      reduce using rule 96 (line -> reassignment .)
    LATE            reduce using rule 96 (line -> reassignment .)
    FINAL           reduce using rule 96 (line -> reassignment .)
    CONST           reduce using rule 96 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 96 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 96 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 96 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 96 (line -> reassignment .)
    STRING_TYPE     reduce using rule 96 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 96 (line -> reassignment .)
    VAR             reduce using rule 96 (line -> reassignment .)
    LIST_TYPE       reduce using rule 96 (line -> reassignment .)
    MAP_TYPE        reduce using rule 96 (line -> reassignment .)
    SET_TYPE        reduce using rule 96 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 96 (line -> reassignment .)
    VOID            reduce using rule 96 (line -> reassignment .)

  ! $end            [ reduce using rule 96 (line -> reassignment .) ]


state 12

    (44) expression -> arithmetic .
    (48) arithmetic -> arithmetic . arith_op arithmetic
    (60) arith_op -> . PLUS
    (61) arith_op -> . MINUS
    (62) arith_op -> . TIMES
    (63) arith_op -> . DIVIDE

    $end            reduce using rule 44 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 44 (expression -> arithmetic .)
    RPAREN          reduce using rule 44 (expression -> arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

    arith_op                       shift and go to state 64

state 13

    (45) expression -> logic .
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

    $end            reduce using rule 45 (expression -> logic .)
    SEMICOLON       reduce using rule 45 (expression -> logic .)
    RPAREN          reduce using rule 45 (expression -> logic .)
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 14

    (46) expression -> function_call .
    (95) line -> function_call .

  ! reduce/reduce conflict for $end resolved using rule 46 (expression -> function_call .)
    $end            reduce using rule 46 (expression -> function_call .)
    LINE_BREAK      reduce using rule 95 (line -> function_call .)
    PRINT           reduce using rule 95 (line -> function_call .)
    IF              reduce using rule 95 (line -> function_call .)
    WHILE           reduce using rule 95 (line -> function_call .)
    FOR             reduce using rule 95 (line -> function_call .)
    IDENTIFIER      reduce using rule 95 (line -> function_call .)
    LATE            reduce using rule 95 (line -> function_call .)
    FINAL           reduce using rule 95 (line -> function_call .)
    CONST           reduce using rule 95 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 95 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 95 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 95 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 95 (line -> function_call .)
    STRING_TYPE     reduce using rule 95 (line -> function_call .)
    ENUM_TYPE       reduce using rule 95 (line -> function_call .)
    VAR             reduce using rule 95 (line -> function_call .)
    LIST_TYPE       reduce using rule 95 (line -> function_call .)
    MAP_TYPE        reduce using rule 95 (line -> function_call .)
    SET_TYPE        reduce using rule 95 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 95 (line -> function_call .)
    VOID            reduce using rule 95 (line -> function_call .)

  ! $end            [ reduce using rule 95 (line -> function_call .) ]


state 15

    (12) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    type                           shift and go to state 72

state 16

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (21) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 74
    QUESTION_MARK   shift and go to state 75

    nullable                       shift and go to state 73

state 17

    (16) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (17) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH number
    (20) reassignment -> IDENTIFIER . INLINE_ARITH
    (30) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (31) function_call -> IDENTIFIER . LPAREN values RPAREN
    (72) value -> IDENTIFIER .

    ASSIGN          shift and go to state 76
    INLINE_ARITH    shift and go to state 77
    LPAREN          shift and go to state 78
    PLUS            reduce using rule 72 (value -> IDENTIFIER .)
    MINUS           reduce using rule 72 (value -> IDENTIFIER .)
    TIMES           reduce using rule 72 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 72 (value -> IDENTIFIER .)
    $end            reduce using rule 72 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 72 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 72 (value -> IDENTIFIER .)
    LESS            reduce using rule 72 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 72 (value -> IDENTIFIER .)
    GREATER         reduce using rule 72 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 72 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 72 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 72 (value -> IDENTIFIER .)


state 18

    (25) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (26) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 79


state 19

    (49) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (56) logic -> LPAREN . logic logic_op logic RPAREN
    (53) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 80
    logic                          shift and go to state 81
    comparison                     shift and go to state 82
    value                          shift and go to state 26
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 20

    (27) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 84


state 21

    (112) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 85


state 22

    (113) for_statement -> FOR . LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 86


state 23

    (84) lines -> line . LINE_BREAK lines
    (85) lines -> line . lines
    (86) lines -> line .
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 86 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 86 (lines -> line .)
    LINE_BREAK      shift and go to state 87
    $end            reduce using rule 86 (lines -> line .)
    RBRACE          reduce using rule 86 (lines -> line .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

  ! $end            [ reduce using rule 88 (lines -> .) ]
  ! RBRACE          [ reduce using rule 88 (lines -> .) ]

    line                           shift and go to state 23
    lines                          shift and go to state 88
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 24

    (87) lines -> LINE_BREAK .

    $end            reduce using rule 87 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 87 (lines -> LINE_BREAK .)


state 25

    (73) value -> number .

    PLUS            reduce using rule 73 (value -> number .)
    MINUS           reduce using rule 73 (value -> number .)
    TIMES           reduce using rule 73 (value -> number .)
    DIVIDE          reduce using rule 73 (value -> number .)
    $end            reduce using rule 73 (value -> number .)
    EQUAL           reduce using rule 73 (value -> number .)
    NOT_EQUAL       reduce using rule 73 (value -> number .)
    LESS            reduce using rule 73 (value -> number .)
    LESS_EQUAL      reduce using rule 73 (value -> number .)
    GREATER         reduce using rule 73 (value -> number .)
    GREATER_EQUAL   reduce using rule 73 (value -> number .)
    LOGICAL_AND     reduce using rule 73 (value -> number .)
    LOGICAL_OR      reduce using rule 73 (value -> number .)
    SEMICOLON       reduce using rule 73 (value -> number .)
    RPAREN          reduce using rule 73 (value -> number .)
    COMMA           reduce using rule 73 (value -> number .)
    RSQUARE         reduce using rule 73 (value -> number .)


state 26

    (47) arithmetic -> value .
    (50) comparison -> value .

  ! reduce/reduce conflict for $end resolved using rule 47 (arithmetic -> value .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 47 (arithmetic -> value .)
  ! reduce/reduce conflict for RPAREN resolved using rule 47 (arithmetic -> value .)
    PLUS            reduce using rule 47 (arithmetic -> value .)
    MINUS           reduce using rule 47 (arithmetic -> value .)
    TIMES           reduce using rule 47 (arithmetic -> value .)
    DIVIDE          reduce using rule 47 (arithmetic -> value .)
    $end            reduce using rule 47 (arithmetic -> value .)
    SEMICOLON       reduce using rule 47 (arithmetic -> value .)
    RPAREN          reduce using rule 47 (arithmetic -> value .)
    EQUAL           reduce using rule 50 (comparison -> value .)
    NOT_EQUAL       reduce using rule 50 (comparison -> value .)
    LESS            reduce using rule 50 (comparison -> value .)
    LESS_EQUAL      reduce using rule 50 (comparison -> value .)
    GREATER         reduce using rule 50 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 50 (comparison -> value .)
    LOGICAL_AND     reduce using rule 50 (comparison -> value .)
    LOGICAL_OR      reduce using rule 50 (comparison -> value .)

  ! $end            [ reduce using rule 50 (comparison -> value .) ]
  ! SEMICOLON       [ reduce using rule 50 (comparison -> value .) ]
  ! RPAREN          [ reduce using rule 50 (comparison -> value .) ]


state 27

    (54) logic -> comparison .
    (52) comparison -> comparison . comp_op comparison
    (64) comp_op -> . EQUAL
    (65) comp_op -> . NOT_EQUAL
    (66) comp_op -> . LESS
    (67) comp_op -> . LESS_EQUAL
    (68) comp_op -> . GREATER
    (69) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 54 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 54 (logic -> comparison .)
    $end            reduce using rule 54 (logic -> comparison .)
    SEMICOLON       reduce using rule 54 (logic -> comparison .)
    RPAREN          reduce using rule 54 (logic -> comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

    comp_op                        shift and go to state 89

state 28

    (57) logic -> LOGICAL_NOT . logic
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 96
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 29

    (22) modifier -> LATE .

    INTEGER_TYPE    reduce using rule 22 (modifier -> LATE .)
    DOUBLE_TYPE     reduce using rule 22 (modifier -> LATE .)
    BOOLEAN_TYPE    reduce using rule 22 (modifier -> LATE .)
    QUEUE_TYPE      reduce using rule 22 (modifier -> LATE .)
    STRING_TYPE     reduce using rule 22 (modifier -> LATE .)
    ENUM_TYPE       reduce using rule 22 (modifier -> LATE .)
    VAR             reduce using rule 22 (modifier -> LATE .)
    LIST_TYPE       reduce using rule 22 (modifier -> LATE .)
    MAP_TYPE        reduce using rule 22 (modifier -> LATE .)
    SET_TYPE        reduce using rule 22 (modifier -> LATE .)
    DYNAMIC_TYPE    reduce using rule 22 (modifier -> LATE .)
    VOID            reduce using rule 22 (modifier -> LATE .)


state 30

    (23) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 23 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 23 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 23 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 23 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 23 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 23 (modifier -> FINAL .)
    VAR             reduce using rule 23 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 23 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 23 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 23 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 23 (modifier -> FINAL .)
    VOID            reduce using rule 23 (modifier -> FINAL .)


state 31

    (24) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 24 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 24 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 24 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 24 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 24 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 24 (modifier -> CONST .)
    VAR             reduce using rule 24 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 24 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 24 (modifier -> CONST .)
    SET_TYPE        reduce using rule 24 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 24 (modifier -> CONST .)
    VOID            reduce using rule 24 (modifier -> CONST .)


state 32

    (32) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 32 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 32 (type -> INTEGER_TYPE .)


state 33

    (33) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 33 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 33 (type -> DOUBLE_TYPE .)


state 34

    (34) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 34 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 34 (type -> BOOLEAN_TYPE .)


state 35

    (35) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 35 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 35 (type -> QUEUE_TYPE .)


state 36

    (36) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 36 (type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 36 (type -> STRING_TYPE .)


state 37

    (37) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 37 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 37 (type -> ENUM_TYPE .)


state 38

    (38) type -> VAR .

    IDENTIFIER      reduce using rule 38 (type -> VAR .)
    QUESTION_MARK   reduce using rule 38 (type -> VAR .)


state 39

    (39) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 39 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 39 (type -> LIST_TYPE .)


state 40

    (40) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 40 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 40 (type -> MAP_TYPE .)


state 41

    (41) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 41 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 41 (type -> SET_TYPE .)


state 42

    (42) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 42 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 42 (type -> DYNAMIC_TYPE .)


state 43

    (43) type -> VOID .

    IDENTIFIER      reduce using rule 43 (type -> VOID .)
    QUESTION_MARK   reduce using rule 43 (type -> VOID .)


state 44

    (74) value -> string .

    PLUS            reduce using rule 74 (value -> string .)
    MINUS           reduce using rule 74 (value -> string .)
    TIMES           reduce using rule 74 (value -> string .)
    DIVIDE          reduce using rule 74 (value -> string .)
    $end            reduce using rule 74 (value -> string .)
    EQUAL           reduce using rule 74 (value -> string .)
    NOT_EQUAL       reduce using rule 74 (value -> string .)
    LESS            reduce using rule 74 (value -> string .)
    LESS_EQUAL      reduce using rule 74 (value -> string .)
    GREATER         reduce using rule 74 (value -> string .)
    GREATER_EQUAL   reduce using rule 74 (value -> string .)
    LOGICAL_AND     reduce using rule 74 (value -> string .)
    LOGICAL_OR      reduce using rule 74 (value -> string .)
    SEMICOLON       reduce using rule 74 (value -> string .)
    RPAREN          reduce using rule 74 (value -> string .)
    COMMA           reduce using rule 74 (value -> string .)
    RSQUARE         reduce using rule 74 (value -> string .)


state 45

    (75) value -> list .

    PLUS            reduce using rule 75 (value -> list .)
    MINUS           reduce using rule 75 (value -> list .)
    TIMES           reduce using rule 75 (value -> list .)
    DIVIDE          reduce using rule 75 (value -> list .)
    $end            reduce using rule 75 (value -> list .)
    EQUAL           reduce using rule 75 (value -> list .)
    NOT_EQUAL       reduce using rule 75 (value -> list .)
    LESS            reduce using rule 75 (value -> list .)
    LESS_EQUAL      reduce using rule 75 (value -> list .)
    GREATER         reduce using rule 75 (value -> list .)
    GREATER_EQUAL   reduce using rule 75 (value -> list .)
    LOGICAL_AND     reduce using rule 75 (value -> list .)
    LOGICAL_OR      reduce using rule 75 (value -> list .)
    SEMICOLON       reduce using rule 75 (value -> list .)
    RPAREN          reduce using rule 75 (value -> list .)
    COMMA           reduce using rule 75 (value -> list .)
    RSQUARE         reduce using rule 75 (value -> list .)


state 46

    (51) comparison -> boolean .

    EQUAL           reduce using rule 51 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 51 (comparison -> boolean .)
    LESS            reduce using rule 51 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 51 (comparison -> boolean .)
    GREATER         reduce using rule 51 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 51 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 51 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 51 (comparison -> boolean .)
    $end            reduce using rule 51 (comparison -> boolean .)
    SEMICOLON       reduce using rule 51 (comparison -> boolean .)
    RPAREN          reduce using rule 51 (comparison -> boolean .)


state 47

    (76) number -> INTEGER .

    PLUS            reduce using rule 76 (number -> INTEGER .)
    MINUS           reduce using rule 76 (number -> INTEGER .)
    TIMES           reduce using rule 76 (number -> INTEGER .)
    DIVIDE          reduce using rule 76 (number -> INTEGER .)
    $end            reduce using rule 76 (number -> INTEGER .)
    EQUAL           reduce using rule 76 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 76 (number -> INTEGER .)
    LESS            reduce using rule 76 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 76 (number -> INTEGER .)
    GREATER         reduce using rule 76 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 76 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 76 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 76 (number -> INTEGER .)
    SEMICOLON       reduce using rule 76 (number -> INTEGER .)
    RPAREN          reduce using rule 76 (number -> INTEGER .)
    COMMA           reduce using rule 76 (number -> INTEGER .)
    RSQUARE         reduce using rule 76 (number -> INTEGER .)
    LINE_BREAK      reduce using rule 76 (number -> INTEGER .)
    PRINT           reduce using rule 76 (number -> INTEGER .)
    IF              reduce using rule 76 (number -> INTEGER .)
    WHILE           reduce using rule 76 (number -> INTEGER .)
    FOR             reduce using rule 76 (number -> INTEGER .)
    IDENTIFIER      reduce using rule 76 (number -> INTEGER .)
    LATE            reduce using rule 76 (number -> INTEGER .)
    FINAL           reduce using rule 76 (number -> INTEGER .)
    CONST           reduce using rule 76 (number -> INTEGER .)
    INTEGER_TYPE    reduce using rule 76 (number -> INTEGER .)
    DOUBLE_TYPE     reduce using rule 76 (number -> INTEGER .)
    BOOLEAN_TYPE    reduce using rule 76 (number -> INTEGER .)
    QUEUE_TYPE      reduce using rule 76 (number -> INTEGER .)
    STRING_TYPE     reduce using rule 76 (number -> INTEGER .)
    ENUM_TYPE       reduce using rule 76 (number -> INTEGER .)
    VAR             reduce using rule 76 (number -> INTEGER .)
    LIST_TYPE       reduce using rule 76 (number -> INTEGER .)
    MAP_TYPE        reduce using rule 76 (number -> INTEGER .)
    SET_TYPE        reduce using rule 76 (number -> INTEGER .)
    DYNAMIC_TYPE    reduce using rule 76 (number -> INTEGER .)
    VOID            reduce using rule 76 (number -> INTEGER .)
    RBRACE          reduce using rule 76 (number -> INTEGER .)


state 48

    (77) number -> DOUBLE .

    PLUS            reduce using rule 77 (number -> DOUBLE .)
    MINUS           reduce using rule 77 (number -> DOUBLE .)
    TIMES           reduce using rule 77 (number -> DOUBLE .)
    DIVIDE          reduce using rule 77 (number -> DOUBLE .)
    $end            reduce using rule 77 (number -> DOUBLE .)
    EQUAL           reduce using rule 77 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 77 (number -> DOUBLE .)
    LESS            reduce using rule 77 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 77 (number -> DOUBLE .)
    GREATER         reduce using rule 77 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 77 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 77 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 77 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 77 (number -> DOUBLE .)
    RPAREN          reduce using rule 77 (number -> DOUBLE .)
    COMMA           reduce using rule 77 (number -> DOUBLE .)
    RSQUARE         reduce using rule 77 (number -> DOUBLE .)
    LINE_BREAK      reduce using rule 77 (number -> DOUBLE .)
    PRINT           reduce using rule 77 (number -> DOUBLE .)
    IF              reduce using rule 77 (number -> DOUBLE .)
    WHILE           reduce using rule 77 (number -> DOUBLE .)
    FOR             reduce using rule 77 (number -> DOUBLE .)
    IDENTIFIER      reduce using rule 77 (number -> DOUBLE .)
    LATE            reduce using rule 77 (number -> DOUBLE .)
    FINAL           reduce using rule 77 (number -> DOUBLE .)
    CONST           reduce using rule 77 (number -> DOUBLE .)
    INTEGER_TYPE    reduce using rule 77 (number -> DOUBLE .)
    DOUBLE_TYPE     reduce using rule 77 (number -> DOUBLE .)
    BOOLEAN_TYPE    reduce using rule 77 (number -> DOUBLE .)
    QUEUE_TYPE      reduce using rule 77 (number -> DOUBLE .)
    STRING_TYPE     reduce using rule 77 (number -> DOUBLE .)
    ENUM_TYPE       reduce using rule 77 (number -> DOUBLE .)
    VAR             reduce using rule 77 (number -> DOUBLE .)
    LIST_TYPE       reduce using rule 77 (number -> DOUBLE .)
    MAP_TYPE        reduce using rule 77 (number -> DOUBLE .)
    SET_TYPE        reduce using rule 77 (number -> DOUBLE .)
    DYNAMIC_TYPE    reduce using rule 77 (number -> DOUBLE .)
    VOID            reduce using rule 77 (number -> DOUBLE .)
    RBRACE          reduce using rule 77 (number -> DOUBLE .)


state 49

    (78) string -> STRING .

    PLUS            reduce using rule 78 (string -> STRING .)
    MINUS           reduce using rule 78 (string -> STRING .)
    TIMES           reduce using rule 78 (string -> STRING .)
    DIVIDE          reduce using rule 78 (string -> STRING .)
    $end            reduce using rule 78 (string -> STRING .)
    EQUAL           reduce using rule 78 (string -> STRING .)
    NOT_EQUAL       reduce using rule 78 (string -> STRING .)
    LESS            reduce using rule 78 (string -> STRING .)
    LESS_EQUAL      reduce using rule 78 (string -> STRING .)
    GREATER         reduce using rule 78 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 78 (string -> STRING .)
    LOGICAL_AND     reduce using rule 78 (string -> STRING .)
    LOGICAL_OR      reduce using rule 78 (string -> STRING .)
    SEMICOLON       reduce using rule 78 (string -> STRING .)
    RPAREN          reduce using rule 78 (string -> STRING .)
    COMMA           reduce using rule 78 (string -> STRING .)
    RSQUARE         reduce using rule 78 (string -> STRING .)


state 50

    (81) list -> LSQUARE . RSQUARE
    (82) list -> LSQUARE . values RSQUARE
    (70) values -> . value
    (71) values -> . value COMMA values
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 99
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    values                         shift and go to state 100
    value                          shift and go to state 101
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 51

    (79) boolean -> TRUE .

    EQUAL           reduce using rule 79 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 79 (boolean -> TRUE .)
    LESS            reduce using rule 79 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 79 (boolean -> TRUE .)
    GREATER         reduce using rule 79 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 79 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 79 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 79 (boolean -> TRUE .)
    $end            reduce using rule 79 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 79 (boolean -> TRUE .)
    RPAREN          reduce using rule 79 (boolean -> TRUE .)


state 52

    (80) boolean -> FALSE .

    EQUAL           reduce using rule 80 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 80 (boolean -> FALSE .)
    LESS            reduce using rule 80 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 80 (boolean -> FALSE .)
    GREATER         reduce using rule 80 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 80 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 80 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 80 (boolean -> FALSE .)
    $end            reduce using rule 80 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 80 (boolean -> FALSE .)
    RPAREN          reduce using rule 80 (boolean -> FALSE .)


state 53

    (28) if_statement -> if_statement ELSE . if_statement
    (29) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 103
    IF              shift and go to state 20

    if_statement                   shift and go to state 102

state 54

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 104


state 55

    (89) line -> print .

    LINE_BREAK      reduce using rule 89 (line -> print .)
    PRINT           reduce using rule 89 (line -> print .)
    IF              reduce using rule 89 (line -> print .)
    WHILE           reduce using rule 89 (line -> print .)
    FOR             reduce using rule 89 (line -> print .)
    IDENTIFIER      reduce using rule 89 (line -> print .)
    LATE            reduce using rule 89 (line -> print .)
    FINAL           reduce using rule 89 (line -> print .)
    CONST           reduce using rule 89 (line -> print .)
    INTEGER_TYPE    reduce using rule 89 (line -> print .)
    DOUBLE_TYPE     reduce using rule 89 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 89 (line -> print .)
    QUEUE_TYPE      reduce using rule 89 (line -> print .)
    STRING_TYPE     reduce using rule 89 (line -> print .)
    ENUM_TYPE       reduce using rule 89 (line -> print .)
    VAR             reduce using rule 89 (line -> print .)
    LIST_TYPE       reduce using rule 89 (line -> print .)
    MAP_TYPE        reduce using rule 89 (line -> print .)
    SET_TYPE        reduce using rule 89 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 89 (line -> print .)
    VOID            reduce using rule 89 (line -> print .)
    RBRACE          reduce using rule 89 (line -> print .)
    $end            reduce using rule 89 (line -> print .)


state 56

    (90) line -> assignment .

    LINE_BREAK      reduce using rule 90 (line -> assignment .)
    PRINT           reduce using rule 90 (line -> assignment .)
    IF              reduce using rule 90 (line -> assignment .)
    WHILE           reduce using rule 90 (line -> assignment .)
    FOR             reduce using rule 90 (line -> assignment .)
    IDENTIFIER      reduce using rule 90 (line -> assignment .)
    LATE            reduce using rule 90 (line -> assignment .)
    FINAL           reduce using rule 90 (line -> assignment .)
    CONST           reduce using rule 90 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 90 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 90 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 90 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 90 (line -> assignment .)
    STRING_TYPE     reduce using rule 90 (line -> assignment .)
    ENUM_TYPE       reduce using rule 90 (line -> assignment .)
    VAR             reduce using rule 90 (line -> assignment .)
    LIST_TYPE       reduce using rule 90 (line -> assignment .)
    MAP_TYPE        reduce using rule 90 (line -> assignment .)
    SET_TYPE        reduce using rule 90 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 90 (line -> assignment .)
    VOID            reduce using rule 90 (line -> assignment .)
    RBRACE          reduce using rule 90 (line -> assignment .)
    $end            reduce using rule 90 (line -> assignment .)


state 57

    (91) line -> function .

    LINE_BREAK      reduce using rule 91 (line -> function .)
    PRINT           reduce using rule 91 (line -> function .)
    IF              reduce using rule 91 (line -> function .)
    WHILE           reduce using rule 91 (line -> function .)
    FOR             reduce using rule 91 (line -> function .)
    IDENTIFIER      reduce using rule 91 (line -> function .)
    LATE            reduce using rule 91 (line -> function .)
    FINAL           reduce using rule 91 (line -> function .)
    CONST           reduce using rule 91 (line -> function .)
    INTEGER_TYPE    reduce using rule 91 (line -> function .)
    DOUBLE_TYPE     reduce using rule 91 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 91 (line -> function .)
    QUEUE_TYPE      reduce using rule 91 (line -> function .)
    STRING_TYPE     reduce using rule 91 (line -> function .)
    ENUM_TYPE       reduce using rule 91 (line -> function .)
    VAR             reduce using rule 91 (line -> function .)
    LIST_TYPE       reduce using rule 91 (line -> function .)
    MAP_TYPE        reduce using rule 91 (line -> function .)
    SET_TYPE        reduce using rule 91 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 91 (line -> function .)
    VOID            reduce using rule 91 (line -> function .)
    RBRACE          reduce using rule 91 (line -> function .)
    $end            reduce using rule 91 (line -> function .)


state 58

    (92) line -> if_statement .
    (28) if_statement -> if_statement . ELSE if_statement
    (29) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 92 (line -> if_statement .)
    PRINT           reduce using rule 92 (line -> if_statement .)
    IF              reduce using rule 92 (line -> if_statement .)
    WHILE           reduce using rule 92 (line -> if_statement .)
    FOR             reduce using rule 92 (line -> if_statement .)
    IDENTIFIER      reduce using rule 92 (line -> if_statement .)
    LATE            reduce using rule 92 (line -> if_statement .)
    FINAL           reduce using rule 92 (line -> if_statement .)
    CONST           reduce using rule 92 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 92 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 92 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 92 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 92 (line -> if_statement .)
    STRING_TYPE     reduce using rule 92 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 92 (line -> if_statement .)
    VAR             reduce using rule 92 (line -> if_statement .)
    LIST_TYPE       reduce using rule 92 (line -> if_statement .)
    MAP_TYPE        reduce using rule 92 (line -> if_statement .)
    SET_TYPE        reduce using rule 92 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 92 (line -> if_statement .)
    VOID            reduce using rule 92 (line -> if_statement .)
    RBRACE          reduce using rule 92 (line -> if_statement .)
    $end            reduce using rule 92 (line -> if_statement .)
    ELSE            shift and go to state 53


state 59

    (93) line -> while_statement .

    LINE_BREAK      reduce using rule 93 (line -> while_statement .)
    PRINT           reduce using rule 93 (line -> while_statement .)
    IF              reduce using rule 93 (line -> while_statement .)
    WHILE           reduce using rule 93 (line -> while_statement .)
    FOR             reduce using rule 93 (line -> while_statement .)
    IDENTIFIER      reduce using rule 93 (line -> while_statement .)
    LATE            reduce using rule 93 (line -> while_statement .)
    FINAL           reduce using rule 93 (line -> while_statement .)
    CONST           reduce using rule 93 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 93 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 93 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 93 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 93 (line -> while_statement .)
    STRING_TYPE     reduce using rule 93 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 93 (line -> while_statement .)
    VAR             reduce using rule 93 (line -> while_statement .)
    LIST_TYPE       reduce using rule 93 (line -> while_statement .)
    MAP_TYPE        reduce using rule 93 (line -> while_statement .)
    SET_TYPE        reduce using rule 93 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 93 (line -> while_statement .)
    VOID            reduce using rule 93 (line -> while_statement .)
    RBRACE          reduce using rule 93 (line -> while_statement .)
    $end            reduce using rule 93 (line -> while_statement .)


state 60

    (94) line -> for_statement .

    LINE_BREAK      reduce using rule 94 (line -> for_statement .)
    PRINT           reduce using rule 94 (line -> for_statement .)
    IF              reduce using rule 94 (line -> for_statement .)
    WHILE           reduce using rule 94 (line -> for_statement .)
    FOR             reduce using rule 94 (line -> for_statement .)
    IDENTIFIER      reduce using rule 94 (line -> for_statement .)
    LATE            reduce using rule 94 (line -> for_statement .)
    FINAL           reduce using rule 94 (line -> for_statement .)
    CONST           reduce using rule 94 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 94 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 94 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 94 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 94 (line -> for_statement .)
    STRING_TYPE     reduce using rule 94 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 94 (line -> for_statement .)
    VAR             reduce using rule 94 (line -> for_statement .)
    LIST_TYPE       reduce using rule 94 (line -> for_statement .)
    MAP_TYPE        reduce using rule 94 (line -> for_statement .)
    SET_TYPE        reduce using rule 94 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 94 (line -> for_statement .)
    VOID            reduce using rule 94 (line -> for_statement .)
    RBRACE          reduce using rule 94 (line -> for_statement .)
    $end            reduce using rule 94 (line -> for_statement .)


state 61

    (95) line -> function_call .

    LINE_BREAK      reduce using rule 95 (line -> function_call .)
    PRINT           reduce using rule 95 (line -> function_call .)
    IF              reduce using rule 95 (line -> function_call .)
    WHILE           reduce using rule 95 (line -> function_call .)
    FOR             reduce using rule 95 (line -> function_call .)
    IDENTIFIER      reduce using rule 95 (line -> function_call .)
    LATE            reduce using rule 95 (line -> function_call .)
    FINAL           reduce using rule 95 (line -> function_call .)
    CONST           reduce using rule 95 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 95 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 95 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 95 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 95 (line -> function_call .)
    STRING_TYPE     reduce using rule 95 (line -> function_call .)
    ENUM_TYPE       reduce using rule 95 (line -> function_call .)
    VAR             reduce using rule 95 (line -> function_call .)
    LIST_TYPE       reduce using rule 95 (line -> function_call .)
    MAP_TYPE        reduce using rule 95 (line -> function_call .)
    SET_TYPE        reduce using rule 95 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 95 (line -> function_call .)
    VOID            reduce using rule 95 (line -> function_call .)
    RBRACE          reduce using rule 95 (line -> function_call .)
    $end            reduce using rule 95 (line -> function_call .)


state 62

    (96) line -> reassignment .

    LINE_BREAK      reduce using rule 96 (line -> reassignment .)
    PRINT           reduce using rule 96 (line -> reassignment .)
    IF              reduce using rule 96 (line -> reassignment .)
    WHILE           reduce using rule 96 (line -> reassignment .)
    FOR             reduce using rule 96 (line -> reassignment .)
    IDENTIFIER      reduce using rule 96 (line -> reassignment .)
    LATE            reduce using rule 96 (line -> reassignment .)
    FINAL           reduce using rule 96 (line -> reassignment .)
    CONST           reduce using rule 96 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 96 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 96 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 96 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 96 (line -> reassignment .)
    STRING_TYPE     reduce using rule 96 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 96 (line -> reassignment .)
    VAR             reduce using rule 96 (line -> reassignment .)
    LIST_TYPE       reduce using rule 96 (line -> reassignment .)
    MAP_TYPE        reduce using rule 96 (line -> reassignment .)
    SET_TYPE        reduce using rule 96 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 96 (line -> reassignment .)
    VOID            reduce using rule 96 (line -> reassignment .)
    RBRACE          reduce using rule 96 (line -> reassignment .)
    $end            reduce using rule 96 (line -> reassignment .)


state 63

    (30) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (31) function_call -> IDENTIFIER . LPAREN values RPAREN
    (16) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (17) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH number
    (20) reassignment -> IDENTIFIER . INLINE_ARITH

    LPAREN          shift and go to state 78
    ASSIGN          shift and go to state 76
    INLINE_ARITH    shift and go to state 77


state 64

    (48) arithmetic -> arithmetic arith_op . arithmetic
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 105
    value                          shift and go to state 106
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 65

    (60) arith_op -> PLUS .

    LPAREN          reduce using rule 60 (arith_op -> PLUS .)
    IDENTIFIER      reduce using rule 60 (arith_op -> PLUS .)
    INTEGER         reduce using rule 60 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 60 (arith_op -> PLUS .)
    STRING          reduce using rule 60 (arith_op -> PLUS .)
    LSQUARE         reduce using rule 60 (arith_op -> PLUS .)


state 66

    (61) arith_op -> MINUS .

    LPAREN          reduce using rule 61 (arith_op -> MINUS .)
    IDENTIFIER      reduce using rule 61 (arith_op -> MINUS .)
    INTEGER         reduce using rule 61 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 61 (arith_op -> MINUS .)
    STRING          reduce using rule 61 (arith_op -> MINUS .)
    LSQUARE         reduce using rule 61 (arith_op -> MINUS .)


state 67

    (62) arith_op -> TIMES .

    LPAREN          reduce using rule 62 (arith_op -> TIMES .)
    IDENTIFIER      reduce using rule 62 (arith_op -> TIMES .)
    INTEGER         reduce using rule 62 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 62 (arith_op -> TIMES .)
    STRING          reduce using rule 62 (arith_op -> TIMES .)
    LSQUARE         reduce using rule 62 (arith_op -> TIMES .)


state 68

    (63) arith_op -> DIVIDE .

    LPAREN          reduce using rule 63 (arith_op -> DIVIDE .)
    IDENTIFIER      reduce using rule 63 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 63 (arith_op -> DIVIDE .)
    DOUBLE          reduce using rule 63 (arith_op -> DIVIDE .)
    STRING          reduce using rule 63 (arith_op -> DIVIDE .)
    LSQUARE         reduce using rule 63 (arith_op -> DIVIDE .)


state 69

    (55) logic -> logic logic_op . logic
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 108
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 70

    (58) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 58 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 58 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 58 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 58 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 58 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 58 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 58 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 58 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 58 (logic_op -> LOGICAL_AND .)


state 71

    (59) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 59 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 59 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 59 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 59 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 59 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 59 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 59 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 59 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 59 (logic_op -> LOGICAL_OR .)


state 72

    (12) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (21) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 110
    QUESTION_MARK   shift and go to state 75

    nullable                       shift and go to state 109

state 73

    (13) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 111


state 74

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (83) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 112
    LPAREN          shift and go to state 113


state 75

    (21) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 21 (nullable -> QUESTION_MARK .)


state 76

    (16) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (44) expression -> . arithmetic
    (45) expression -> . logic
    (46) expression -> . function_call
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 115
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 77

    (17) reassignment -> IDENTIFIER INLINE_ARITH . number SEMICOLON
    (18) reassignment -> IDENTIFIER INLINE_ARITH . SEMICOLON
    (19) reassignment -> IDENTIFIER INLINE_ARITH . number
    (20) reassignment -> IDENTIFIER INLINE_ARITH .
    (76) number -> . INTEGER
    (77) number -> . DOUBLE

    SEMICOLON       shift and go to state 118
    $end            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LINE_BREAK      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    PRINT           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IF              reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    WHILE           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FOR             reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IDENTIFIER      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LATE            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FINAL           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    CONST           reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DOUBLE_TYPE     reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    BOOLEAN_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    QUEUE_TYPE      reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    STRING_TYPE     reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    ENUM_TYPE       reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VAR             reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LIST_TYPE       reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    MAP_TYPE        reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    SET_TYPE        reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DYNAMIC_TYPE    reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VOID            reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RBRACE          reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RPAREN          reduce using rule 20 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48

    number                         shift and go to state 117

state 78

    (30) function_call -> IDENTIFIER LPAREN . values RPAREN SEMICOLON
    (31) function_call -> IDENTIFIER LPAREN . values RPAREN
    (70) values -> . value
    (71) values -> . value COMMA values
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    values                         shift and go to state 119
    value                          shift and go to state 101
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 79

    (25) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (26) print -> PRINT LPAREN . RPAREN SEMICOLON
    (44) expression -> . arithmetic
    (45) expression -> . logic
    (46) expression -> . function_call
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE

    RPAREN          shift and go to state 121
    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 120
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 80

    (49) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (48) arithmetic -> arithmetic . arith_op arithmetic
    (60) arith_op -> . PLUS
    (61) arith_op -> . MINUS
    (62) arith_op -> . TIMES
    (63) arith_op -> . DIVIDE

    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

    arith_op                       shift and go to state 122

state 81

    (56) logic -> LPAREN logic . logic_op logic RPAREN
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 123

state 82

    (53) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (54) logic -> comparison .
    (52) comparison -> comparison . comp_op comparison
    (64) comp_op -> . EQUAL
    (65) comp_op -> . NOT_EQUAL
    (66) comp_op -> . LESS
    (67) comp_op -> . LESS_EQUAL
    (68) comp_op -> . GREATER
    (69) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 54 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 54 (logic -> comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

    comp_op                        shift and go to state 124

state 83

    (72) value -> IDENTIFIER .

    PLUS            reduce using rule 72 (value -> IDENTIFIER .)
    MINUS           reduce using rule 72 (value -> IDENTIFIER .)
    TIMES           reduce using rule 72 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 72 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 72 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 72 (value -> IDENTIFIER .)
    LESS            reduce using rule 72 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 72 (value -> IDENTIFIER .)
    GREATER         reduce using rule 72 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 72 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 72 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 72 (value -> IDENTIFIER .)
    $end            reduce using rule 72 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 72 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 72 (value -> IDENTIFIER .)
    COMMA           reduce using rule 72 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 72 (value -> IDENTIFIER .)


state 84

    (27) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 125
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 85

    (112) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 126
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 86

    (113) for_statement -> FOR LPAREN . assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    assignment                     shift and go to state 127
    modifier                       shift and go to state 15
    type                           shift and go to state 128

state 87

    (84) lines -> line LINE_BREAK . lines
    (87) lines -> LINE_BREAK .
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 87 (lines -> LINE_BREAK .)
  ! reduce/reduce conflict for RBRACE resolved using rule 87 (lines -> LINE_BREAK .)
    $end            reduce using rule 87 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 87 (lines -> LINE_BREAK .)
    LINE_BREAK      shift and go to state 24
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

  ! $end            [ reduce using rule 88 (lines -> .) ]
  ! RBRACE          [ reduce using rule 88 (lines -> .) ]

    line                           shift and go to state 23
    lines                          shift and go to state 129
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 88

    (85) lines -> line lines .

    $end            reduce using rule 85 (lines -> line lines .)
    RBRACE          reduce using rule 85 (lines -> line lines .)


state 89

    (52) comparison -> comparison comp_op . comparison
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 131
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    comparison                     shift and go to state 130
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 90

    (64) comp_op -> EQUAL .

    LPAREN          reduce using rule 64 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 64 (comp_op -> EQUAL .)
    TRUE            reduce using rule 64 (comp_op -> EQUAL .)
    FALSE           reduce using rule 64 (comp_op -> EQUAL .)
    INTEGER         reduce using rule 64 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 64 (comp_op -> EQUAL .)
    STRING          reduce using rule 64 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 64 (comp_op -> EQUAL .)


state 91

    (65) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 65 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 65 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 65 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 65 (comp_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 65 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 65 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 65 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 65 (comp_op -> NOT_EQUAL .)


state 92

    (66) comp_op -> LESS .

    LPAREN          reduce using rule 66 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 66 (comp_op -> LESS .)
    TRUE            reduce using rule 66 (comp_op -> LESS .)
    FALSE           reduce using rule 66 (comp_op -> LESS .)
    INTEGER         reduce using rule 66 (comp_op -> LESS .)
    DOUBLE          reduce using rule 66 (comp_op -> LESS .)
    STRING          reduce using rule 66 (comp_op -> LESS .)
    LSQUARE         reduce using rule 66 (comp_op -> LESS .)


state 93

    (67) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 67 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 67 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 67 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 67 (comp_op -> LESS_EQUAL .)
    INTEGER         reduce using rule 67 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 67 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 67 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 67 (comp_op -> LESS_EQUAL .)


state 94

    (68) comp_op -> GREATER .

    LPAREN          reduce using rule 68 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 68 (comp_op -> GREATER .)
    TRUE            reduce using rule 68 (comp_op -> GREATER .)
    FALSE           reduce using rule 68 (comp_op -> GREATER .)
    INTEGER         reduce using rule 68 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 68 (comp_op -> GREATER .)
    STRING          reduce using rule 68 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 68 (comp_op -> GREATER .)


state 95

    (69) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 69 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 69 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 69 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 69 (comp_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 69 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 69 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 69 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 69 (comp_op -> GREATER_EQUAL .)


state 96

    (57) logic -> LOGICAL_NOT logic .
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 57 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 57 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 57 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

  ! LOGICAL_AND     [ reduce using rule 57 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 57 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 69

state 97

    (56) logic -> LPAREN . logic logic_op logic RPAREN
    (53) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 81
    comparison                     shift and go to state 82
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 98

    (50) comparison -> value .

    EQUAL           reduce using rule 50 (comparison -> value .)
    NOT_EQUAL       reduce using rule 50 (comparison -> value .)
    LESS            reduce using rule 50 (comparison -> value .)
    LESS_EQUAL      reduce using rule 50 (comparison -> value .)
    GREATER         reduce using rule 50 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 50 (comparison -> value .)
    LOGICAL_AND     reduce using rule 50 (comparison -> value .)
    LOGICAL_OR      reduce using rule 50 (comparison -> value .)
    $end            reduce using rule 50 (comparison -> value .)
    SEMICOLON       reduce using rule 50 (comparison -> value .)
    RPAREN          reduce using rule 50 (comparison -> value .)


state 99

    (81) list -> LSQUARE RSQUARE .

    PLUS            reduce using rule 81 (list -> LSQUARE RSQUARE .)
    MINUS           reduce using rule 81 (list -> LSQUARE RSQUARE .)
    TIMES           reduce using rule 81 (list -> LSQUARE RSQUARE .)
    DIVIDE          reduce using rule 81 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 81 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 81 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 81 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 81 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 81 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 81 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 81 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 81 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 81 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 81 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 81 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 81 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 81 (list -> LSQUARE RSQUARE .)


state 100

    (82) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 132


state 101

    (70) values -> value .
    (71) values -> value . COMMA values

    RSQUARE         reduce using rule 70 (values -> value .)
    RPAREN          reduce using rule 70 (values -> value .)
    COMMA           shift and go to state 133


state 102

    (28) if_statement -> if_statement ELSE if_statement .
    (28) if_statement -> if_statement . ELSE if_statement
    (29) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    WHILE           reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    FOR             reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    IDENTIFIER      reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    LATE            reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 28 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 53

  ! ELSE            [ reduce using rule 28 (if_statement -> if_statement ELSE if_statement .) ]


state 103

    (29) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 88 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    if_statement                   shift and go to state 58
    lines                          shift and go to state 134
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 104

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 105

    (48) arithmetic -> arithmetic arith_op arithmetic .
    (48) arithmetic -> arithmetic . arith_op arithmetic
    (60) arith_op -> . PLUS
    (61) arith_op -> . MINUS
    (62) arith_op -> . TIMES
    (63) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    $end            reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 64

state 106

    (47) arithmetic -> value .

    PLUS            reduce using rule 47 (arithmetic -> value .)
    MINUS           reduce using rule 47 (arithmetic -> value .)
    TIMES           reduce using rule 47 (arithmetic -> value .)
    DIVIDE          reduce using rule 47 (arithmetic -> value .)
    $end            reduce using rule 47 (arithmetic -> value .)
    SEMICOLON       reduce using rule 47 (arithmetic -> value .)
    RPAREN          reduce using rule 47 (arithmetic -> value .)


state 107

    (49) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 80
    value                          shift and go to state 106
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 108

    (55) logic -> logic logic_op logic .
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 55 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 55 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 55 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

  ! LOGICAL_AND     [ reduce using rule 55 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 55 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 69

state 109

    (12) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 135


state 110

    (14) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 136


state 111

    (13) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 137


state 112

    (15) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (44) expression -> . arithmetic
    (45) expression -> . logic
    (46) expression -> . function_call
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 138
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 113

    (83) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (97) parameters -> . VOID
    (98) parameters -> . parameter
    (99) parameters -> . parameter COMMA parameters
    (100) parameters -> .
    (101) parameter -> . type IDENTIFIER
    (102) parameter -> . IDENTIFIER
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    VOID            shift and go to state 142
    RPAREN          reduce using rule 100 (parameters -> .)
    IDENTIFIER      shift and go to state 140
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42

    type                           shift and go to state 139
    parameters                     shift and go to state 141
    parameter                      shift and go to state 143

state 114

    (30) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (31) function_call -> IDENTIFIER . LPAREN values RPAREN
    (72) value -> IDENTIFIER .

    LPAREN          shift and go to state 78
    PLUS            reduce using rule 72 (value -> IDENTIFIER .)
    MINUS           reduce using rule 72 (value -> IDENTIFIER .)
    TIMES           reduce using rule 72 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 72 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 72 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 72 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 72 (value -> IDENTIFIER .)
    LESS            reduce using rule 72 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 72 (value -> IDENTIFIER .)
    GREATER         reduce using rule 72 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 72 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 72 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 72 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 72 (value -> IDENTIFIER .)


state 115

    (16) reassignment -> IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 144


state 116

    (46) expression -> function_call .

    SEMICOLON       reduce using rule 46 (expression -> function_call .)
    RPAREN          reduce using rule 46 (expression -> function_call .)


state 117

    (17) reassignment -> IDENTIFIER INLINE_ARITH number . SEMICOLON
    (19) reassignment -> IDENTIFIER INLINE_ARITH number .

    SEMICOLON       shift and go to state 145
    $end            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LINE_BREAK      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    PRINT           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IF              reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    WHILE           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FOR             reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IDENTIFIER      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LATE            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FINAL           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    CONST           reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    INTEGER_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DOUBLE_TYPE     reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    BOOLEAN_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    QUEUE_TYPE      reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    STRING_TYPE     reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    ENUM_TYPE       reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VAR             reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LIST_TYPE       reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    MAP_TYPE        reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    SET_TYPE        reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DYNAMIC_TYPE    reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VOID            reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RBRACE          reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RPAREN          reduce using rule 19 (reassignment -> IDENTIFIER INLINE_ARITH number .)


state 118

    (18) reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .

    $end            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LINE_BREAK      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    PRINT           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IF              reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    WHILE           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FOR             reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IDENTIFIER      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LATE            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FINAL           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    CONST           reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    INTEGER_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    QUEUE_TYPE      reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    STRING_TYPE     reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    ENUM_TYPE       reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VAR             reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LIST_TYPE       reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    MAP_TYPE        reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    SET_TYPE        reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VOID            reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RBRACE          reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RPAREN          reduce using rule 18 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)


state 119

    (30) function_call -> IDENTIFIER LPAREN values . RPAREN SEMICOLON
    (31) function_call -> IDENTIFIER LPAREN values . RPAREN

    RPAREN          shift and go to state 146


state 120

    (25) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 147


state 121

    (26) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 148


state 122

    (49) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (48) arithmetic -> arithmetic arith_op . arithmetic
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    arithmetic                     shift and go to state 149
    value                          shift and go to state 106
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 123

    (56) logic -> LPAREN logic logic_op . logic RPAREN
    (55) logic -> logic logic_op . logic
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 150
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 124

    (53) comparison -> LPAREN comparison comp_op . comparison RPAREN
    (52) comparison -> comparison comp_op . comparison
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 131
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    comparison                     shift and go to state 151
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 125

    (27) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 152
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 126

    (112) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 153
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 127

    (113) for_statement -> FOR LPAREN assignment . SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    SEMICOLON       shift and go to state 154


state 128

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (21) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 155
    QUESTION_MARK   shift and go to state 75

    nullable                       shift and go to state 73

state 129

    (84) lines -> line LINE_BREAK lines .

    $end            reduce using rule 84 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 84 (lines -> line LINE_BREAK lines .)


state 130

    (52) comparison -> comparison comp_op comparison .
    (52) comparison -> comparison . comp_op comparison
    (64) comp_op -> . EQUAL
    (65) comp_op -> . NOT_EQUAL
    (66) comp_op -> . LESS
    (67) comp_op -> . LESS_EQUAL
    (68) comp_op -> . GREATER
    (69) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 52 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 52 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 52 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 52 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 52 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

  ! EQUAL           [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 89

state 131

    (53) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 131
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    comparison                     shift and go to state 156
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 132

    (82) list -> LSQUARE values RSQUARE .

    PLUS            reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    MINUS           reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    TIMES           reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    DIVIDE          reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 82 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 82 (list -> LSQUARE values RSQUARE .)


state 133

    (71) values -> value COMMA . values
    (70) values -> . value
    (71) values -> . value COMMA values
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 83
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    value                          shift and go to state 101
    values                         shift and go to state 157
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 134

    (29) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 158


state 135

    (12) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 159


state 136

    (14) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (44) expression -> . arithmetic
    (45) expression -> . logic
    (46) expression -> . function_call
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 160
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 137

    (13) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (44) expression -> . arithmetic
    (45) expression -> . logic
    (46) expression -> . function_call
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 161
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 138

    (15) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 162


state 139

    (101) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 163


state 140

    (102) parameter -> IDENTIFIER .

    COMMA           reduce using rule 102 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 102 (parameter -> IDENTIFIER .)


state 141

    (83) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 164


state 142

    (97) parameters -> VOID .
    (43) type -> VOID .

    RPAREN          reduce using rule 97 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 43 (type -> VOID .)


state 143

    (98) parameters -> parameter .
    (99) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 98 (parameters -> parameter .)
    COMMA           shift and go to state 165


state 144

    (16) reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 16 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 145

    (17) reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .

    $end            reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LINE_BREAK      reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    PRINT           reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IF              reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    WHILE           reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FOR             reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IDENTIFIER      reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LATE            reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FINAL           reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    CONST           reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    INTEGER_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    QUEUE_TYPE      reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    STRING_TYPE     reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    ENUM_TYPE       reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VAR             reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LIST_TYPE       reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    MAP_TYPE        reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    SET_TYPE        reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VOID            reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RBRACE          reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RPAREN          reduce using rule 17 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)


state 146

    (30) function_call -> IDENTIFIER LPAREN values RPAREN . SEMICOLON
    (31) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 166
    $end            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LINE_BREAK      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PRINT           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    WHILE           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LATE            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FINAL           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE_TYPE     reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    QUEUE_TYPE      reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING_TYPE     reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    ENUM_TYPE       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LIST_TYPE       reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    MAP_TYPE        reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SET_TYPE        reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DYNAMIC_TYPE    reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VOID            reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RBRACE          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RPAREN          reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! SEMICOLON       [ reduce using rule 31 (function_call -> IDENTIFIER LPAREN values RPAREN .) ]


state 147

    (25) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 167


state 148

    (26) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LATE            reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 26 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 149

    (49) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (48) arithmetic -> arithmetic arith_op arithmetic .
    (48) arithmetic -> arithmetic . arith_op arithmetic
    (60) arith_op -> . PLUS
    (61) arith_op -> . MINUS
    (62) arith_op -> . TIMES
    (63) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    RPAREN          shift and go to state 168
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68

  ! PLUS            [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 48 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 64

state 150

    (56) logic -> LPAREN logic logic_op logic . RPAREN
    (55) logic -> logic logic_op logic .
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 169
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

  ! LOGICAL_AND     [ reduce using rule 55 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 55 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 69

state 151

    (53) comparison -> LPAREN comparison comp_op comparison . RPAREN
    (52) comparison -> comparison comp_op comparison .
    (52) comparison -> comparison . comp_op comparison
    (64) comp_op -> . EQUAL
    (65) comp_op -> . NOT_EQUAL
    (66) comp_op -> . LESS
    (67) comp_op -> . LESS_EQUAL
    (68) comp_op -> . GREATER
    (69) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    RPAREN          shift and go to state 170
    LOGICAL_AND     reduce using rule 52 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 52 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

  ! EQUAL           [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 52 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 89

state 152

    (27) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 171


state 153

    (112) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 172


state 154

    (113) for_statement -> FOR LPAREN assignment SEMICOLON . logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 97
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 83
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50

    logic                          shift and go to state 173
    comparison                     shift and go to state 27
    value                          shift and go to state 98
    boolean                        shift and go to state 46
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45

state 155

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 112


state 156

    (53) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (52) comparison -> comparison . comp_op comparison
    (64) comp_op -> . EQUAL
    (65) comp_op -> . NOT_EQUAL
    (66) comp_op -> . LESS
    (67) comp_op -> . LESS_EQUAL
    (68) comp_op -> . GREATER
    (69) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS            shift and go to state 92
    LESS_EQUAL      shift and go to state 93
    GREATER         shift and go to state 94
    GREATER_EQUAL   shift and go to state 95

    comp_op                        shift and go to state 124

state 157

    (71) values -> value COMMA values .

    RSQUARE         reduce using rule 71 (values -> value COMMA values .)
    RPAREN          reduce using rule 71 (values -> value COMMA values .)


state 158

    (29) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    WHILE           reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FOR             reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LATE            reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 29 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 159

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (44) expression -> . arithmetic
    (45) expression -> . logic
    (46) expression -> . function_call
    (47) arithmetic -> . value
    (48) arithmetic -> . arithmetic arith_op arithmetic
    (49) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (54) logic -> . comparison
    (55) logic -> . logic logic_op logic
    (56) logic -> . LPAREN logic logic_op logic RPAREN
    (57) logic -> . LOGICAL_NOT logic
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (72) value -> . IDENTIFIER
    (73) value -> . number
    (74) value -> . string
    (75) value -> . list
    (50) comparison -> . value
    (51) comparison -> . boolean
    (52) comparison -> . comparison comp_op comparison
    (53) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (76) number -> . INTEGER
    (77) number -> . DOUBLE
    (78) string -> . STRING
    (81) list -> . LSQUARE RSQUARE
    (82) list -> . LSQUARE values RSQUARE
    (79) boolean -> . TRUE
    (80) boolean -> . FALSE

    LPAREN          shift and go to state 19
    LOGICAL_NOT     shift and go to state 28
    IDENTIFIER      shift and go to state 114
    INTEGER         shift and go to state 47
    DOUBLE          shift and go to state 48
    STRING          shift and go to state 49
    LSQUARE         shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52

    expression                     shift and go to state 174
    arithmetic                     shift and go to state 12
    logic                          shift and go to state 13
    function_call                  shift and go to state 116
    value                          shift and go to state 26
    comparison                     shift and go to state 27
    number                         shift and go to state 25
    string                         shift and go to state 44
    list                           shift and go to state 45
    boolean                        shift and go to state 46

state 160

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 175


state 161

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 176


state 162

    (15) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 163

    (101) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 101 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 101 (parameter -> type IDENTIFIER .)


state 164

    (83) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 177


state 165

    (99) parameters -> parameter COMMA . parameters
    (97) parameters -> . VOID
    (98) parameters -> . parameter
    (99) parameters -> . parameter COMMA parameters
    (100) parameters -> .
    (101) parameter -> . type IDENTIFIER
    (102) parameter -> . IDENTIFIER
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    VOID            shift and go to state 142
    RPAREN          reduce using rule 100 (parameters -> .)
    IDENTIFIER      shift and go to state 140
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42

    parameter                      shift and go to state 143
    parameters                     shift and go to state 178
    type                           shift and go to state 139

state 166

    (30) function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    WHILE           reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LATE            reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FINAL           reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    CONST           reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VOID            reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RBRACE          reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RPAREN          reduce using rule 30 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)


state 167

    (25) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LATE            reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 25 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 168

    (49) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 49 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 49 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 49 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DIVIDE          reduce using rule 49 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 49 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 49 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 49 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 169

    (56) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 56 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 56 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 56 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 56 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 56 (logic -> LPAREN logic logic_op logic RPAREN .)


state 170

    (53) comparison -> LPAREN comparison comp_op comparison RPAREN .

    EQUAL           reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    NOT_EQUAL       reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS            reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS_EQUAL      reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER         reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER_EQUAL   reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_AND     reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_OR      reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    $end            reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SEMICOLON       reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RPAREN          reduce using rule 53 (comparison -> LPAREN comparison comp_op comparison RPAREN .)


state 171

    (27) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 88 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    lines                          shift and go to state 179
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 172

    (112) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 88 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    lines                          shift and go to state 180
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 173

    (113) for_statement -> FOR LPAREN assignment SEMICOLON logic . SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (55) logic -> logic . logic_op logic
    (58) logic_op -> . LOGICAL_AND
    (59) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 181
    LOGICAL_AND     shift and go to state 70
    LOGICAL_OR      shift and go to state 71

    logic_op                       shift and go to state 69

state 174

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 182


state 175

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 176

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 177

    (83) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 88 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    type                           shift and go to state 16
    lines                          shift and go to state 183
    line                           shift and go to state 23
    print                          shift and go to state 55
    assignment                     shift and go to state 56
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    reassignment                   shift and go to state 62
    modifier                       shift and go to state 15

state 178

    (99) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 99 (parameters -> parameter COMMA parameters .)


state 179

    (27) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 184


state 180

    (112) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 185


state 181

    (113) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON . reassignment RPAREN LBRACE lines RBRACE
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH

    IDENTIFIER      shift and go to state 187

    reassignment                   shift and go to state 186

state 182

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 183

    (83) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 188


state 184

    (27) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 27 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 185

    (112) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 112 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 186

    (113) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 189


state 187

    (16) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (17) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (18) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (19) reassignment -> IDENTIFIER . INLINE_ARITH number
    (20) reassignment -> IDENTIFIER . INLINE_ARITH

    ASSIGN          shift and go to state 76
    INLINE_ARITH    shift and go to state 77


state 188

    (83) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 83 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 189

    (113) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 190


state 190

    (113) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE . lines RBRACE
    (84) lines -> . line LINE_BREAK lines
    (85) lines -> . line lines
    (86) lines -> . line
    (87) lines -> . LINE_BREAK
    (88) lines -> .
    (89) line -> . print
    (90) line -> . assignment
    (91) line -> . function
    (92) line -> . if_statement
    (93) line -> . while_statement
    (94) line -> . for_statement
    (95) line -> . function_call
    (96) line -> . reassignment
    (25) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (26) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (83) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (27) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (28) if_statement -> . if_statement ELSE if_statement
    (29) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (112) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (113) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (30) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (31) function_call -> . IDENTIFIER LPAREN values RPAREN
    (16) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (17) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (18) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (19) reassignment -> . IDENTIFIER INLINE_ARITH number
    (20) reassignment -> . IDENTIFIER INLINE_ARITH
    (22) modifier -> . LATE
    (23) modifier -> . FINAL
    (24) modifier -> . CONST
    (32) type -> . INTEGER_TYPE
    (33) type -> . DOUBLE_TYPE
    (34) type -> . BOOLEAN_TYPE
    (35) type -> . QUEUE_TYPE
    (36) type -> . STRING_TYPE
    (37) type -> . ENUM_TYPE
    (38) type -> . VAR
    (39) type -> . LIST_TYPE
    (40) type -> . MAP_TYPE
    (41) type -> . SET_TYPE
    (42) type -> . DYNAMIC_TYPE
    (43) type -> . VOID

    LINE_BREAK      shift and go to state 24
    RBRACE          reduce using rule 88 (lines -> .)
    PRINT           shift and go to state 18
    IF              shift and go to state 20
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IDENTIFIER      shift and go to state 63
    LATE            shift and go to state 29
    FINAL           shift and go to state 30
    CONST           shift and go to state 31
    INTEGER_TYPE    shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOLEAN_TYPE    shift and go to state 34
    QUEUE_TYPE      shift and go to state 35
    STRING_TYPE     shift and go to state 36
    ENUM_TYPE       shift and go to state 37
    VAR             shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    DYNAMIC_TYPE    shift and go to state 42
    VOID            shift and go to state 43

    assignment                     shift and go to state 56
    reassignment                   shift and go to state 62
    lines                          shift and go to state 191
    line                           shift and go to state 23
    print                          shift and go to state 55
    function                       shift and go to state 57
    if_statement                   shift and go to state 58
    while_statement                shift and go to state 59
    for_statement                  shift and go to state 60
    function_call                  shift and go to state 61
    modifier                       shift and go to state 15
    type                           shift and go to state 16

state 191

    (113) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 192


state 192

    (113) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 113 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 96 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 96 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 102 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 108 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 108 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 130 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 130 resolved as shift
WARNING: shift/reduce conflict for LESS in state 130 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 130 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 130 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 130 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 150 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 150 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 151 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 151 resolved as shift
WARNING: shift/reduce conflict for LESS in state 151 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 151 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (statement -> while_statement)
WARNING: rejected rule (line -> while_statement) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (statement -> for_statement)
WARNING: rejected rule (line -> for_statement) in state 8
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> reassignment)
WARNING: rejected rule (line -> reassignment) in state 11
WARNING: reduce/reduce conflict in state 14 resolved using rule (expression -> function_call)
WARNING: rejected rule (line -> function_call) in state 14
WARNING: reduce/reduce conflict in state 23 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 23
WARNING: reduce/reduce conflict in state 26 resolved using rule (arithmetic -> value)
WARNING: rejected rule (comparison -> value) in state 26
WARNING: reduce/reduce conflict in state 87 resolved using rule (lines -> LINE_BREAK)
WARNING: rejected rule (lines -> <empty>) in state 87
