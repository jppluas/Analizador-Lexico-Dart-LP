Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DO
    DOT
    ENUM
    EXTENDS
    FINALLY
    GET
    IMPLEMENTS
    IN
    RETURN
    SWITCH
    THROW
    TRY
    TYPEDEF
    ZERO

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> reassignment
Rule 11    statement -> <empty>
Rule 12    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 16    assignment -> type IDENTIFIER ASSIGN expression
Rule 17    assignment -> int_assignment
Rule 18    assignment -> string_assignment
Rule 19    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 20    int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 21    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 22    int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 23    int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 24    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 25    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic
Rule 26    string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 27    string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 28    string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 29    string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 30    string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
Rule 31    string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON
Rule 32    string_assignment -> string_type IDENTIFIER ASSIGN concate
Rule 33    number_type -> INTEGER_TYPE
Rule 34    number_type -> VAR
Rule 35    number_type -> DOUBLE_TYPE
Rule 36    string_type -> STRING_TYPE
Rule 37    string_type -> VAR
Rule 38    reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 39    reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 40    reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 41    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 42    reassignment -> IDENTIFIER INLINE_ARITH
Rule 43    nullable -> QUESTION_MARK
Rule 44    modifier -> FINAL
Rule 45    modifier -> CONST
Rule 46    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 47    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 48    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 49    if_statement -> if_statement ELSE if_statement
Rule 50    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 51    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 52    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 53    function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON
Rule 54    function_call -> IDENTIFIER LPAREN RPAREN
Rule 55    type -> INTEGER_TYPE
Rule 56    type -> DOUBLE_TYPE
Rule 57    type -> BOOLEAN_TYPE
Rule 58    type -> QUEUE_TYPE
Rule 59    type -> STRING_TYPE
Rule 60    type -> ENUM_TYPE
Rule 61    type -> VAR
Rule 62    type -> LIST_TYPE
Rule 63    type -> MAP_TYPE
Rule 64    type -> SET_TYPE
Rule 65    type -> DYNAMIC_TYPE
Rule 66    type -> VOID
Rule 67    expression -> arithmetic
Rule 68    expression -> concate
Rule 69    expression -> logic
Rule 70    expression -> function_call
Rule 71    expression -> division
Rule 72    arithmetic -> number
Rule 73    arithmetic -> arithmetic arith_op arithmetic
Rule 74    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 75    division -> number DIVIDE number
Rule 76    concate -> string
Rule 77    concate -> concate PLUS concate
Rule 78    concate -> LPAREN concate PLUS concate RPAREN
Rule 79    comparison -> values
Rule 80    comparison -> boolean
Rule 81    comparison -> comparison comp_op comparison
Rule 82    comparison -> LPAREN comparison comp_op number comparison
Rule 83    logic -> comparison
Rule 84    logic -> logic logic_op logic
Rule 85    logic -> LPAREN logic logic_op logic RPAREN
Rule 86    logic -> LOGICAL_NOT logic
Rule 87    logic_op -> LOGICAL_AND
Rule 88    logic_op -> LOGICAL_OR
Rule 89    arith_op -> PLUS
Rule 90    arith_op -> MINUS
Rule 91    arith_op -> TIMES
Rule 92    comp_op -> EQUAL
Rule 93    comp_op -> NOT_EQUAL
Rule 94    comp_op -> LESS
Rule 95    comp_op -> LESS_EQUAL
Rule 96    comp_op -> GREATER
Rule 97    comp_op -> GREATER_EQUAL
Rule 98    values -> value
Rule 99    values -> value COMMA values
Rule 100   value -> IDENTIFIER
Rule 101   value -> number
Rule 102   value -> string
Rule 103   value -> list
Rule 104   number -> INTEGER
Rule 105   number -> DOUBLE
Rule 106   string -> STRING
Rule 107   boolean -> TRUE
Rule 108   boolean -> FALSE
Rule 109   list -> LSQUARE RSQUARE
Rule 110   list -> LSQUARE values RSQUARE
Rule 111   function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 112   lines -> line LINE_BREAK lines
Rule 113   lines -> line lines
Rule 114   lines -> line
Rule 115   lines -> LINE_BREAK
Rule 116   lines -> <empty>
Rule 117   line -> print
Rule 118   line -> assignment
Rule 119   line -> function
Rule 120   line -> if_statement
Rule 121   line -> while_statement
Rule 122   line -> for_statement
Rule 123   line -> function_call
Rule 124   line -> reassignment
Rule 125   parameters -> VOID
Rule 126   parameters -> parameter
Rule 127   parameters -> parameter COMMA parameters
Rule 128   parameters -> <empty>
Rule 129   parameter -> type IDENTIFIER
Rule 130   parameter -> IDENTIFIER
Rule 131   map -> MAP_TYPE LESS type COMMA type GREATER
Rule 132   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE values RSQUARE
Rule 133   map -> MAP_TYPE LESS type COMMA type GREATER LSQUARE RSQUARE
Rule 134   set -> SET_TYPE LESS type GREATER
Rule 135   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 136   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 137   queue -> QUEUE_TYPE LESS type GREATER
Rule 138   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 139   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 140   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 141   for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
ASSIGN               : 12 13 14 15 16 19 20 21 22 23 24 25 26 27 28 29 30 31 32 38
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 57
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 99 127 131 132 133
COMMENT              : 
CONST                : 45
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 75
DO                   : 
DOT                  : 
DOUBLE               : 105
DOUBLE_TYPE          : 35 56
DYNAMIC_TYPE         : 65
ELSE                 : 49 50
ENUM                 : 
ENUM_TYPE            : 60
EQUAL                : 92
EXTENDS              : 
FALSE                : 108
FINAL                : 44
FINALLY              : 
FOR                  : 141
GET                  : 
GREATER              : 96 131 132 133 134 135 136 137 138 139
GREATER_EQUAL        : 97
IDENTIFIER           : 12 13 14 15 16 19 20 21 22 23 24 25 26 27 28 29 30 31 32 38 39 40 41 42 51 52 53 54 100 111 129 130
IF                   : 48
IMPLEMENTS           : 
IN                   : 
INLINE_ARITH         : 39 40 41 42
INTEGER              : 104
INTEGER_TYPE         : 33 55
LBRACE               : 9 48 50 111 140 141
LESS                 : 94 131 132 133 134 135 136 137 138 139
LESS_EQUAL           : 95
LINE_BREAK           : 112 115
LIST_TYPE            : 62
LOGICAL_AND          : 87
LOGICAL_NOT          : 86
LOGICAL_OR           : 88
LPAREN               : 46 47 48 51 52 53 54 74 78 82 85 111 140 141
LSQUARE              : 109 110 132 133 135 136 138 139
MAP_TYPE             : 63 131 132 133
MINUS                : 90
NOT_EQUAL            : 93
NULL                 : 19 20 26 27
PLUS                 : 77 78 89
PRINT                : 46 47
QUESTION_MARK        : 43
QUEUE_TYPE           : 58 137 138 139
RBRACE               : 9 48 50 111 140 141
RETURN               : 
RPAREN               : 46 47 48 51 52 53 54 74 78 85 111 140 141
RSQUARE              : 109 110 132 133 135 136 138 139
SEMICOLON            : 12 13 14 15 19 20 21 22 23 24 26 27 28 29 30 31 38 39 40 46 47 51 53 141 141
SET_TYPE             : 64 134 135 136
STRING               : 106
STRING_TYPE          : 36 59
SWITCH               : 
THROW                : 
TIMES                : 91
TRUE                 : 107
TRY                  : 
TYPEDEF              : 
VAR                  : 34 37 61
VOID                 : 66 125
WHILE                : 140
ZERO                 : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 73 74
arithmetic           : 21 22 23 24 25 67 73 73 74 74
assignment           : 2 118 141
boolean              : 80
comp_op              : 81 82
comparison           : 81 81 82 82 83
concate              : 28 29 30 31 32 68 77 77 78 78
division             : 71
expression           : 1 12 13 14 15 16 38 46
for_statement        : 7 122
function             : 4 119
function_call        : 70 123
if_statement         : 5 49 49 50 120
int_assignment       : 17
line                 : 112 113 114
lines                : 8 9 48 50 111 112 113 140 141
list                 : 103
logic                : 48 69 84 84 85 85 86 140 141
logic_op             : 84 85
map                  : 
modifier             : 12 14 19 21 23 26 28 30
nullable             : 12 13 19 20 21 22 26 27 28 29
number               : 39 41 72 75 75 82 101
number_type          : 19 20 21 22 23 24 25
parameter            : 126 127
parameters           : 111 127
print                : 3 117
queue                : 
reassignment         : 10 124 141
set                  : 
statement            : 0
string               : 76 102
string_assignment    : 18
string_type          : 26 27 28 29 30 31 32
type                 : 12 13 14 15 16 111 129 131 131 132 132 133 133 134 135 136 137 138 139
value                : 98 99
values               : 51 52 79 99 110 132 135 138
while_statement      : 6 121

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> . reassignment
    (11) statement -> .
    (67) expression -> . arithmetic
    (68) expression -> . concate
    (69) expression -> . logic
    (70) expression -> . function_call
    (71) expression -> . division
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) division -> . number DIVIDE number
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
    LBRACE          shift and go to state 10
    $end            reduce using rule 11 (statement -> .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    LINE_BREAK      shift and go to state 28
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LSQUARE         shift and go to state 58

  ! $end            [ reduce using rule 116 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    reassignment                   shift and go to state 11
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 15
    division                       shift and go to state 16
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    line                           shift and go to state 27
    number                         shift and go to state 29
    string                         shift and go to state 30
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (118) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 118 (line -> assignment .)
    PRINT           reduce using rule 118 (line -> assignment .)
    IF              reduce using rule 118 (line -> assignment .)
    WHILE           reduce using rule 118 (line -> assignment .)
    FOR             reduce using rule 118 (line -> assignment .)
    IDENTIFIER      reduce using rule 118 (line -> assignment .)
    FINAL           reduce using rule 118 (line -> assignment .)
    CONST           reduce using rule 118 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 118 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 118 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 118 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 118 (line -> assignment .)
    STRING_TYPE     reduce using rule 118 (line -> assignment .)
    ENUM_TYPE       reduce using rule 118 (line -> assignment .)
    VAR             reduce using rule 118 (line -> assignment .)
    LIST_TYPE       reduce using rule 118 (line -> assignment .)
    MAP_TYPE        reduce using rule 118 (line -> assignment .)
    SET_TYPE        reduce using rule 118 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 118 (line -> assignment .)
    VOID            reduce using rule 118 (line -> assignment .)

  ! $end            [ reduce using rule 118 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (117) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 117 (line -> print .)
    PRINT           reduce using rule 117 (line -> print .)
    IF              reduce using rule 117 (line -> print .)
    WHILE           reduce using rule 117 (line -> print .)
    FOR             reduce using rule 117 (line -> print .)
    IDENTIFIER      reduce using rule 117 (line -> print .)
    FINAL           reduce using rule 117 (line -> print .)
    CONST           reduce using rule 117 (line -> print .)
    INTEGER_TYPE    reduce using rule 117 (line -> print .)
    DOUBLE_TYPE     reduce using rule 117 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 117 (line -> print .)
    QUEUE_TYPE      reduce using rule 117 (line -> print .)
    STRING_TYPE     reduce using rule 117 (line -> print .)
    ENUM_TYPE       reduce using rule 117 (line -> print .)
    VAR             reduce using rule 117 (line -> print .)
    LIST_TYPE       reduce using rule 117 (line -> print .)
    MAP_TYPE        reduce using rule 117 (line -> print .)
    SET_TYPE        reduce using rule 117 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 117 (line -> print .)
    VOID            reduce using rule 117 (line -> print .)

  ! $end            [ reduce using rule 117 (line -> print .) ]


state 5

    (4) statement -> function .
    (119) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 119 (line -> function .)
    PRINT           reduce using rule 119 (line -> function .)
    IF              reduce using rule 119 (line -> function .)
    WHILE           reduce using rule 119 (line -> function .)
    FOR             reduce using rule 119 (line -> function .)
    IDENTIFIER      reduce using rule 119 (line -> function .)
    FINAL           reduce using rule 119 (line -> function .)
    CONST           reduce using rule 119 (line -> function .)
    INTEGER_TYPE    reduce using rule 119 (line -> function .)
    DOUBLE_TYPE     reduce using rule 119 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 119 (line -> function .)
    QUEUE_TYPE      reduce using rule 119 (line -> function .)
    STRING_TYPE     reduce using rule 119 (line -> function .)
    ENUM_TYPE       reduce using rule 119 (line -> function .)
    VAR             reduce using rule 119 (line -> function .)
    LIST_TYPE       reduce using rule 119 (line -> function .)
    MAP_TYPE        reduce using rule 119 (line -> function .)
    SET_TYPE        reduce using rule 119 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 119 (line -> function .)
    VOID            reduce using rule 119 (line -> function .)

  ! $end            [ reduce using rule 119 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (49) if_statement -> if_statement . ELSE if_statement
    (50) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (120) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 59
    LINE_BREAK      reduce using rule 120 (line -> if_statement .)
    PRINT           reduce using rule 120 (line -> if_statement .)
    IF              reduce using rule 120 (line -> if_statement .)
    WHILE           reduce using rule 120 (line -> if_statement .)
    FOR             reduce using rule 120 (line -> if_statement .)
    IDENTIFIER      reduce using rule 120 (line -> if_statement .)
    FINAL           reduce using rule 120 (line -> if_statement .)
    CONST           reduce using rule 120 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 120 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 120 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 120 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 120 (line -> if_statement .)
    STRING_TYPE     reduce using rule 120 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 120 (line -> if_statement .)
    VAR             reduce using rule 120 (line -> if_statement .)
    LIST_TYPE       reduce using rule 120 (line -> if_statement .)
    MAP_TYPE        reduce using rule 120 (line -> if_statement .)
    SET_TYPE        reduce using rule 120 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 120 (line -> if_statement .)
    VOID            reduce using rule 120 (line -> if_statement .)

  ! $end            [ reduce using rule 120 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .
    (121) line -> while_statement .

  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> while_statement .)
    $end            reduce using rule 6 (statement -> while_statement .)
    LINE_BREAK      reduce using rule 121 (line -> while_statement .)
    PRINT           reduce using rule 121 (line -> while_statement .)
    IF              reduce using rule 121 (line -> while_statement .)
    WHILE           reduce using rule 121 (line -> while_statement .)
    FOR             reduce using rule 121 (line -> while_statement .)
    IDENTIFIER      reduce using rule 121 (line -> while_statement .)
    FINAL           reduce using rule 121 (line -> while_statement .)
    CONST           reduce using rule 121 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 121 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 121 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 121 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 121 (line -> while_statement .)
    STRING_TYPE     reduce using rule 121 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 121 (line -> while_statement .)
    VAR             reduce using rule 121 (line -> while_statement .)
    LIST_TYPE       reduce using rule 121 (line -> while_statement .)
    MAP_TYPE        reduce using rule 121 (line -> while_statement .)
    SET_TYPE        reduce using rule 121 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 121 (line -> while_statement .)
    VOID            reduce using rule 121 (line -> while_statement .)

  ! $end            [ reduce using rule 121 (line -> while_statement .) ]


state 8

    (7) statement -> for_statement .
    (122) line -> for_statement .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    LINE_BREAK      reduce using rule 122 (line -> for_statement .)
    PRINT           reduce using rule 122 (line -> for_statement .)
    IF              reduce using rule 122 (line -> for_statement .)
    WHILE           reduce using rule 122 (line -> for_statement .)
    FOR             reduce using rule 122 (line -> for_statement .)
    IDENTIFIER      reduce using rule 122 (line -> for_statement .)
    FINAL           reduce using rule 122 (line -> for_statement .)
    CONST           reduce using rule 122 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 122 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 122 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 122 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 122 (line -> for_statement .)
    STRING_TYPE     reduce using rule 122 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 122 (line -> for_statement .)
    VAR             reduce using rule 122 (line -> for_statement .)
    LIST_TYPE       reduce using rule 122 (line -> for_statement .)
    MAP_TYPE        reduce using rule 122 (line -> for_statement .)
    SET_TYPE        reduce using rule 122 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 122 (line -> for_statement .)
    VOID            reduce using rule 122 (line -> for_statement .)

  ! $end            [ reduce using rule 122 (line -> for_statement .) ]


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    LINE_BREAK      shift and go to state 28
    RBRACE          reduce using rule 116 (lines -> .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    lines                          shift and go to state 60
    line                           shift and go to state 27
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 11

    (10) statement -> reassignment .
    (124) line -> reassignment .

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> reassignment .)
    $end            reduce using rule 10 (statement -> reassignment .)
    LINE_BREAK      reduce using rule 124 (line -> reassignment .)
    PRINT           reduce using rule 124 (line -> reassignment .)
    IF              reduce using rule 124 (line -> reassignment .)
    WHILE           reduce using rule 124 (line -> reassignment .)
    FOR             reduce using rule 124 (line -> reassignment .)
    IDENTIFIER      reduce using rule 124 (line -> reassignment .)
    FINAL           reduce using rule 124 (line -> reassignment .)
    CONST           reduce using rule 124 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 124 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 124 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 124 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 124 (line -> reassignment .)
    STRING_TYPE     reduce using rule 124 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 124 (line -> reassignment .)
    VAR             reduce using rule 124 (line -> reassignment .)
    LIST_TYPE       reduce using rule 124 (line -> reassignment .)
    MAP_TYPE        reduce using rule 124 (line -> reassignment .)
    SET_TYPE        reduce using rule 124 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 124 (line -> reassignment .)
    VOID            reduce using rule 124 (line -> reassignment .)

  ! $end            [ reduce using rule 124 (line -> reassignment .) ]


state 12

    (67) expression -> arithmetic .
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

    $end            reduce using rule 67 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 67 (expression -> arithmetic .)
    RPAREN          reduce using rule 67 (expression -> arithmetic .)
    LINE_BREAK      reduce using rule 67 (expression -> arithmetic .)
    PRINT           reduce using rule 67 (expression -> arithmetic .)
    IF              reduce using rule 67 (expression -> arithmetic .)
    WHILE           reduce using rule 67 (expression -> arithmetic .)
    FOR             reduce using rule 67 (expression -> arithmetic .)
    IDENTIFIER      reduce using rule 67 (expression -> arithmetic .)
    FINAL           reduce using rule 67 (expression -> arithmetic .)
    CONST           reduce using rule 67 (expression -> arithmetic .)
    INTEGER_TYPE    reduce using rule 67 (expression -> arithmetic .)
    DOUBLE_TYPE     reduce using rule 67 (expression -> arithmetic .)
    BOOLEAN_TYPE    reduce using rule 67 (expression -> arithmetic .)
    QUEUE_TYPE      reduce using rule 67 (expression -> arithmetic .)
    STRING_TYPE     reduce using rule 67 (expression -> arithmetic .)
    ENUM_TYPE       reduce using rule 67 (expression -> arithmetic .)
    VAR             reduce using rule 67 (expression -> arithmetic .)
    LIST_TYPE       reduce using rule 67 (expression -> arithmetic .)
    MAP_TYPE        reduce using rule 67 (expression -> arithmetic .)
    SET_TYPE        reduce using rule 67 (expression -> arithmetic .)
    DYNAMIC_TYPE    reduce using rule 67 (expression -> arithmetic .)
    VOID            reduce using rule 67 (expression -> arithmetic .)
    RBRACE          reduce using rule 67 (expression -> arithmetic .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 13

    (68) expression -> concate .
    (77) concate -> concate . PLUS concate

    $end            reduce using rule 68 (expression -> concate .)
    SEMICOLON       reduce using rule 68 (expression -> concate .)
    RPAREN          reduce using rule 68 (expression -> concate .)
    LINE_BREAK      reduce using rule 68 (expression -> concate .)
    PRINT           reduce using rule 68 (expression -> concate .)
    IF              reduce using rule 68 (expression -> concate .)
    WHILE           reduce using rule 68 (expression -> concate .)
    FOR             reduce using rule 68 (expression -> concate .)
    IDENTIFIER      reduce using rule 68 (expression -> concate .)
    FINAL           reduce using rule 68 (expression -> concate .)
    CONST           reduce using rule 68 (expression -> concate .)
    INTEGER_TYPE    reduce using rule 68 (expression -> concate .)
    DOUBLE_TYPE     reduce using rule 68 (expression -> concate .)
    BOOLEAN_TYPE    reduce using rule 68 (expression -> concate .)
    QUEUE_TYPE      reduce using rule 68 (expression -> concate .)
    STRING_TYPE     reduce using rule 68 (expression -> concate .)
    ENUM_TYPE       reduce using rule 68 (expression -> concate .)
    VAR             reduce using rule 68 (expression -> concate .)
    LIST_TYPE       reduce using rule 68 (expression -> concate .)
    MAP_TYPE        reduce using rule 68 (expression -> concate .)
    SET_TYPE        reduce using rule 68 (expression -> concate .)
    DYNAMIC_TYPE    reduce using rule 68 (expression -> concate .)
    VOID            reduce using rule 68 (expression -> concate .)
    RBRACE          reduce using rule 68 (expression -> concate .)
    PLUS            shift and go to state 74


state 14

    (69) expression -> logic .
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

    $end            reduce using rule 69 (expression -> logic .)
    SEMICOLON       reduce using rule 69 (expression -> logic .)
    RPAREN          reduce using rule 69 (expression -> logic .)
    LINE_BREAK      reduce using rule 69 (expression -> logic .)
    PRINT           reduce using rule 69 (expression -> logic .)
    IF              reduce using rule 69 (expression -> logic .)
    WHILE           reduce using rule 69 (expression -> logic .)
    FOR             reduce using rule 69 (expression -> logic .)
    IDENTIFIER      reduce using rule 69 (expression -> logic .)
    FINAL           reduce using rule 69 (expression -> logic .)
    CONST           reduce using rule 69 (expression -> logic .)
    INTEGER_TYPE    reduce using rule 69 (expression -> logic .)
    DOUBLE_TYPE     reduce using rule 69 (expression -> logic .)
    BOOLEAN_TYPE    reduce using rule 69 (expression -> logic .)
    QUEUE_TYPE      reduce using rule 69 (expression -> logic .)
    STRING_TYPE     reduce using rule 69 (expression -> logic .)
    ENUM_TYPE       reduce using rule 69 (expression -> logic .)
    VAR             reduce using rule 69 (expression -> logic .)
    LIST_TYPE       reduce using rule 69 (expression -> logic .)
    MAP_TYPE        reduce using rule 69 (expression -> logic .)
    SET_TYPE        reduce using rule 69 (expression -> logic .)
    DYNAMIC_TYPE    reduce using rule 69 (expression -> logic .)
    VOID            reduce using rule 69 (expression -> logic .)
    RBRACE          reduce using rule 69 (expression -> logic .)
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 15

    (70) expression -> function_call .
    (123) line -> function_call .

  ! reduce/reduce conflict for $end resolved using rule 70 (expression -> function_call .)
    $end            reduce using rule 70 (expression -> function_call .)
    LINE_BREAK      reduce using rule 123 (line -> function_call .)
    PRINT           reduce using rule 123 (line -> function_call .)
    IF              reduce using rule 123 (line -> function_call .)
    WHILE           reduce using rule 123 (line -> function_call .)
    FOR             reduce using rule 123 (line -> function_call .)
    IDENTIFIER      reduce using rule 123 (line -> function_call .)
    FINAL           reduce using rule 123 (line -> function_call .)
    CONST           reduce using rule 123 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 123 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 123 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 123 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 123 (line -> function_call .)
    STRING_TYPE     reduce using rule 123 (line -> function_call .)
    ENUM_TYPE       reduce using rule 123 (line -> function_call .)
    VAR             reduce using rule 123 (line -> function_call .)
    LIST_TYPE       reduce using rule 123 (line -> function_call .)
    MAP_TYPE        reduce using rule 123 (line -> function_call .)
    SET_TYPE        reduce using rule 123 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 123 (line -> function_call .)
    VOID            reduce using rule 123 (line -> function_call .)

  ! $end            [ reduce using rule 123 (line -> function_call .) ]


state 16

    (71) expression -> division .

    $end            reduce using rule 71 (expression -> division .)
    SEMICOLON       reduce using rule 71 (expression -> division .)
    RPAREN          reduce using rule 71 (expression -> division .)
    LINE_BREAK      reduce using rule 71 (expression -> division .)
    PRINT           reduce using rule 71 (expression -> division .)
    IF              reduce using rule 71 (expression -> division .)
    WHILE           reduce using rule 71 (expression -> division .)
    FOR             reduce using rule 71 (expression -> division .)
    IDENTIFIER      reduce using rule 71 (expression -> division .)
    FINAL           reduce using rule 71 (expression -> division .)
    CONST           reduce using rule 71 (expression -> division .)
    INTEGER_TYPE    reduce using rule 71 (expression -> division .)
    DOUBLE_TYPE     reduce using rule 71 (expression -> division .)
    BOOLEAN_TYPE    reduce using rule 71 (expression -> division .)
    QUEUE_TYPE      reduce using rule 71 (expression -> division .)
    STRING_TYPE     reduce using rule 71 (expression -> division .)
    ENUM_TYPE       reduce using rule 71 (expression -> division .)
    VAR             reduce using rule 71 (expression -> division .)
    LIST_TYPE       reduce using rule 71 (expression -> division .)
    MAP_TYPE        reduce using rule 71 (expression -> division .)
    SET_TYPE        reduce using rule 71 (expression -> division .)
    DYNAMIC_TYPE    reduce using rule 71 (expression -> division .)
    VOID            reduce using rule 71 (expression -> division .)
    RBRACE          reduce using rule 71 (expression -> division .)


state 17

    (12) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (19) int_assignment -> modifier . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> modifier . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> modifier . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) string_assignment -> modifier . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> modifier . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> modifier . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    type                           shift and go to state 78
    number_type                    shift and go to state 79
    string_type                    shift and go to state 80

state 18

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (111) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (43) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 82
    QUESTION_MARK   shift and go to state 83

    nullable                       shift and go to state 81

state 19

    (38) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (39) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (40) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number
    (42) reassignment -> IDENTIFIER . INLINE_ARITH
    (51) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (52) function_call -> IDENTIFIER . LPAREN values RPAREN
    (53) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN RPAREN
    (100) value -> IDENTIFIER .

    ASSIGN          shift and go to state 84
    INLINE_ARITH    shift and go to state 85
    LPAREN          shift and go to state 86
    COMMA           reduce using rule 100 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 100 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 100 (value -> IDENTIFIER .)
    LESS            reduce using rule 100 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 100 (value -> IDENTIFIER .)
    GREATER         reduce using rule 100 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 100 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 100 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 100 (value -> IDENTIFIER .)
    $end            reduce using rule 100 (value -> IDENTIFIER .)


state 20

    (17) assignment -> int_assignment .

    $end            reduce using rule 17 (assignment -> int_assignment .)
    LINE_BREAK      reduce using rule 17 (assignment -> int_assignment .)
    PRINT           reduce using rule 17 (assignment -> int_assignment .)
    IF              reduce using rule 17 (assignment -> int_assignment .)
    WHILE           reduce using rule 17 (assignment -> int_assignment .)
    FOR             reduce using rule 17 (assignment -> int_assignment .)
    IDENTIFIER      reduce using rule 17 (assignment -> int_assignment .)
    FINAL           reduce using rule 17 (assignment -> int_assignment .)
    CONST           reduce using rule 17 (assignment -> int_assignment .)
    INTEGER_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    DOUBLE_TYPE     reduce using rule 17 (assignment -> int_assignment .)
    BOOLEAN_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    QUEUE_TYPE      reduce using rule 17 (assignment -> int_assignment .)
    STRING_TYPE     reduce using rule 17 (assignment -> int_assignment .)
    ENUM_TYPE       reduce using rule 17 (assignment -> int_assignment .)
    VAR             reduce using rule 17 (assignment -> int_assignment .)
    LIST_TYPE       reduce using rule 17 (assignment -> int_assignment .)
    MAP_TYPE        reduce using rule 17 (assignment -> int_assignment .)
    SET_TYPE        reduce using rule 17 (assignment -> int_assignment .)
    DYNAMIC_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    VOID            reduce using rule 17 (assignment -> int_assignment .)
    RBRACE          reduce using rule 17 (assignment -> int_assignment .)
    SEMICOLON       reduce using rule 17 (assignment -> int_assignment .)


state 21

    (18) assignment -> string_assignment .

    $end            reduce using rule 18 (assignment -> string_assignment .)
    LINE_BREAK      reduce using rule 18 (assignment -> string_assignment .)
    PRINT           reduce using rule 18 (assignment -> string_assignment .)
    IF              reduce using rule 18 (assignment -> string_assignment .)
    WHILE           reduce using rule 18 (assignment -> string_assignment .)
    FOR             reduce using rule 18 (assignment -> string_assignment .)
    IDENTIFIER      reduce using rule 18 (assignment -> string_assignment .)
    FINAL           reduce using rule 18 (assignment -> string_assignment .)
    CONST           reduce using rule 18 (assignment -> string_assignment .)
    INTEGER_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    DOUBLE_TYPE     reduce using rule 18 (assignment -> string_assignment .)
    BOOLEAN_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    QUEUE_TYPE      reduce using rule 18 (assignment -> string_assignment .)
    STRING_TYPE     reduce using rule 18 (assignment -> string_assignment .)
    ENUM_TYPE       reduce using rule 18 (assignment -> string_assignment .)
    VAR             reduce using rule 18 (assignment -> string_assignment .)
    LIST_TYPE       reduce using rule 18 (assignment -> string_assignment .)
    MAP_TYPE        reduce using rule 18 (assignment -> string_assignment .)
    SET_TYPE        reduce using rule 18 (assignment -> string_assignment .)
    DYNAMIC_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    VOID            reduce using rule 18 (assignment -> string_assignment .)
    RBRACE          reduce using rule 18 (assignment -> string_assignment .)
    SEMICOLON       reduce using rule 18 (assignment -> string_assignment .)


state 22

    (46) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (47) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 87


state 23

    (74) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (78) concate -> LPAREN . concate PLUS concate RPAREN
    (85) logic -> LPAREN . logic logic_op logic RPAREN
    (82) comparison -> LPAREN . comparison comp_op number comparison
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    LSQUARE         shift and go to state 58

    arithmetic                     shift and go to state 88
    concate                        shift and go to state 89
    logic                          shift and go to state 90
    comparison                     shift and go to state 91
    number                         shift and go to state 92
    string                         shift and go to state 30
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 24

    (48) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 94


state 25

    (140) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 95


state 26

    (141) for_statement -> FOR . LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 96


state 27

    (112) lines -> line . LINE_BREAK lines
    (113) lines -> line . lines
    (114) lines -> line .
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

  ! reduce/reduce conflict for $end resolved using rule 114 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 114 (lines -> line .)
    LINE_BREAK      shift and go to state 97
    $end            reduce using rule 114 (lines -> line .)
    RBRACE          reduce using rule 114 (lines -> line .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! $end            [ reduce using rule 116 (lines -> .) ]
  ! RBRACE          [ reduce using rule 116 (lines -> .) ]

    line                           shift and go to state 27
    lines                          shift and go to state 98
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 28

    (115) lines -> LINE_BREAK .

    $end            reduce using rule 115 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 115 (lines -> LINE_BREAK .)


state 29

    (72) arithmetic -> number .
    (75) division -> number . DIVIDE number
    (101) value -> number .

  ! reduce/reduce conflict for $end resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for RPAREN resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for PRINT resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for IF resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for WHILE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for FOR resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for FINAL resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for CONST resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for VAR resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for VOID resolved using rule 72 (arithmetic -> number .)
  ! reduce/reduce conflict for RBRACE resolved using rule 72 (arithmetic -> number .)
    PLUS            reduce using rule 72 (arithmetic -> number .)
    MINUS           reduce using rule 72 (arithmetic -> number .)
    TIMES           reduce using rule 72 (arithmetic -> number .)
    $end            reduce using rule 72 (arithmetic -> number .)
    SEMICOLON       reduce using rule 72 (arithmetic -> number .)
    RPAREN          reduce using rule 72 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 72 (arithmetic -> number .)
    PRINT           reduce using rule 72 (arithmetic -> number .)
    IF              reduce using rule 72 (arithmetic -> number .)
    WHILE           reduce using rule 72 (arithmetic -> number .)
    FOR             reduce using rule 72 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 72 (arithmetic -> number .)
    FINAL           reduce using rule 72 (arithmetic -> number .)
    CONST           reduce using rule 72 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 72 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 72 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 72 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 72 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 72 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 72 (arithmetic -> number .)
    VAR             reduce using rule 72 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 72 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 72 (arithmetic -> number .)
    SET_TYPE        reduce using rule 72 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 72 (arithmetic -> number .)
    VOID            reduce using rule 72 (arithmetic -> number .)
    RBRACE          reduce using rule 72 (arithmetic -> number .)
    DIVIDE          shift and go to state 99
    COMMA           reduce using rule 101 (value -> number .)
    EQUAL           reduce using rule 101 (value -> number .)
    NOT_EQUAL       reduce using rule 101 (value -> number .)
    LESS            reduce using rule 101 (value -> number .)
    LESS_EQUAL      reduce using rule 101 (value -> number .)
    GREATER         reduce using rule 101 (value -> number .)
    GREATER_EQUAL   reduce using rule 101 (value -> number .)
    LOGICAL_AND     reduce using rule 101 (value -> number .)
    LOGICAL_OR      reduce using rule 101 (value -> number .)

  ! $end            [ reduce using rule 101 (value -> number .) ]
  ! SEMICOLON       [ reduce using rule 101 (value -> number .) ]
  ! RPAREN          [ reduce using rule 101 (value -> number .) ]
  ! LINE_BREAK      [ reduce using rule 101 (value -> number .) ]
  ! PRINT           [ reduce using rule 101 (value -> number .) ]
  ! IF              [ reduce using rule 101 (value -> number .) ]
  ! WHILE           [ reduce using rule 101 (value -> number .) ]
  ! FOR             [ reduce using rule 101 (value -> number .) ]
  ! IDENTIFIER      [ reduce using rule 101 (value -> number .) ]
  ! FINAL           [ reduce using rule 101 (value -> number .) ]
  ! CONST           [ reduce using rule 101 (value -> number .) ]
  ! INTEGER_TYPE    [ reduce using rule 101 (value -> number .) ]
  ! DOUBLE_TYPE     [ reduce using rule 101 (value -> number .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 101 (value -> number .) ]
  ! QUEUE_TYPE      [ reduce using rule 101 (value -> number .) ]
  ! STRING_TYPE     [ reduce using rule 101 (value -> number .) ]
  ! ENUM_TYPE       [ reduce using rule 101 (value -> number .) ]
  ! VAR             [ reduce using rule 101 (value -> number .) ]
  ! LIST_TYPE       [ reduce using rule 101 (value -> number .) ]
  ! MAP_TYPE        [ reduce using rule 101 (value -> number .) ]
  ! SET_TYPE        [ reduce using rule 101 (value -> number .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 101 (value -> number .) ]
  ! VOID            [ reduce using rule 101 (value -> number .) ]
  ! RBRACE          [ reduce using rule 101 (value -> number .) ]


state 30

    (76) concate -> string .
    (102) value -> string .

  ! reduce/reduce conflict for $end resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for RPAREN resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for PRINT resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for IF resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for WHILE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for FOR resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for FINAL resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for CONST resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for VAR resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for VOID resolved using rule 76 (concate -> string .)
  ! reduce/reduce conflict for RBRACE resolved using rule 76 (concate -> string .)
    PLUS            reduce using rule 76 (concate -> string .)
    $end            reduce using rule 76 (concate -> string .)
    SEMICOLON       reduce using rule 76 (concate -> string .)
    RPAREN          reduce using rule 76 (concate -> string .)
    LINE_BREAK      reduce using rule 76 (concate -> string .)
    PRINT           reduce using rule 76 (concate -> string .)
    IF              reduce using rule 76 (concate -> string .)
    WHILE           reduce using rule 76 (concate -> string .)
    FOR             reduce using rule 76 (concate -> string .)
    IDENTIFIER      reduce using rule 76 (concate -> string .)
    FINAL           reduce using rule 76 (concate -> string .)
    CONST           reduce using rule 76 (concate -> string .)
    INTEGER_TYPE    reduce using rule 76 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 76 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 76 (concate -> string .)
    QUEUE_TYPE      reduce using rule 76 (concate -> string .)
    STRING_TYPE     reduce using rule 76 (concate -> string .)
    ENUM_TYPE       reduce using rule 76 (concate -> string .)
    VAR             reduce using rule 76 (concate -> string .)
    LIST_TYPE       reduce using rule 76 (concate -> string .)
    MAP_TYPE        reduce using rule 76 (concate -> string .)
    SET_TYPE        reduce using rule 76 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 76 (concate -> string .)
    VOID            reduce using rule 76 (concate -> string .)
    RBRACE          reduce using rule 76 (concate -> string .)
    COMMA           reduce using rule 102 (value -> string .)
    EQUAL           reduce using rule 102 (value -> string .)
    NOT_EQUAL       reduce using rule 102 (value -> string .)
    LESS            reduce using rule 102 (value -> string .)
    LESS_EQUAL      reduce using rule 102 (value -> string .)
    GREATER         reduce using rule 102 (value -> string .)
    GREATER_EQUAL   reduce using rule 102 (value -> string .)
    LOGICAL_AND     reduce using rule 102 (value -> string .)
    LOGICAL_OR      reduce using rule 102 (value -> string .)

  ! $end            [ reduce using rule 102 (value -> string .) ]
  ! SEMICOLON       [ reduce using rule 102 (value -> string .) ]
  ! RPAREN          [ reduce using rule 102 (value -> string .) ]
  ! LINE_BREAK      [ reduce using rule 102 (value -> string .) ]
  ! PRINT           [ reduce using rule 102 (value -> string .) ]
  ! IF              [ reduce using rule 102 (value -> string .) ]
  ! WHILE           [ reduce using rule 102 (value -> string .) ]
  ! FOR             [ reduce using rule 102 (value -> string .) ]
  ! IDENTIFIER      [ reduce using rule 102 (value -> string .) ]
  ! FINAL           [ reduce using rule 102 (value -> string .) ]
  ! CONST           [ reduce using rule 102 (value -> string .) ]
  ! INTEGER_TYPE    [ reduce using rule 102 (value -> string .) ]
  ! DOUBLE_TYPE     [ reduce using rule 102 (value -> string .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 102 (value -> string .) ]
  ! QUEUE_TYPE      [ reduce using rule 102 (value -> string .) ]
  ! STRING_TYPE     [ reduce using rule 102 (value -> string .) ]
  ! ENUM_TYPE       [ reduce using rule 102 (value -> string .) ]
  ! VAR             [ reduce using rule 102 (value -> string .) ]
  ! LIST_TYPE       [ reduce using rule 102 (value -> string .) ]
  ! MAP_TYPE        [ reduce using rule 102 (value -> string .) ]
  ! SET_TYPE        [ reduce using rule 102 (value -> string .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 102 (value -> string .) ]
  ! VOID            [ reduce using rule 102 (value -> string .) ]
  ! RBRACE          [ reduce using rule 102 (value -> string .) ]


state 31

    (83) logic -> comparison .
    (81) comparison -> comparison . comp_op comparison
    (92) comp_op -> . EQUAL
    (93) comp_op -> . NOT_EQUAL
    (94) comp_op -> . LESS
    (95) comp_op -> . LESS_EQUAL
    (96) comp_op -> . GREATER
    (97) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 83 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 83 (logic -> comparison .)
    $end            reduce using rule 83 (logic -> comparison .)
    SEMICOLON       reduce using rule 83 (logic -> comparison .)
    RPAREN          reduce using rule 83 (logic -> comparison .)
    LINE_BREAK      reduce using rule 83 (logic -> comparison .)
    PRINT           reduce using rule 83 (logic -> comparison .)
    IF              reduce using rule 83 (logic -> comparison .)
    WHILE           reduce using rule 83 (logic -> comparison .)
    FOR             reduce using rule 83 (logic -> comparison .)
    IDENTIFIER      reduce using rule 83 (logic -> comparison .)
    FINAL           reduce using rule 83 (logic -> comparison .)
    CONST           reduce using rule 83 (logic -> comparison .)
    INTEGER_TYPE    reduce using rule 83 (logic -> comparison .)
    DOUBLE_TYPE     reduce using rule 83 (logic -> comparison .)
    BOOLEAN_TYPE    reduce using rule 83 (logic -> comparison .)
    QUEUE_TYPE      reduce using rule 83 (logic -> comparison .)
    STRING_TYPE     reduce using rule 83 (logic -> comparison .)
    ENUM_TYPE       reduce using rule 83 (logic -> comparison .)
    VAR             reduce using rule 83 (logic -> comparison .)
    LIST_TYPE       reduce using rule 83 (logic -> comparison .)
    MAP_TYPE        reduce using rule 83 (logic -> comparison .)
    SET_TYPE        reduce using rule 83 (logic -> comparison .)
    DYNAMIC_TYPE    reduce using rule 83 (logic -> comparison .)
    VOID            reduce using rule 83 (logic -> comparison .)
    RBRACE          reduce using rule 83 (logic -> comparison .)
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 100

state 32

    (86) logic -> LOGICAL_NOT . logic
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 108
    LOGICAL_NOT     shift and go to state 32
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    logic                          shift and go to state 107
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    number                         shift and go to state 109
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 33

    (79) comparison -> values .

    EQUAL           reduce using rule 79 (comparison -> values .)
    NOT_EQUAL       reduce using rule 79 (comparison -> values .)
    LESS            reduce using rule 79 (comparison -> values .)
    LESS_EQUAL      reduce using rule 79 (comparison -> values .)
    GREATER         reduce using rule 79 (comparison -> values .)
    GREATER_EQUAL   reduce using rule 79 (comparison -> values .)
    LOGICAL_AND     reduce using rule 79 (comparison -> values .)
    LOGICAL_OR      reduce using rule 79 (comparison -> values .)
    $end            reduce using rule 79 (comparison -> values .)
    SEMICOLON       reduce using rule 79 (comparison -> values .)
    RPAREN          reduce using rule 79 (comparison -> values .)
    LINE_BREAK      reduce using rule 79 (comparison -> values .)
    PRINT           reduce using rule 79 (comparison -> values .)
    IF              reduce using rule 79 (comparison -> values .)
    WHILE           reduce using rule 79 (comparison -> values .)
    FOR             reduce using rule 79 (comparison -> values .)
    IDENTIFIER      reduce using rule 79 (comparison -> values .)
    FINAL           reduce using rule 79 (comparison -> values .)
    CONST           reduce using rule 79 (comparison -> values .)
    INTEGER_TYPE    reduce using rule 79 (comparison -> values .)
    DOUBLE_TYPE     reduce using rule 79 (comparison -> values .)
    BOOLEAN_TYPE    reduce using rule 79 (comparison -> values .)
    QUEUE_TYPE      reduce using rule 79 (comparison -> values .)
    STRING_TYPE     reduce using rule 79 (comparison -> values .)
    ENUM_TYPE       reduce using rule 79 (comparison -> values .)
    VAR             reduce using rule 79 (comparison -> values .)
    LIST_TYPE       reduce using rule 79 (comparison -> values .)
    MAP_TYPE        reduce using rule 79 (comparison -> values .)
    SET_TYPE        reduce using rule 79 (comparison -> values .)
    DYNAMIC_TYPE    reduce using rule 79 (comparison -> values .)
    VOID            reduce using rule 79 (comparison -> values .)
    RBRACE          reduce using rule 79 (comparison -> values .)


state 34

    (44) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 44 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 44 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 44 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 44 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 44 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 44 (modifier -> FINAL .)
    VAR             reduce using rule 44 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 44 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 44 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 44 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 44 (modifier -> FINAL .)
    VOID            reduce using rule 44 (modifier -> FINAL .)


state 35

    (45) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 45 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 45 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 45 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 45 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 45 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 45 (modifier -> CONST .)
    VAR             reduce using rule 45 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 45 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 45 (modifier -> CONST .)
    SET_TYPE        reduce using rule 45 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 45 (modifier -> CONST .)
    VOID            reduce using rule 45 (modifier -> CONST .)


state 36

    (55) type -> INTEGER_TYPE .
    (33) number_type -> INTEGER_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 33 (number_type -> INTEGER_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 33 (number_type -> INTEGER_TYPE .)
    IDENTIFIER      reduce using rule 33 (number_type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 33 (number_type -> INTEGER_TYPE .)

  ! IDENTIFIER      [ reduce using rule 55 (type -> INTEGER_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 55 (type -> INTEGER_TYPE .) ]


state 37

    (56) type -> DOUBLE_TYPE .
    (35) number_type -> DOUBLE_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 35 (number_type -> DOUBLE_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 35 (number_type -> DOUBLE_TYPE .)
    IDENTIFIER      reduce using rule 35 (number_type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 35 (number_type -> DOUBLE_TYPE .)

  ! IDENTIFIER      [ reduce using rule 56 (type -> DOUBLE_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 56 (type -> DOUBLE_TYPE .) ]


state 38

    (57) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 57 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 57 (type -> BOOLEAN_TYPE .)


state 39

    (58) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 58 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 58 (type -> QUEUE_TYPE .)


state 40

    (59) type -> STRING_TYPE .
    (36) string_type -> STRING_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (string_type -> STRING_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 36 (string_type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 36 (string_type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 36 (string_type -> STRING_TYPE .)

  ! IDENTIFIER      [ reduce using rule 59 (type -> STRING_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 59 (type -> STRING_TYPE .) ]


state 41

    (60) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 60 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 60 (type -> ENUM_TYPE .)


state 42

    (61) type -> VAR .
    (34) number_type -> VAR .
    (37) string_type -> VAR .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 34 (number_type -> VAR .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 34 (number_type -> VAR .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 34 (number_type -> VAR .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 34 (number_type -> VAR .)
    IDENTIFIER      reduce using rule 34 (number_type -> VAR .)
    QUESTION_MARK   reduce using rule 34 (number_type -> VAR .)

  ! IDENTIFIER      [ reduce using rule 61 (type -> VAR .) ]
  ! QUESTION_MARK   [ reduce using rule 61 (type -> VAR .) ]
  ! IDENTIFIER      [ reduce using rule 37 (string_type -> VAR .) ]
  ! QUESTION_MARK   [ reduce using rule 37 (string_type -> VAR .) ]


state 43

    (62) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 62 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 62 (type -> LIST_TYPE .)


state 44

    (63) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 63 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 63 (type -> MAP_TYPE .)


state 45

    (64) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 64 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 64 (type -> SET_TYPE .)


state 46

    (65) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 65 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 65 (type -> DYNAMIC_TYPE .)


state 47

    (66) type -> VOID .

    IDENTIFIER      reduce using rule 66 (type -> VOID .)
    QUESTION_MARK   reduce using rule 66 (type -> VOID .)


state 48

    (20) int_assignment -> number_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (22) int_assignment -> number_type . nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> number_type . IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> number_type . IDENTIFIER ASSIGN arithmetic
    (43) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 112
    QUESTION_MARK   shift and go to state 83

    nullable                       shift and go to state 111

state 49

    (27) string_assignment -> string_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (29) string_assignment -> string_type . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> string_type . IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> string_type . IDENTIFIER ASSIGN concate
    (43) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 114
    QUESTION_MARK   shift and go to state 83

    nullable                       shift and go to state 113

state 50

    (104) number -> INTEGER .

    DIVIDE          reduce using rule 104 (number -> INTEGER .)
    PLUS            reduce using rule 104 (number -> INTEGER .)
    MINUS           reduce using rule 104 (number -> INTEGER .)
    TIMES           reduce using rule 104 (number -> INTEGER .)
    $end            reduce using rule 104 (number -> INTEGER .)
    COMMA           reduce using rule 104 (number -> INTEGER .)
    EQUAL           reduce using rule 104 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 104 (number -> INTEGER .)
    LESS            reduce using rule 104 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 104 (number -> INTEGER .)
    GREATER         reduce using rule 104 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 104 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 104 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 104 (number -> INTEGER .)
    SEMICOLON       reduce using rule 104 (number -> INTEGER .)
    RPAREN          reduce using rule 104 (number -> INTEGER .)
    LINE_BREAK      reduce using rule 104 (number -> INTEGER .)
    PRINT           reduce using rule 104 (number -> INTEGER .)
    IF              reduce using rule 104 (number -> INTEGER .)
    WHILE           reduce using rule 104 (number -> INTEGER .)
    FOR             reduce using rule 104 (number -> INTEGER .)
    IDENTIFIER      reduce using rule 104 (number -> INTEGER .)
    FINAL           reduce using rule 104 (number -> INTEGER .)
    CONST           reduce using rule 104 (number -> INTEGER .)
    INTEGER_TYPE    reduce using rule 104 (number -> INTEGER .)
    DOUBLE_TYPE     reduce using rule 104 (number -> INTEGER .)
    BOOLEAN_TYPE    reduce using rule 104 (number -> INTEGER .)
    QUEUE_TYPE      reduce using rule 104 (number -> INTEGER .)
    STRING_TYPE     reduce using rule 104 (number -> INTEGER .)
    ENUM_TYPE       reduce using rule 104 (number -> INTEGER .)
    VAR             reduce using rule 104 (number -> INTEGER .)
    LIST_TYPE       reduce using rule 104 (number -> INTEGER .)
    MAP_TYPE        reduce using rule 104 (number -> INTEGER .)
    SET_TYPE        reduce using rule 104 (number -> INTEGER .)
    DYNAMIC_TYPE    reduce using rule 104 (number -> INTEGER .)
    VOID            reduce using rule 104 (number -> INTEGER .)
    RBRACE          reduce using rule 104 (number -> INTEGER .)
    RSQUARE         reduce using rule 104 (number -> INTEGER .)
    LPAREN          reduce using rule 104 (number -> INTEGER .)
    TRUE            reduce using rule 104 (number -> INTEGER .)
    FALSE           reduce using rule 104 (number -> INTEGER .)
    INTEGER         reduce using rule 104 (number -> INTEGER .)
    DOUBLE          reduce using rule 104 (number -> INTEGER .)
    STRING          reduce using rule 104 (number -> INTEGER .)
    LSQUARE         reduce using rule 104 (number -> INTEGER .)


state 51

    (105) number -> DOUBLE .

    DIVIDE          reduce using rule 105 (number -> DOUBLE .)
    PLUS            reduce using rule 105 (number -> DOUBLE .)
    MINUS           reduce using rule 105 (number -> DOUBLE .)
    TIMES           reduce using rule 105 (number -> DOUBLE .)
    $end            reduce using rule 105 (number -> DOUBLE .)
    COMMA           reduce using rule 105 (number -> DOUBLE .)
    EQUAL           reduce using rule 105 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 105 (number -> DOUBLE .)
    LESS            reduce using rule 105 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 105 (number -> DOUBLE .)
    GREATER         reduce using rule 105 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 105 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 105 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 105 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 105 (number -> DOUBLE .)
    RPAREN          reduce using rule 105 (number -> DOUBLE .)
    LINE_BREAK      reduce using rule 105 (number -> DOUBLE .)
    PRINT           reduce using rule 105 (number -> DOUBLE .)
    IF              reduce using rule 105 (number -> DOUBLE .)
    WHILE           reduce using rule 105 (number -> DOUBLE .)
    FOR             reduce using rule 105 (number -> DOUBLE .)
    IDENTIFIER      reduce using rule 105 (number -> DOUBLE .)
    FINAL           reduce using rule 105 (number -> DOUBLE .)
    CONST           reduce using rule 105 (number -> DOUBLE .)
    INTEGER_TYPE    reduce using rule 105 (number -> DOUBLE .)
    DOUBLE_TYPE     reduce using rule 105 (number -> DOUBLE .)
    BOOLEAN_TYPE    reduce using rule 105 (number -> DOUBLE .)
    QUEUE_TYPE      reduce using rule 105 (number -> DOUBLE .)
    STRING_TYPE     reduce using rule 105 (number -> DOUBLE .)
    ENUM_TYPE       reduce using rule 105 (number -> DOUBLE .)
    VAR             reduce using rule 105 (number -> DOUBLE .)
    LIST_TYPE       reduce using rule 105 (number -> DOUBLE .)
    MAP_TYPE        reduce using rule 105 (number -> DOUBLE .)
    SET_TYPE        reduce using rule 105 (number -> DOUBLE .)
    DYNAMIC_TYPE    reduce using rule 105 (number -> DOUBLE .)
    VOID            reduce using rule 105 (number -> DOUBLE .)
    RBRACE          reduce using rule 105 (number -> DOUBLE .)
    RSQUARE         reduce using rule 105 (number -> DOUBLE .)
    LPAREN          reduce using rule 105 (number -> DOUBLE .)
    TRUE            reduce using rule 105 (number -> DOUBLE .)
    FALSE           reduce using rule 105 (number -> DOUBLE .)
    INTEGER         reduce using rule 105 (number -> DOUBLE .)
    DOUBLE          reduce using rule 105 (number -> DOUBLE .)
    STRING          reduce using rule 105 (number -> DOUBLE .)
    LSQUARE         reduce using rule 105 (number -> DOUBLE .)


state 52

    (106) string -> STRING .

    PLUS            reduce using rule 106 (string -> STRING .)
    $end            reduce using rule 106 (string -> STRING .)
    COMMA           reduce using rule 106 (string -> STRING .)
    EQUAL           reduce using rule 106 (string -> STRING .)
    NOT_EQUAL       reduce using rule 106 (string -> STRING .)
    LESS            reduce using rule 106 (string -> STRING .)
    LESS_EQUAL      reduce using rule 106 (string -> STRING .)
    GREATER         reduce using rule 106 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 106 (string -> STRING .)
    LOGICAL_AND     reduce using rule 106 (string -> STRING .)
    LOGICAL_OR      reduce using rule 106 (string -> STRING .)
    SEMICOLON       reduce using rule 106 (string -> STRING .)
    RPAREN          reduce using rule 106 (string -> STRING .)
    LINE_BREAK      reduce using rule 106 (string -> STRING .)
    PRINT           reduce using rule 106 (string -> STRING .)
    IF              reduce using rule 106 (string -> STRING .)
    WHILE           reduce using rule 106 (string -> STRING .)
    FOR             reduce using rule 106 (string -> STRING .)
    IDENTIFIER      reduce using rule 106 (string -> STRING .)
    FINAL           reduce using rule 106 (string -> STRING .)
    CONST           reduce using rule 106 (string -> STRING .)
    INTEGER_TYPE    reduce using rule 106 (string -> STRING .)
    DOUBLE_TYPE     reduce using rule 106 (string -> STRING .)
    BOOLEAN_TYPE    reduce using rule 106 (string -> STRING .)
    QUEUE_TYPE      reduce using rule 106 (string -> STRING .)
    STRING_TYPE     reduce using rule 106 (string -> STRING .)
    ENUM_TYPE       reduce using rule 106 (string -> STRING .)
    VAR             reduce using rule 106 (string -> STRING .)
    LIST_TYPE       reduce using rule 106 (string -> STRING .)
    MAP_TYPE        reduce using rule 106 (string -> STRING .)
    SET_TYPE        reduce using rule 106 (string -> STRING .)
    DYNAMIC_TYPE    reduce using rule 106 (string -> STRING .)
    VOID            reduce using rule 106 (string -> STRING .)
    RBRACE          reduce using rule 106 (string -> STRING .)
    RSQUARE         reduce using rule 106 (string -> STRING .)


state 53

    (80) comparison -> boolean .

    EQUAL           reduce using rule 80 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 80 (comparison -> boolean .)
    LESS            reduce using rule 80 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 80 (comparison -> boolean .)
    GREATER         reduce using rule 80 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 80 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 80 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 80 (comparison -> boolean .)
    $end            reduce using rule 80 (comparison -> boolean .)
    SEMICOLON       reduce using rule 80 (comparison -> boolean .)
    RPAREN          reduce using rule 80 (comparison -> boolean .)
    LINE_BREAK      reduce using rule 80 (comparison -> boolean .)
    PRINT           reduce using rule 80 (comparison -> boolean .)
    IF              reduce using rule 80 (comparison -> boolean .)
    WHILE           reduce using rule 80 (comparison -> boolean .)
    FOR             reduce using rule 80 (comparison -> boolean .)
    IDENTIFIER      reduce using rule 80 (comparison -> boolean .)
    FINAL           reduce using rule 80 (comparison -> boolean .)
    CONST           reduce using rule 80 (comparison -> boolean .)
    INTEGER_TYPE    reduce using rule 80 (comparison -> boolean .)
    DOUBLE_TYPE     reduce using rule 80 (comparison -> boolean .)
    BOOLEAN_TYPE    reduce using rule 80 (comparison -> boolean .)
    QUEUE_TYPE      reduce using rule 80 (comparison -> boolean .)
    STRING_TYPE     reduce using rule 80 (comparison -> boolean .)
    ENUM_TYPE       reduce using rule 80 (comparison -> boolean .)
    VAR             reduce using rule 80 (comparison -> boolean .)
    LIST_TYPE       reduce using rule 80 (comparison -> boolean .)
    MAP_TYPE        reduce using rule 80 (comparison -> boolean .)
    SET_TYPE        reduce using rule 80 (comparison -> boolean .)
    DYNAMIC_TYPE    reduce using rule 80 (comparison -> boolean .)
    VOID            reduce using rule 80 (comparison -> boolean .)
    RBRACE          reduce using rule 80 (comparison -> boolean .)


state 54

    (98) values -> value .
    (99) values -> value . COMMA values

    EQUAL           reduce using rule 98 (values -> value .)
    NOT_EQUAL       reduce using rule 98 (values -> value .)
    LESS            reduce using rule 98 (values -> value .)
    LESS_EQUAL      reduce using rule 98 (values -> value .)
    GREATER         reduce using rule 98 (values -> value .)
    GREATER_EQUAL   reduce using rule 98 (values -> value .)
    LOGICAL_AND     reduce using rule 98 (values -> value .)
    LOGICAL_OR      reduce using rule 98 (values -> value .)
    $end            reduce using rule 98 (values -> value .)
    SEMICOLON       reduce using rule 98 (values -> value .)
    RPAREN          reduce using rule 98 (values -> value .)
    LINE_BREAK      reduce using rule 98 (values -> value .)
    PRINT           reduce using rule 98 (values -> value .)
    IF              reduce using rule 98 (values -> value .)
    WHILE           reduce using rule 98 (values -> value .)
    FOR             reduce using rule 98 (values -> value .)
    IDENTIFIER      reduce using rule 98 (values -> value .)
    FINAL           reduce using rule 98 (values -> value .)
    CONST           reduce using rule 98 (values -> value .)
    INTEGER_TYPE    reduce using rule 98 (values -> value .)
    DOUBLE_TYPE     reduce using rule 98 (values -> value .)
    BOOLEAN_TYPE    reduce using rule 98 (values -> value .)
    QUEUE_TYPE      reduce using rule 98 (values -> value .)
    STRING_TYPE     reduce using rule 98 (values -> value .)
    ENUM_TYPE       reduce using rule 98 (values -> value .)
    VAR             reduce using rule 98 (values -> value .)
    LIST_TYPE       reduce using rule 98 (values -> value .)
    MAP_TYPE        reduce using rule 98 (values -> value .)
    SET_TYPE        reduce using rule 98 (values -> value .)
    DYNAMIC_TYPE    reduce using rule 98 (values -> value .)
    VOID            reduce using rule 98 (values -> value .)
    RBRACE          reduce using rule 98 (values -> value .)
    RSQUARE         reduce using rule 98 (values -> value .)
    COMMA           shift and go to state 115


state 55

    (107) boolean -> TRUE .

    EQUAL           reduce using rule 107 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 107 (boolean -> TRUE .)
    LESS            reduce using rule 107 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 107 (boolean -> TRUE .)
    GREATER         reduce using rule 107 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 107 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 107 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 107 (boolean -> TRUE .)
    $end            reduce using rule 107 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 107 (boolean -> TRUE .)
    RPAREN          reduce using rule 107 (boolean -> TRUE .)
    LINE_BREAK      reduce using rule 107 (boolean -> TRUE .)
    PRINT           reduce using rule 107 (boolean -> TRUE .)
    IF              reduce using rule 107 (boolean -> TRUE .)
    WHILE           reduce using rule 107 (boolean -> TRUE .)
    FOR             reduce using rule 107 (boolean -> TRUE .)
    IDENTIFIER      reduce using rule 107 (boolean -> TRUE .)
    FINAL           reduce using rule 107 (boolean -> TRUE .)
    CONST           reduce using rule 107 (boolean -> TRUE .)
    INTEGER_TYPE    reduce using rule 107 (boolean -> TRUE .)
    DOUBLE_TYPE     reduce using rule 107 (boolean -> TRUE .)
    BOOLEAN_TYPE    reduce using rule 107 (boolean -> TRUE .)
    QUEUE_TYPE      reduce using rule 107 (boolean -> TRUE .)
    STRING_TYPE     reduce using rule 107 (boolean -> TRUE .)
    ENUM_TYPE       reduce using rule 107 (boolean -> TRUE .)
    VAR             reduce using rule 107 (boolean -> TRUE .)
    LIST_TYPE       reduce using rule 107 (boolean -> TRUE .)
    MAP_TYPE        reduce using rule 107 (boolean -> TRUE .)
    SET_TYPE        reduce using rule 107 (boolean -> TRUE .)
    DYNAMIC_TYPE    reduce using rule 107 (boolean -> TRUE .)
    VOID            reduce using rule 107 (boolean -> TRUE .)
    RBRACE          reduce using rule 107 (boolean -> TRUE .)


state 56

    (108) boolean -> FALSE .

    EQUAL           reduce using rule 108 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 108 (boolean -> FALSE .)
    LESS            reduce using rule 108 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 108 (boolean -> FALSE .)
    GREATER         reduce using rule 108 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 108 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 108 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 108 (boolean -> FALSE .)
    $end            reduce using rule 108 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 108 (boolean -> FALSE .)
    RPAREN          reduce using rule 108 (boolean -> FALSE .)
    LINE_BREAK      reduce using rule 108 (boolean -> FALSE .)
    PRINT           reduce using rule 108 (boolean -> FALSE .)
    IF              reduce using rule 108 (boolean -> FALSE .)
    WHILE           reduce using rule 108 (boolean -> FALSE .)
    FOR             reduce using rule 108 (boolean -> FALSE .)
    IDENTIFIER      reduce using rule 108 (boolean -> FALSE .)
    FINAL           reduce using rule 108 (boolean -> FALSE .)
    CONST           reduce using rule 108 (boolean -> FALSE .)
    INTEGER_TYPE    reduce using rule 108 (boolean -> FALSE .)
    DOUBLE_TYPE     reduce using rule 108 (boolean -> FALSE .)
    BOOLEAN_TYPE    reduce using rule 108 (boolean -> FALSE .)
    QUEUE_TYPE      reduce using rule 108 (boolean -> FALSE .)
    STRING_TYPE     reduce using rule 108 (boolean -> FALSE .)
    ENUM_TYPE       reduce using rule 108 (boolean -> FALSE .)
    VAR             reduce using rule 108 (boolean -> FALSE .)
    LIST_TYPE       reduce using rule 108 (boolean -> FALSE .)
    MAP_TYPE        reduce using rule 108 (boolean -> FALSE .)
    SET_TYPE        reduce using rule 108 (boolean -> FALSE .)
    DYNAMIC_TYPE    reduce using rule 108 (boolean -> FALSE .)
    VOID            reduce using rule 108 (boolean -> FALSE .)
    RBRACE          reduce using rule 108 (boolean -> FALSE .)


state 57

    (103) value -> list .

    COMMA           reduce using rule 103 (value -> list .)
    EQUAL           reduce using rule 103 (value -> list .)
    NOT_EQUAL       reduce using rule 103 (value -> list .)
    LESS            reduce using rule 103 (value -> list .)
    LESS_EQUAL      reduce using rule 103 (value -> list .)
    GREATER         reduce using rule 103 (value -> list .)
    GREATER_EQUAL   reduce using rule 103 (value -> list .)
    LOGICAL_AND     reduce using rule 103 (value -> list .)
    LOGICAL_OR      reduce using rule 103 (value -> list .)
    $end            reduce using rule 103 (value -> list .)
    SEMICOLON       reduce using rule 103 (value -> list .)
    RPAREN          reduce using rule 103 (value -> list .)
    LINE_BREAK      reduce using rule 103 (value -> list .)
    PRINT           reduce using rule 103 (value -> list .)
    IF              reduce using rule 103 (value -> list .)
    WHILE           reduce using rule 103 (value -> list .)
    FOR             reduce using rule 103 (value -> list .)
    IDENTIFIER      reduce using rule 103 (value -> list .)
    FINAL           reduce using rule 103 (value -> list .)
    CONST           reduce using rule 103 (value -> list .)
    INTEGER_TYPE    reduce using rule 103 (value -> list .)
    DOUBLE_TYPE     reduce using rule 103 (value -> list .)
    BOOLEAN_TYPE    reduce using rule 103 (value -> list .)
    QUEUE_TYPE      reduce using rule 103 (value -> list .)
    STRING_TYPE     reduce using rule 103 (value -> list .)
    ENUM_TYPE       reduce using rule 103 (value -> list .)
    VAR             reduce using rule 103 (value -> list .)
    LIST_TYPE       reduce using rule 103 (value -> list .)
    MAP_TYPE        reduce using rule 103 (value -> list .)
    SET_TYPE        reduce using rule 103 (value -> list .)
    DYNAMIC_TYPE    reduce using rule 103 (value -> list .)
    VOID            reduce using rule 103 (value -> list .)
    RBRACE          reduce using rule 103 (value -> list .)
    RSQUARE         reduce using rule 103 (value -> list .)


state 58

    (109) list -> LSQUARE . RSQUARE
    (110) list -> LSQUARE . values RSQUARE
    (98) values -> . value
    (99) values -> . value COMMA values
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 116
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    values                         shift and go to state 117
    value                          shift and go to state 54
    number                         shift and go to state 109
    string                         shift and go to state 110
    list                           shift and go to state 57

state 59

    (49) if_statement -> if_statement ELSE . if_statement
    (50) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 119
    IF              shift and go to state 24

    if_statement                   shift and go to state 118

state 60

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 120


state 61

    (117) line -> print .

    LINE_BREAK      reduce using rule 117 (line -> print .)
    PRINT           reduce using rule 117 (line -> print .)
    IF              reduce using rule 117 (line -> print .)
    WHILE           reduce using rule 117 (line -> print .)
    FOR             reduce using rule 117 (line -> print .)
    IDENTIFIER      reduce using rule 117 (line -> print .)
    FINAL           reduce using rule 117 (line -> print .)
    CONST           reduce using rule 117 (line -> print .)
    INTEGER_TYPE    reduce using rule 117 (line -> print .)
    DOUBLE_TYPE     reduce using rule 117 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 117 (line -> print .)
    QUEUE_TYPE      reduce using rule 117 (line -> print .)
    STRING_TYPE     reduce using rule 117 (line -> print .)
    ENUM_TYPE       reduce using rule 117 (line -> print .)
    VAR             reduce using rule 117 (line -> print .)
    LIST_TYPE       reduce using rule 117 (line -> print .)
    MAP_TYPE        reduce using rule 117 (line -> print .)
    SET_TYPE        reduce using rule 117 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 117 (line -> print .)
    VOID            reduce using rule 117 (line -> print .)
    RBRACE          reduce using rule 117 (line -> print .)
    $end            reduce using rule 117 (line -> print .)


state 62

    (118) line -> assignment .

    LINE_BREAK      reduce using rule 118 (line -> assignment .)
    PRINT           reduce using rule 118 (line -> assignment .)
    IF              reduce using rule 118 (line -> assignment .)
    WHILE           reduce using rule 118 (line -> assignment .)
    FOR             reduce using rule 118 (line -> assignment .)
    IDENTIFIER      reduce using rule 118 (line -> assignment .)
    FINAL           reduce using rule 118 (line -> assignment .)
    CONST           reduce using rule 118 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 118 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 118 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 118 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 118 (line -> assignment .)
    STRING_TYPE     reduce using rule 118 (line -> assignment .)
    ENUM_TYPE       reduce using rule 118 (line -> assignment .)
    VAR             reduce using rule 118 (line -> assignment .)
    LIST_TYPE       reduce using rule 118 (line -> assignment .)
    MAP_TYPE        reduce using rule 118 (line -> assignment .)
    SET_TYPE        reduce using rule 118 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 118 (line -> assignment .)
    VOID            reduce using rule 118 (line -> assignment .)
    RBRACE          reduce using rule 118 (line -> assignment .)
    $end            reduce using rule 118 (line -> assignment .)


state 63

    (119) line -> function .

    LINE_BREAK      reduce using rule 119 (line -> function .)
    PRINT           reduce using rule 119 (line -> function .)
    IF              reduce using rule 119 (line -> function .)
    WHILE           reduce using rule 119 (line -> function .)
    FOR             reduce using rule 119 (line -> function .)
    IDENTIFIER      reduce using rule 119 (line -> function .)
    FINAL           reduce using rule 119 (line -> function .)
    CONST           reduce using rule 119 (line -> function .)
    INTEGER_TYPE    reduce using rule 119 (line -> function .)
    DOUBLE_TYPE     reduce using rule 119 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 119 (line -> function .)
    QUEUE_TYPE      reduce using rule 119 (line -> function .)
    STRING_TYPE     reduce using rule 119 (line -> function .)
    ENUM_TYPE       reduce using rule 119 (line -> function .)
    VAR             reduce using rule 119 (line -> function .)
    LIST_TYPE       reduce using rule 119 (line -> function .)
    MAP_TYPE        reduce using rule 119 (line -> function .)
    SET_TYPE        reduce using rule 119 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 119 (line -> function .)
    VOID            reduce using rule 119 (line -> function .)
    RBRACE          reduce using rule 119 (line -> function .)
    $end            reduce using rule 119 (line -> function .)


state 64

    (120) line -> if_statement .
    (49) if_statement -> if_statement . ELSE if_statement
    (50) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 120 (line -> if_statement .)
    PRINT           reduce using rule 120 (line -> if_statement .)
    IF              reduce using rule 120 (line -> if_statement .)
    WHILE           reduce using rule 120 (line -> if_statement .)
    FOR             reduce using rule 120 (line -> if_statement .)
    IDENTIFIER      reduce using rule 120 (line -> if_statement .)
    FINAL           reduce using rule 120 (line -> if_statement .)
    CONST           reduce using rule 120 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 120 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 120 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 120 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 120 (line -> if_statement .)
    STRING_TYPE     reduce using rule 120 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 120 (line -> if_statement .)
    VAR             reduce using rule 120 (line -> if_statement .)
    LIST_TYPE       reduce using rule 120 (line -> if_statement .)
    MAP_TYPE        reduce using rule 120 (line -> if_statement .)
    SET_TYPE        reduce using rule 120 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 120 (line -> if_statement .)
    VOID            reduce using rule 120 (line -> if_statement .)
    RBRACE          reduce using rule 120 (line -> if_statement .)
    $end            reduce using rule 120 (line -> if_statement .)
    ELSE            shift and go to state 59


state 65

    (121) line -> while_statement .

    LINE_BREAK      reduce using rule 121 (line -> while_statement .)
    PRINT           reduce using rule 121 (line -> while_statement .)
    IF              reduce using rule 121 (line -> while_statement .)
    WHILE           reduce using rule 121 (line -> while_statement .)
    FOR             reduce using rule 121 (line -> while_statement .)
    IDENTIFIER      reduce using rule 121 (line -> while_statement .)
    FINAL           reduce using rule 121 (line -> while_statement .)
    CONST           reduce using rule 121 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 121 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 121 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 121 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 121 (line -> while_statement .)
    STRING_TYPE     reduce using rule 121 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 121 (line -> while_statement .)
    VAR             reduce using rule 121 (line -> while_statement .)
    LIST_TYPE       reduce using rule 121 (line -> while_statement .)
    MAP_TYPE        reduce using rule 121 (line -> while_statement .)
    SET_TYPE        reduce using rule 121 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 121 (line -> while_statement .)
    VOID            reduce using rule 121 (line -> while_statement .)
    RBRACE          reduce using rule 121 (line -> while_statement .)
    $end            reduce using rule 121 (line -> while_statement .)


state 66

    (122) line -> for_statement .

    LINE_BREAK      reduce using rule 122 (line -> for_statement .)
    PRINT           reduce using rule 122 (line -> for_statement .)
    IF              reduce using rule 122 (line -> for_statement .)
    WHILE           reduce using rule 122 (line -> for_statement .)
    FOR             reduce using rule 122 (line -> for_statement .)
    IDENTIFIER      reduce using rule 122 (line -> for_statement .)
    FINAL           reduce using rule 122 (line -> for_statement .)
    CONST           reduce using rule 122 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 122 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 122 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 122 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 122 (line -> for_statement .)
    STRING_TYPE     reduce using rule 122 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 122 (line -> for_statement .)
    VAR             reduce using rule 122 (line -> for_statement .)
    LIST_TYPE       reduce using rule 122 (line -> for_statement .)
    MAP_TYPE        reduce using rule 122 (line -> for_statement .)
    SET_TYPE        reduce using rule 122 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 122 (line -> for_statement .)
    VOID            reduce using rule 122 (line -> for_statement .)
    RBRACE          reduce using rule 122 (line -> for_statement .)
    $end            reduce using rule 122 (line -> for_statement .)


state 67

    (123) line -> function_call .

    LINE_BREAK      reduce using rule 123 (line -> function_call .)
    PRINT           reduce using rule 123 (line -> function_call .)
    IF              reduce using rule 123 (line -> function_call .)
    WHILE           reduce using rule 123 (line -> function_call .)
    FOR             reduce using rule 123 (line -> function_call .)
    IDENTIFIER      reduce using rule 123 (line -> function_call .)
    FINAL           reduce using rule 123 (line -> function_call .)
    CONST           reduce using rule 123 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 123 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 123 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 123 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 123 (line -> function_call .)
    STRING_TYPE     reduce using rule 123 (line -> function_call .)
    ENUM_TYPE       reduce using rule 123 (line -> function_call .)
    VAR             reduce using rule 123 (line -> function_call .)
    LIST_TYPE       reduce using rule 123 (line -> function_call .)
    MAP_TYPE        reduce using rule 123 (line -> function_call .)
    SET_TYPE        reduce using rule 123 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 123 (line -> function_call .)
    VOID            reduce using rule 123 (line -> function_call .)
    RBRACE          reduce using rule 123 (line -> function_call .)
    $end            reduce using rule 123 (line -> function_call .)


state 68

    (124) line -> reassignment .

    LINE_BREAK      reduce using rule 124 (line -> reassignment .)
    PRINT           reduce using rule 124 (line -> reassignment .)
    IF              reduce using rule 124 (line -> reassignment .)
    WHILE           reduce using rule 124 (line -> reassignment .)
    FOR             reduce using rule 124 (line -> reassignment .)
    IDENTIFIER      reduce using rule 124 (line -> reassignment .)
    FINAL           reduce using rule 124 (line -> reassignment .)
    CONST           reduce using rule 124 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 124 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 124 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 124 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 124 (line -> reassignment .)
    STRING_TYPE     reduce using rule 124 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 124 (line -> reassignment .)
    VAR             reduce using rule 124 (line -> reassignment .)
    LIST_TYPE       reduce using rule 124 (line -> reassignment .)
    MAP_TYPE        reduce using rule 124 (line -> reassignment .)
    SET_TYPE        reduce using rule 124 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 124 (line -> reassignment .)
    VOID            reduce using rule 124 (line -> reassignment .)
    RBRACE          reduce using rule 124 (line -> reassignment .)
    $end            reduce using rule 124 (line -> reassignment .)


state 69

    (51) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (52) function_call -> IDENTIFIER . LPAREN values RPAREN
    (53) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN RPAREN
    (38) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (39) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (40) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number
    (42) reassignment -> IDENTIFIER . INLINE_ARITH

    LPAREN          shift and go to state 86
    ASSIGN          shift and go to state 84
    INLINE_ARITH    shift and go to state 85


state 70

    (73) arithmetic -> arithmetic arith_op . arithmetic
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    arithmetic                     shift and go to state 121
    number                         shift and go to state 122

state 71

    (89) arith_op -> PLUS .

    LPAREN          reduce using rule 89 (arith_op -> PLUS .)
    INTEGER         reduce using rule 89 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 89 (arith_op -> PLUS .)


state 72

    (90) arith_op -> MINUS .

    LPAREN          reduce using rule 90 (arith_op -> MINUS .)
    INTEGER         reduce using rule 90 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 90 (arith_op -> MINUS .)


state 73

    (91) arith_op -> TIMES .

    LPAREN          reduce using rule 91 (arith_op -> TIMES .)
    INTEGER         reduce using rule 91 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 91 (arith_op -> TIMES .)


state 74

    (77) concate -> concate PLUS . concate
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (106) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 52

    concate                        shift and go to state 124
    string                         shift and go to state 125

state 75

    (84) logic -> logic logic_op . logic
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 108
    LOGICAL_NOT     shift and go to state 32
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    logic                          shift and go to state 127
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    number                         shift and go to state 109
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 76

    (87) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 87 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 87 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 87 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 87 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 87 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 87 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 87 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 87 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 87 (logic_op -> LOGICAL_AND .)


state 77

    (88) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 88 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 88 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 88 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 88 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 88 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 88 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 88 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 88 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 88 (logic_op -> LOGICAL_OR .)


state 78

    (12) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (43) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 129
    QUESTION_MARK   shift and go to state 83

    nullable                       shift and go to state 128

state 79

    (19) int_assignment -> modifier number_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> modifier number_type . nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> modifier number_type . IDENTIFIER ASSIGN arithmetic SEMICOLON
    (43) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 131
    QUESTION_MARK   shift and go to state 83

    nullable                       shift and go to state 130

state 80

    (26) string_assignment -> modifier string_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> modifier string_type . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> modifier string_type . IDENTIFIER ASSIGN concate SEMICOLON
    (43) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 133
    QUESTION_MARK   shift and go to state 83

    nullable                       shift and go to state 132

state 81

    (13) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 134


state 82

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression
    (111) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 135
    LPAREN          shift and go to state 136


state 83

    (43) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 43 (nullable -> QUESTION_MARK .)


state 84

    (38) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (67) expression -> . arithmetic
    (68) expression -> . concate
    (69) expression -> . logic
    (70) expression -> . function_call
    (71) expression -> . division
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) division -> . number DIVIDE number
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LSQUARE         shift and go to state 58

    expression                     shift and go to state 138
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 29
    string                         shift and go to state 30
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 85

    (39) reassignment -> IDENTIFIER INLINE_ARITH . number SEMICOLON
    (40) reassignment -> IDENTIFIER INLINE_ARITH . SEMICOLON
    (41) reassignment -> IDENTIFIER INLINE_ARITH . number
    (42) reassignment -> IDENTIFIER INLINE_ARITH .
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    SEMICOLON       shift and go to state 141
    $end            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LINE_BREAK      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    PRINT           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IF              reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    WHILE           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FOR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IDENTIFIER      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FINAL           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    CONST           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DOUBLE_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    BOOLEAN_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    QUEUE_TYPE      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    STRING_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    ENUM_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VAR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LIST_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    MAP_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    SET_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DYNAMIC_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VOID            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RBRACE          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RPAREN          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    number                         shift and go to state 140

state 86

    (51) function_call -> IDENTIFIER LPAREN . values RPAREN SEMICOLON
    (52) function_call -> IDENTIFIER LPAREN . values RPAREN
    (53) function_call -> IDENTIFIER LPAREN . RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN . RPAREN
    (98) values -> . value
    (99) values -> . value COMMA values
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 143
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    values                         shift and go to state 142
    value                          shift and go to state 54
    number                         shift and go to state 109
    string                         shift and go to state 110
    list                           shift and go to state 57

state 87

    (46) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (47) print -> PRINT LPAREN . RPAREN SEMICOLON
    (67) expression -> . arithmetic
    (68) expression -> . concate
    (69) expression -> . logic
    (70) expression -> . function_call
    (71) expression -> . division
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) division -> . number DIVIDE number
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 145
    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LSQUARE         shift and go to state 58

    expression                     shift and go to state 144
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 29
    string                         shift and go to state 30
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 88

    (74) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 146

state 89

    (78) concate -> LPAREN concate . PLUS concate RPAREN
    (77) concate -> concate . PLUS concate

    PLUS            shift and go to state 147


state 90

    (85) logic -> LPAREN logic . logic_op logic RPAREN
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 148

state 91

    (82) comparison -> LPAREN comparison . comp_op number comparison
    (83) logic -> comparison .
    (81) comparison -> comparison . comp_op comparison
    (92) comp_op -> . EQUAL
    (93) comp_op -> . NOT_EQUAL
    (94) comp_op -> . LESS
    (95) comp_op -> . LESS_EQUAL
    (96) comp_op -> . GREATER
    (97) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 83 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 83 (logic -> comparison .)
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 149

state 92

    (72) arithmetic -> number .
    (101) value -> number .

    PLUS            reduce using rule 72 (arithmetic -> number .)
    MINUS           reduce using rule 72 (arithmetic -> number .)
    TIMES           reduce using rule 72 (arithmetic -> number .)
    COMMA           reduce using rule 101 (value -> number .)
    EQUAL           reduce using rule 101 (value -> number .)
    NOT_EQUAL       reduce using rule 101 (value -> number .)
    LESS            reduce using rule 101 (value -> number .)
    LESS_EQUAL      reduce using rule 101 (value -> number .)
    GREATER         reduce using rule 101 (value -> number .)
    GREATER_EQUAL   reduce using rule 101 (value -> number .)
    LOGICAL_AND     reduce using rule 101 (value -> number .)
    LOGICAL_OR      reduce using rule 101 (value -> number .)


state 93

    (100) value -> IDENTIFIER .

    COMMA           reduce using rule 100 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 100 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 100 (value -> IDENTIFIER .)
    LESS            reduce using rule 100 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 100 (value -> IDENTIFIER .)
    GREATER         reduce using rule 100 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 100 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 100 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 100 (value -> IDENTIFIER .)
    $end            reduce using rule 100 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 100 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 100 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 100 (value -> IDENTIFIER .)
    PRINT           reduce using rule 100 (value -> IDENTIFIER .)
    IF              reduce using rule 100 (value -> IDENTIFIER .)
    WHILE           reduce using rule 100 (value -> IDENTIFIER .)
    FOR             reduce using rule 100 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 100 (value -> IDENTIFIER .)
    FINAL           reduce using rule 100 (value -> IDENTIFIER .)
    CONST           reduce using rule 100 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 100 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 100 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 100 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 100 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 100 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 100 (value -> IDENTIFIER .)
    VAR             reduce using rule 100 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 100 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 100 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 100 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 100 (value -> IDENTIFIER .)
    VOID            reduce using rule 100 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 100 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 100 (value -> IDENTIFIER .)


state 94

    (48) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 108
    LOGICAL_NOT     shift and go to state 32
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    logic                          shift and go to state 150
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    number                         shift and go to state 109
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 95

    (140) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 108
    LOGICAL_NOT     shift and go to state 32
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    logic                          shift and go to state 151
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    number                         shift and go to state 109
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 96

    (141) for_statement -> FOR LPAREN . assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    assignment                     shift and go to state 152
    modifier                       shift and go to state 17
    type                           shift and go to state 153
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 97

    (112) lines -> line LINE_BREAK . lines
    (115) lines -> LINE_BREAK .
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

  ! reduce/reduce conflict for $end resolved using rule 115 (lines -> LINE_BREAK .)
  ! reduce/reduce conflict for RBRACE resolved using rule 115 (lines -> LINE_BREAK .)
    $end            reduce using rule 115 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 115 (lines -> LINE_BREAK .)
    LINE_BREAK      shift and go to state 28
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

  ! $end            [ reduce using rule 116 (lines -> .) ]
  ! RBRACE          [ reduce using rule 116 (lines -> .) ]

    line                           shift and go to state 27
    lines                          shift and go to state 154
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 98

    (113) lines -> line lines .

    $end            reduce using rule 113 (lines -> line lines .)
    RBRACE          reduce using rule 113 (lines -> line lines .)


state 99

    (75) division -> number DIVIDE . number
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    number                         shift and go to state 155

state 100

    (81) comparison -> comparison comp_op . comparison
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 157
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    comparison                     shift and go to state 156
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    number                         shift and go to state 109
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 101

    (92) comp_op -> EQUAL .

    LPAREN          reduce using rule 92 (comp_op -> EQUAL .)
    TRUE            reduce using rule 92 (comp_op -> EQUAL .)
    FALSE           reduce using rule 92 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 92 (comp_op -> EQUAL .)
    INTEGER         reduce using rule 92 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 92 (comp_op -> EQUAL .)
    STRING          reduce using rule 92 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 92 (comp_op -> EQUAL .)


state 102

    (93) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 93 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 93 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 93 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 93 (comp_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 93 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 93 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 93 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 93 (comp_op -> NOT_EQUAL .)


state 103

    (94) comp_op -> LESS .

    LPAREN          reduce using rule 94 (comp_op -> LESS .)
    TRUE            reduce using rule 94 (comp_op -> LESS .)
    FALSE           reduce using rule 94 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 94 (comp_op -> LESS .)
    INTEGER         reduce using rule 94 (comp_op -> LESS .)
    DOUBLE          reduce using rule 94 (comp_op -> LESS .)
    STRING          reduce using rule 94 (comp_op -> LESS .)
    LSQUARE         reduce using rule 94 (comp_op -> LESS .)


state 104

    (95) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 95 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 95 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 95 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 95 (comp_op -> LESS_EQUAL .)
    INTEGER         reduce using rule 95 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 95 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 95 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 95 (comp_op -> LESS_EQUAL .)


state 105

    (96) comp_op -> GREATER .

    LPAREN          reduce using rule 96 (comp_op -> GREATER .)
    TRUE            reduce using rule 96 (comp_op -> GREATER .)
    FALSE           reduce using rule 96 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 96 (comp_op -> GREATER .)
    INTEGER         reduce using rule 96 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 96 (comp_op -> GREATER .)
    STRING          reduce using rule 96 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 96 (comp_op -> GREATER .)


state 106

    (97) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 97 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 97 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 97 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 97 (comp_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 97 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 97 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 97 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 97 (comp_op -> GREATER_EQUAL .)


state 107

    (86) logic -> LOGICAL_NOT logic .
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    LINE_BREAK      reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    PRINT           reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    IF              reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    WHILE           reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    FOR             reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    IDENTIFIER      reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    FINAL           reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    CONST           reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    INTEGER_TYPE    reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    DOUBLE_TYPE     reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    BOOLEAN_TYPE    reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    QUEUE_TYPE      reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    STRING_TYPE     reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    ENUM_TYPE       reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    VAR             reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    LIST_TYPE       reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    MAP_TYPE        reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    SET_TYPE        reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    DYNAMIC_TYPE    reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    VOID            reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    RBRACE          reduce using rule 86 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

  ! LOGICAL_AND     [ reduce using rule 86 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 86 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 75

state 108

    (85) logic -> LPAREN . logic logic_op logic RPAREN
    (82) comparison -> LPAREN . comparison comp_op number comparison
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 108
    LOGICAL_NOT     shift and go to state 32
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    logic                          shift and go to state 90
    comparison                     shift and go to state 91
    number                         shift and go to state 109
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 109

    (101) value -> number .

    COMMA           reduce using rule 101 (value -> number .)
    EQUAL           reduce using rule 101 (value -> number .)
    NOT_EQUAL       reduce using rule 101 (value -> number .)
    LESS            reduce using rule 101 (value -> number .)
    LESS_EQUAL      reduce using rule 101 (value -> number .)
    GREATER         reduce using rule 101 (value -> number .)
    GREATER_EQUAL   reduce using rule 101 (value -> number .)
    LOGICAL_AND     reduce using rule 101 (value -> number .)
    LOGICAL_OR      reduce using rule 101 (value -> number .)
    $end            reduce using rule 101 (value -> number .)
    SEMICOLON       reduce using rule 101 (value -> number .)
    RPAREN          reduce using rule 101 (value -> number .)
    LINE_BREAK      reduce using rule 101 (value -> number .)
    PRINT           reduce using rule 101 (value -> number .)
    IF              reduce using rule 101 (value -> number .)
    WHILE           reduce using rule 101 (value -> number .)
    FOR             reduce using rule 101 (value -> number .)
    IDENTIFIER      reduce using rule 101 (value -> number .)
    FINAL           reduce using rule 101 (value -> number .)
    CONST           reduce using rule 101 (value -> number .)
    INTEGER_TYPE    reduce using rule 101 (value -> number .)
    DOUBLE_TYPE     reduce using rule 101 (value -> number .)
    BOOLEAN_TYPE    reduce using rule 101 (value -> number .)
    QUEUE_TYPE      reduce using rule 101 (value -> number .)
    STRING_TYPE     reduce using rule 101 (value -> number .)
    ENUM_TYPE       reduce using rule 101 (value -> number .)
    VAR             reduce using rule 101 (value -> number .)
    LIST_TYPE       reduce using rule 101 (value -> number .)
    MAP_TYPE        reduce using rule 101 (value -> number .)
    SET_TYPE        reduce using rule 101 (value -> number .)
    DYNAMIC_TYPE    reduce using rule 101 (value -> number .)
    VOID            reduce using rule 101 (value -> number .)
    RBRACE          reduce using rule 101 (value -> number .)
    RSQUARE         reduce using rule 101 (value -> number .)


state 110

    (102) value -> string .

    COMMA           reduce using rule 102 (value -> string .)
    EQUAL           reduce using rule 102 (value -> string .)
    NOT_EQUAL       reduce using rule 102 (value -> string .)
    LESS            reduce using rule 102 (value -> string .)
    LESS_EQUAL      reduce using rule 102 (value -> string .)
    GREATER         reduce using rule 102 (value -> string .)
    GREATER_EQUAL   reduce using rule 102 (value -> string .)
    LOGICAL_AND     reduce using rule 102 (value -> string .)
    LOGICAL_OR      reduce using rule 102 (value -> string .)
    $end            reduce using rule 102 (value -> string .)
    SEMICOLON       reduce using rule 102 (value -> string .)
    RPAREN          reduce using rule 102 (value -> string .)
    LINE_BREAK      reduce using rule 102 (value -> string .)
    PRINT           reduce using rule 102 (value -> string .)
    IF              reduce using rule 102 (value -> string .)
    WHILE           reduce using rule 102 (value -> string .)
    FOR             reduce using rule 102 (value -> string .)
    IDENTIFIER      reduce using rule 102 (value -> string .)
    FINAL           reduce using rule 102 (value -> string .)
    CONST           reduce using rule 102 (value -> string .)
    INTEGER_TYPE    reduce using rule 102 (value -> string .)
    DOUBLE_TYPE     reduce using rule 102 (value -> string .)
    BOOLEAN_TYPE    reduce using rule 102 (value -> string .)
    QUEUE_TYPE      reduce using rule 102 (value -> string .)
    STRING_TYPE     reduce using rule 102 (value -> string .)
    ENUM_TYPE       reduce using rule 102 (value -> string .)
    VAR             reduce using rule 102 (value -> string .)
    LIST_TYPE       reduce using rule 102 (value -> string .)
    MAP_TYPE        reduce using rule 102 (value -> string .)
    SET_TYPE        reduce using rule 102 (value -> string .)
    DYNAMIC_TYPE    reduce using rule 102 (value -> string .)
    VOID            reduce using rule 102 (value -> string .)
    RBRACE          reduce using rule 102 (value -> string .)
    RSQUARE         reduce using rule 102 (value -> string .)


state 111

    (20) int_assignment -> number_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (22) int_assignment -> number_type nullable . IDENTIFIER ASSIGN arithmetic SEMICOLON

    IDENTIFIER      shift and go to state 158


state 112

    (24) int_assignment -> number_type IDENTIFIER . ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> number_type IDENTIFIER . ASSIGN arithmetic

    ASSIGN          shift and go to state 159


state 113

    (27) string_assignment -> string_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (29) string_assignment -> string_type nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 160


state 114

    (31) string_assignment -> string_type IDENTIFIER . ASSIGN concate SEMICOLON
    (32) string_assignment -> string_type IDENTIFIER . ASSIGN concate

    ASSIGN          shift and go to state 161


state 115

    (99) values -> value COMMA . values
    (98) values -> . value
    (99) values -> . value COMMA values
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    value                          shift and go to state 54
    values                         shift and go to state 162
    number                         shift and go to state 109
    string                         shift and go to state 110
    list                           shift and go to state 57

state 116

    (109) list -> LSQUARE RSQUARE .

    COMMA           reduce using rule 109 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 109 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 109 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 109 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 109 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 109 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 109 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 109 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 109 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 109 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 109 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 109 (list -> LSQUARE RSQUARE .)
    LINE_BREAK      reduce using rule 109 (list -> LSQUARE RSQUARE .)
    PRINT           reduce using rule 109 (list -> LSQUARE RSQUARE .)
    IF              reduce using rule 109 (list -> LSQUARE RSQUARE .)
    WHILE           reduce using rule 109 (list -> LSQUARE RSQUARE .)
    FOR             reduce using rule 109 (list -> LSQUARE RSQUARE .)
    IDENTIFIER      reduce using rule 109 (list -> LSQUARE RSQUARE .)
    FINAL           reduce using rule 109 (list -> LSQUARE RSQUARE .)
    CONST           reduce using rule 109 (list -> LSQUARE RSQUARE .)
    INTEGER_TYPE    reduce using rule 109 (list -> LSQUARE RSQUARE .)
    DOUBLE_TYPE     reduce using rule 109 (list -> LSQUARE RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 109 (list -> LSQUARE RSQUARE .)
    QUEUE_TYPE      reduce using rule 109 (list -> LSQUARE RSQUARE .)
    STRING_TYPE     reduce using rule 109 (list -> LSQUARE RSQUARE .)
    ENUM_TYPE       reduce using rule 109 (list -> LSQUARE RSQUARE .)
    VAR             reduce using rule 109 (list -> LSQUARE RSQUARE .)
    LIST_TYPE       reduce using rule 109 (list -> LSQUARE RSQUARE .)
    MAP_TYPE        reduce using rule 109 (list -> LSQUARE RSQUARE .)
    SET_TYPE        reduce using rule 109 (list -> LSQUARE RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 109 (list -> LSQUARE RSQUARE .)
    VOID            reduce using rule 109 (list -> LSQUARE RSQUARE .)
    RBRACE          reduce using rule 109 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 109 (list -> LSQUARE RSQUARE .)


state 117

    (110) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 163


state 118

    (49) if_statement -> if_statement ELSE if_statement .
    (49) if_statement -> if_statement . ELSE if_statement
    (50) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    WHILE           reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    FOR             reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    IDENTIFIER      reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 49 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 59

  ! ELSE            [ reduce using rule 49 (if_statement -> if_statement ELSE if_statement .) ]


state 119

    (50) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    LINE_BREAK      shift and go to state 28
    RBRACE          reduce using rule 116 (lines -> .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    if_statement                   shift and go to state 64
    lines                          shift and go to state 164
    line                           shift and go to state 27
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 120

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 121

    (73) arithmetic -> arithmetic arith_op arithmetic .
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    $end            reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    LINE_BREAK      reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    PRINT           reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    IF              reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    WHILE           reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    FOR             reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    IDENTIFIER      reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    FINAL           reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    CONST           reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER_TYPE    reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE_TYPE     reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    BOOLEAN_TYPE    reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    QUEUE_TYPE      reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING_TYPE     reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    ENUM_TYPE       reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    VAR             reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    LIST_TYPE       reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    MAP_TYPE        reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    SET_TYPE        reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    DYNAMIC_TYPE    reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    VOID            reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    RBRACE          reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

  ! PLUS            [ reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 70

state 122

    (72) arithmetic -> number .

    PLUS            reduce using rule 72 (arithmetic -> number .)
    MINUS           reduce using rule 72 (arithmetic -> number .)
    TIMES           reduce using rule 72 (arithmetic -> number .)
    $end            reduce using rule 72 (arithmetic -> number .)
    SEMICOLON       reduce using rule 72 (arithmetic -> number .)
    RPAREN          reduce using rule 72 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 72 (arithmetic -> number .)
    PRINT           reduce using rule 72 (arithmetic -> number .)
    IF              reduce using rule 72 (arithmetic -> number .)
    WHILE           reduce using rule 72 (arithmetic -> number .)
    FOR             reduce using rule 72 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 72 (arithmetic -> number .)
    FINAL           reduce using rule 72 (arithmetic -> number .)
    CONST           reduce using rule 72 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 72 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 72 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 72 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 72 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 72 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 72 (arithmetic -> number .)
    VAR             reduce using rule 72 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 72 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 72 (arithmetic -> number .)
    SET_TYPE        reduce using rule 72 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 72 (arithmetic -> number .)
    VOID            reduce using rule 72 (arithmetic -> number .)
    RBRACE          reduce using rule 72 (arithmetic -> number .)


state 123

    (74) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    arithmetic                     shift and go to state 88
    number                         shift and go to state 122

state 124

    (77) concate -> concate PLUS concate .
    (77) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    $end            reduce using rule 77 (concate -> concate PLUS concate .)
    SEMICOLON       reduce using rule 77 (concate -> concate PLUS concate .)
    RPAREN          reduce using rule 77 (concate -> concate PLUS concate .)
    LINE_BREAK      reduce using rule 77 (concate -> concate PLUS concate .)
    PRINT           reduce using rule 77 (concate -> concate PLUS concate .)
    IF              reduce using rule 77 (concate -> concate PLUS concate .)
    WHILE           reduce using rule 77 (concate -> concate PLUS concate .)
    FOR             reduce using rule 77 (concate -> concate PLUS concate .)
    IDENTIFIER      reduce using rule 77 (concate -> concate PLUS concate .)
    FINAL           reduce using rule 77 (concate -> concate PLUS concate .)
    CONST           reduce using rule 77 (concate -> concate PLUS concate .)
    INTEGER_TYPE    reduce using rule 77 (concate -> concate PLUS concate .)
    DOUBLE_TYPE     reduce using rule 77 (concate -> concate PLUS concate .)
    BOOLEAN_TYPE    reduce using rule 77 (concate -> concate PLUS concate .)
    QUEUE_TYPE      reduce using rule 77 (concate -> concate PLUS concate .)
    STRING_TYPE     reduce using rule 77 (concate -> concate PLUS concate .)
    ENUM_TYPE       reduce using rule 77 (concate -> concate PLUS concate .)
    VAR             reduce using rule 77 (concate -> concate PLUS concate .)
    LIST_TYPE       reduce using rule 77 (concate -> concate PLUS concate .)
    MAP_TYPE        reduce using rule 77 (concate -> concate PLUS concate .)
    SET_TYPE        reduce using rule 77 (concate -> concate PLUS concate .)
    DYNAMIC_TYPE    reduce using rule 77 (concate -> concate PLUS concate .)
    VOID            reduce using rule 77 (concate -> concate PLUS concate .)
    RBRACE          reduce using rule 77 (concate -> concate PLUS concate .)
    PLUS            shift and go to state 74

  ! PLUS            [ reduce using rule 77 (concate -> concate PLUS concate .) ]


state 125

    (76) concate -> string .

    PLUS            reduce using rule 76 (concate -> string .)
    $end            reduce using rule 76 (concate -> string .)
    SEMICOLON       reduce using rule 76 (concate -> string .)
    RPAREN          reduce using rule 76 (concate -> string .)
    LINE_BREAK      reduce using rule 76 (concate -> string .)
    PRINT           reduce using rule 76 (concate -> string .)
    IF              reduce using rule 76 (concate -> string .)
    WHILE           reduce using rule 76 (concate -> string .)
    FOR             reduce using rule 76 (concate -> string .)
    IDENTIFIER      reduce using rule 76 (concate -> string .)
    FINAL           reduce using rule 76 (concate -> string .)
    CONST           reduce using rule 76 (concate -> string .)
    INTEGER_TYPE    reduce using rule 76 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 76 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 76 (concate -> string .)
    QUEUE_TYPE      reduce using rule 76 (concate -> string .)
    STRING_TYPE     reduce using rule 76 (concate -> string .)
    ENUM_TYPE       reduce using rule 76 (concate -> string .)
    VAR             reduce using rule 76 (concate -> string .)
    LIST_TYPE       reduce using rule 76 (concate -> string .)
    MAP_TYPE        reduce using rule 76 (concate -> string .)
    SET_TYPE        reduce using rule 76 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 76 (concate -> string .)
    VOID            reduce using rule 76 (concate -> string .)
    RBRACE          reduce using rule 76 (concate -> string .)


state 126

    (78) concate -> LPAREN . concate PLUS concate RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (106) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 52

    concate                        shift and go to state 89
    string                         shift and go to state 125

state 127

    (84) logic -> logic logic_op logic .
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 84 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 84 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 84 (logic -> logic logic_op logic .)
    LINE_BREAK      reduce using rule 84 (logic -> logic logic_op logic .)
    PRINT           reduce using rule 84 (logic -> logic logic_op logic .)
    IF              reduce using rule 84 (logic -> logic logic_op logic .)
    WHILE           reduce using rule 84 (logic -> logic logic_op logic .)
    FOR             reduce using rule 84 (logic -> logic logic_op logic .)
    IDENTIFIER      reduce using rule 84 (logic -> logic logic_op logic .)
    FINAL           reduce using rule 84 (logic -> logic logic_op logic .)
    CONST           reduce using rule 84 (logic -> logic logic_op logic .)
    INTEGER_TYPE    reduce using rule 84 (logic -> logic logic_op logic .)
    DOUBLE_TYPE     reduce using rule 84 (logic -> logic logic_op logic .)
    BOOLEAN_TYPE    reduce using rule 84 (logic -> logic logic_op logic .)
    QUEUE_TYPE      reduce using rule 84 (logic -> logic logic_op logic .)
    STRING_TYPE     reduce using rule 84 (logic -> logic logic_op logic .)
    ENUM_TYPE       reduce using rule 84 (logic -> logic logic_op logic .)
    VAR             reduce using rule 84 (logic -> logic logic_op logic .)
    LIST_TYPE       reduce using rule 84 (logic -> logic logic_op logic .)
    MAP_TYPE        reduce using rule 84 (logic -> logic logic_op logic .)
    SET_TYPE        reduce using rule 84 (logic -> logic logic_op logic .)
    DYNAMIC_TYPE    reduce using rule 84 (logic -> logic logic_op logic .)
    VOID            reduce using rule 84 (logic -> logic logic_op logic .)
    RBRACE          reduce using rule 84 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

  ! LOGICAL_AND     [ reduce using rule 84 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 84 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 75

state 128

    (12) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 165


state 129

    (14) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 166


state 130

    (19) int_assignment -> modifier number_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> modifier number_type nullable . IDENTIFIER ASSIGN arithmetic SEMICOLON

    IDENTIFIER      shift and go to state 167


state 131

    (23) int_assignment -> modifier number_type IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 168


state 132

    (26) string_assignment -> modifier string_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> modifier string_type nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 169


state 133

    (30) string_assignment -> modifier string_type IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 170


state 134

    (13) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 171


state 135

    (15) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN . expression
    (67) expression -> . arithmetic
    (68) expression -> . concate
    (69) expression -> . logic
    (70) expression -> . function_call
    (71) expression -> . division
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) division -> . number DIVIDE number
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LSQUARE         shift and go to state 58

    expression                     shift and go to state 172
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 29
    string                         shift and go to state 30
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 136

    (111) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (125) parameters -> . VOID
    (126) parameters -> . parameter
    (127) parameters -> . parameter COMMA parameters
    (128) parameters -> .
    (129) parameter -> . type IDENTIFIER
    (130) parameter -> . IDENTIFIER
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID

    VOID            shift and go to state 176
    RPAREN          reduce using rule 128 (parameters -> .)
    IDENTIFIER      shift and go to state 174
    INTEGER_TYPE    shift and go to state 178
    DOUBLE_TYPE     shift and go to state 179
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 180
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 181
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46

    type                           shift and go to state 173
    parameters                     shift and go to state 175
    parameter                      shift and go to state 177

state 137

    (51) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (52) function_call -> IDENTIFIER . LPAREN values RPAREN
    (53) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN RPAREN
    (100) value -> IDENTIFIER .

    LPAREN          shift and go to state 86
    COMMA           reduce using rule 100 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 100 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 100 (value -> IDENTIFIER .)
    LESS            reduce using rule 100 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 100 (value -> IDENTIFIER .)
    GREATER         reduce using rule 100 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 100 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 100 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 100 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 100 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 100 (value -> IDENTIFIER .)
    $end            reduce using rule 100 (value -> IDENTIFIER .)
    LINE_BREAK      reduce using rule 100 (value -> IDENTIFIER .)
    PRINT           reduce using rule 100 (value -> IDENTIFIER .)
    IF              reduce using rule 100 (value -> IDENTIFIER .)
    WHILE           reduce using rule 100 (value -> IDENTIFIER .)
    FOR             reduce using rule 100 (value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 100 (value -> IDENTIFIER .)
    FINAL           reduce using rule 100 (value -> IDENTIFIER .)
    CONST           reduce using rule 100 (value -> IDENTIFIER .)
    INTEGER_TYPE    reduce using rule 100 (value -> IDENTIFIER .)
    DOUBLE_TYPE     reduce using rule 100 (value -> IDENTIFIER .)
    BOOLEAN_TYPE    reduce using rule 100 (value -> IDENTIFIER .)
    QUEUE_TYPE      reduce using rule 100 (value -> IDENTIFIER .)
    STRING_TYPE     reduce using rule 100 (value -> IDENTIFIER .)
    ENUM_TYPE       reduce using rule 100 (value -> IDENTIFIER .)
    VAR             reduce using rule 100 (value -> IDENTIFIER .)
    LIST_TYPE       reduce using rule 100 (value -> IDENTIFIER .)
    MAP_TYPE        reduce using rule 100 (value -> IDENTIFIER .)
    SET_TYPE        reduce using rule 100 (value -> IDENTIFIER .)
    DYNAMIC_TYPE    reduce using rule 100 (value -> IDENTIFIER .)
    VOID            reduce using rule 100 (value -> IDENTIFIER .)
    RBRACE          reduce using rule 100 (value -> IDENTIFIER .)


state 138

    (38) reassignment -> IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 182


state 139

    (70) expression -> function_call .

    SEMICOLON       reduce using rule 70 (expression -> function_call .)
    RPAREN          reduce using rule 70 (expression -> function_call .)
    $end            reduce using rule 70 (expression -> function_call .)
    LINE_BREAK      reduce using rule 70 (expression -> function_call .)
    PRINT           reduce using rule 70 (expression -> function_call .)
    IF              reduce using rule 70 (expression -> function_call .)
    WHILE           reduce using rule 70 (expression -> function_call .)
    FOR             reduce using rule 70 (expression -> function_call .)
    IDENTIFIER      reduce using rule 70 (expression -> function_call .)
    FINAL           reduce using rule 70 (expression -> function_call .)
    CONST           reduce using rule 70 (expression -> function_call .)
    INTEGER_TYPE    reduce using rule 70 (expression -> function_call .)
    DOUBLE_TYPE     reduce using rule 70 (expression -> function_call .)
    BOOLEAN_TYPE    reduce using rule 70 (expression -> function_call .)
    QUEUE_TYPE      reduce using rule 70 (expression -> function_call .)
    STRING_TYPE     reduce using rule 70 (expression -> function_call .)
    ENUM_TYPE       reduce using rule 70 (expression -> function_call .)
    VAR             reduce using rule 70 (expression -> function_call .)
    LIST_TYPE       reduce using rule 70 (expression -> function_call .)
    MAP_TYPE        reduce using rule 70 (expression -> function_call .)
    SET_TYPE        reduce using rule 70 (expression -> function_call .)
    DYNAMIC_TYPE    reduce using rule 70 (expression -> function_call .)
    VOID            reduce using rule 70 (expression -> function_call .)
    RBRACE          reduce using rule 70 (expression -> function_call .)


state 140

    (39) reassignment -> IDENTIFIER INLINE_ARITH number . SEMICOLON
    (41) reassignment -> IDENTIFIER INLINE_ARITH number .

    SEMICOLON       shift and go to state 183
    $end            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LINE_BREAK      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    PRINT           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IF              reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    WHILE           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FOR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IDENTIFIER      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FINAL           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    CONST           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    INTEGER_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DOUBLE_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    BOOLEAN_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    QUEUE_TYPE      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    STRING_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    ENUM_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VAR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LIST_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    MAP_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    SET_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DYNAMIC_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VOID            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RBRACE          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RPAREN          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number .)


state 141

    (40) reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .

    $end            reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LINE_BREAK      reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    PRINT           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IF              reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    WHILE           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FOR             reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FINAL           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    CONST           reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    INTEGER_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    QUEUE_TYPE      reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    STRING_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    ENUM_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VAR             reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LIST_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    MAP_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    SET_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VOID            reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RBRACE          reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RPAREN          reduce using rule 40 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)


state 142

    (51) function_call -> IDENTIFIER LPAREN values . RPAREN SEMICOLON
    (52) function_call -> IDENTIFIER LPAREN values . RPAREN

    RPAREN          shift and go to state 184


state 143

    (53) function_call -> IDENTIFIER LPAREN RPAREN . SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 185
    $end            reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LINE_BREAK      reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FINAL           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONST           reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BOOLEAN_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    QUEUE_TYPE      reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ENUM_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LIST_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MAP_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SET_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DYNAMIC_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VOID            reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 54 (function_call -> IDENTIFIER LPAREN RPAREN .) ]


state 144

    (46) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 186


state 145

    (47) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 187


state 146

    (74) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (73) arithmetic -> arithmetic arith_op . arithmetic
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    arithmetic                     shift and go to state 188
    number                         shift and go to state 122

state 147

    (78) concate -> LPAREN concate PLUS . concate RPAREN
    (77) concate -> concate PLUS . concate
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (106) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 52

    concate                        shift and go to state 189
    string                         shift and go to state 125

state 148

    (85) logic -> LPAREN logic logic_op . logic RPAREN
    (84) logic -> logic logic_op . logic
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 108
    LOGICAL_NOT     shift and go to state 32
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    logic                          shift and go to state 190
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    number                         shift and go to state 109
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 149

    (82) comparison -> LPAREN comparison comp_op . number comparison
    (81) comparison -> comparison comp_op . comparison
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    LPAREN          shift and go to state 157
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    comparison                     shift and go to state 156
    number                         shift and go to state 191
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 150

    (48) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 192
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 151

    (140) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 193
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 152

    (141) for_statement -> FOR LPAREN assignment . SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    SEMICOLON       shift and go to state 194


state 153

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (43) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 195
    QUESTION_MARK   shift and go to state 83

    nullable                       shift and go to state 81

state 154

    (112) lines -> line LINE_BREAK lines .

    $end            reduce using rule 112 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 112 (lines -> line LINE_BREAK lines .)


state 155

    (75) division -> number DIVIDE number .

    $end            reduce using rule 75 (division -> number DIVIDE number .)
    SEMICOLON       reduce using rule 75 (division -> number DIVIDE number .)
    RPAREN          reduce using rule 75 (division -> number DIVIDE number .)
    LINE_BREAK      reduce using rule 75 (division -> number DIVIDE number .)
    PRINT           reduce using rule 75 (division -> number DIVIDE number .)
    IF              reduce using rule 75 (division -> number DIVIDE number .)
    WHILE           reduce using rule 75 (division -> number DIVIDE number .)
    FOR             reduce using rule 75 (division -> number DIVIDE number .)
    IDENTIFIER      reduce using rule 75 (division -> number DIVIDE number .)
    FINAL           reduce using rule 75 (division -> number DIVIDE number .)
    CONST           reduce using rule 75 (division -> number DIVIDE number .)
    INTEGER_TYPE    reduce using rule 75 (division -> number DIVIDE number .)
    DOUBLE_TYPE     reduce using rule 75 (division -> number DIVIDE number .)
    BOOLEAN_TYPE    reduce using rule 75 (division -> number DIVIDE number .)
    QUEUE_TYPE      reduce using rule 75 (division -> number DIVIDE number .)
    STRING_TYPE     reduce using rule 75 (division -> number DIVIDE number .)
    ENUM_TYPE       reduce using rule 75 (division -> number DIVIDE number .)
    VAR             reduce using rule 75 (division -> number DIVIDE number .)
    LIST_TYPE       reduce using rule 75 (division -> number DIVIDE number .)
    MAP_TYPE        reduce using rule 75 (division -> number DIVIDE number .)
    SET_TYPE        reduce using rule 75 (division -> number DIVIDE number .)
    DYNAMIC_TYPE    reduce using rule 75 (division -> number DIVIDE number .)
    VOID            reduce using rule 75 (division -> number DIVIDE number .)
    RBRACE          reduce using rule 75 (division -> number DIVIDE number .)


state 156

    (81) comparison -> comparison comp_op comparison .
    (81) comparison -> comparison . comp_op comparison
    (92) comp_op -> . EQUAL
    (93) comp_op -> . NOT_EQUAL
    (94) comp_op -> . LESS
    (95) comp_op -> . LESS_EQUAL
    (96) comp_op -> . GREATER
    (97) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 81 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 81 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 81 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 81 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 81 (comparison -> comparison comp_op comparison .)
    LINE_BREAK      reduce using rule 81 (comparison -> comparison comp_op comparison .)
    PRINT           reduce using rule 81 (comparison -> comparison comp_op comparison .)
    IF              reduce using rule 81 (comparison -> comparison comp_op comparison .)
    WHILE           reduce using rule 81 (comparison -> comparison comp_op comparison .)
    FOR             reduce using rule 81 (comparison -> comparison comp_op comparison .)
    IDENTIFIER      reduce using rule 81 (comparison -> comparison comp_op comparison .)
    FINAL           reduce using rule 81 (comparison -> comparison comp_op comparison .)
    CONST           reduce using rule 81 (comparison -> comparison comp_op comparison .)
    INTEGER_TYPE    reduce using rule 81 (comparison -> comparison comp_op comparison .)
    DOUBLE_TYPE     reduce using rule 81 (comparison -> comparison comp_op comparison .)
    BOOLEAN_TYPE    reduce using rule 81 (comparison -> comparison comp_op comparison .)
    QUEUE_TYPE      reduce using rule 81 (comparison -> comparison comp_op comparison .)
    STRING_TYPE     reduce using rule 81 (comparison -> comparison comp_op comparison .)
    ENUM_TYPE       reduce using rule 81 (comparison -> comparison comp_op comparison .)
    VAR             reduce using rule 81 (comparison -> comparison comp_op comparison .)
    LIST_TYPE       reduce using rule 81 (comparison -> comparison comp_op comparison .)
    MAP_TYPE        reduce using rule 81 (comparison -> comparison comp_op comparison .)
    SET_TYPE        reduce using rule 81 (comparison -> comparison comp_op comparison .)
    DYNAMIC_TYPE    reduce using rule 81 (comparison -> comparison comp_op comparison .)
    VOID            reduce using rule 81 (comparison -> comparison comp_op comparison .)
    RBRACE          reduce using rule 81 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

  ! EQUAL           [ reduce using rule 81 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 81 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 81 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 81 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 81 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 81 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 100

state 157

    (82) comparison -> LPAREN . comparison comp_op number comparison
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 157
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    comparison                     shift and go to state 196
    number                         shift and go to state 109
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 158

    (20) int_assignment -> number_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (22) int_assignment -> number_type nullable IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 197


state 159

    (24) int_assignment -> number_type IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (25) int_assignment -> number_type IDENTIFIER ASSIGN . arithmetic
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    arithmetic                     shift and go to state 198
    number                         shift and go to state 122

state 160

    (27) string_assignment -> string_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (29) string_assignment -> string_type nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 199


state 161

    (31) string_assignment -> string_type IDENTIFIER ASSIGN . concate SEMICOLON
    (32) string_assignment -> string_type IDENTIFIER ASSIGN . concate
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (106) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 52

    concate                        shift and go to state 200
    string                         shift and go to state 125

state 162

    (99) values -> value COMMA values .

    EQUAL           reduce using rule 99 (values -> value COMMA values .)
    NOT_EQUAL       reduce using rule 99 (values -> value COMMA values .)
    LESS            reduce using rule 99 (values -> value COMMA values .)
    LESS_EQUAL      reduce using rule 99 (values -> value COMMA values .)
    GREATER         reduce using rule 99 (values -> value COMMA values .)
    GREATER_EQUAL   reduce using rule 99 (values -> value COMMA values .)
    LOGICAL_AND     reduce using rule 99 (values -> value COMMA values .)
    LOGICAL_OR      reduce using rule 99 (values -> value COMMA values .)
    $end            reduce using rule 99 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 99 (values -> value COMMA values .)
    RPAREN          reduce using rule 99 (values -> value COMMA values .)
    LINE_BREAK      reduce using rule 99 (values -> value COMMA values .)
    PRINT           reduce using rule 99 (values -> value COMMA values .)
    IF              reduce using rule 99 (values -> value COMMA values .)
    WHILE           reduce using rule 99 (values -> value COMMA values .)
    FOR             reduce using rule 99 (values -> value COMMA values .)
    IDENTIFIER      reduce using rule 99 (values -> value COMMA values .)
    FINAL           reduce using rule 99 (values -> value COMMA values .)
    CONST           reduce using rule 99 (values -> value COMMA values .)
    INTEGER_TYPE    reduce using rule 99 (values -> value COMMA values .)
    DOUBLE_TYPE     reduce using rule 99 (values -> value COMMA values .)
    BOOLEAN_TYPE    reduce using rule 99 (values -> value COMMA values .)
    QUEUE_TYPE      reduce using rule 99 (values -> value COMMA values .)
    STRING_TYPE     reduce using rule 99 (values -> value COMMA values .)
    ENUM_TYPE       reduce using rule 99 (values -> value COMMA values .)
    VAR             reduce using rule 99 (values -> value COMMA values .)
    LIST_TYPE       reduce using rule 99 (values -> value COMMA values .)
    MAP_TYPE        reduce using rule 99 (values -> value COMMA values .)
    SET_TYPE        reduce using rule 99 (values -> value COMMA values .)
    DYNAMIC_TYPE    reduce using rule 99 (values -> value COMMA values .)
    VOID            reduce using rule 99 (values -> value COMMA values .)
    RBRACE          reduce using rule 99 (values -> value COMMA values .)
    RSQUARE         reduce using rule 99 (values -> value COMMA values .)


state 163

    (110) list -> LSQUARE values RSQUARE .

    COMMA           reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    LINE_BREAK      reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    PRINT           reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    IF              reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    WHILE           reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    FOR             reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    IDENTIFIER      reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    FINAL           reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    CONST           reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    INTEGER_TYPE    reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    DOUBLE_TYPE     reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    BOOLEAN_TYPE    reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    QUEUE_TYPE      reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    STRING_TYPE     reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    ENUM_TYPE       reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    VAR             reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    LIST_TYPE       reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    MAP_TYPE        reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    SET_TYPE        reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    DYNAMIC_TYPE    reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    VOID            reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    RBRACE          reduce using rule 110 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 110 (list -> LSQUARE values RSQUARE .)


state 164

    (50) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 201


state 165

    (12) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 202


state 166

    (14) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (67) expression -> . arithmetic
    (68) expression -> . concate
    (69) expression -> . logic
    (70) expression -> . function_call
    (71) expression -> . division
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) division -> . number DIVIDE number
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LSQUARE         shift and go to state 58

    expression                     shift and go to state 203
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 29
    string                         shift and go to state 30
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 167

    (19) int_assignment -> modifier number_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (21) int_assignment -> modifier number_type nullable IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 204


state 168

    (23) int_assignment -> modifier number_type IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    arithmetic                     shift and go to state 205
    number                         shift and go to state 122

state 169

    (26) string_assignment -> modifier string_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (28) string_assignment -> modifier string_type nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 206


state 170

    (30) string_assignment -> modifier string_type IDENTIFIER ASSIGN . concate SEMICOLON
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (106) string -> . STRING

    LPAREN          shift and go to state 126
    STRING          shift and go to state 52

    concate                        shift and go to state 207
    string                         shift and go to state 125

state 171

    (13) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (67) expression -> . arithmetic
    (68) expression -> . concate
    (69) expression -> . logic
    (70) expression -> . function_call
    (71) expression -> . division
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) division -> . number DIVIDE number
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LSQUARE         shift and go to state 58

    expression                     shift and go to state 208
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 29
    string                         shift and go to state 30
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 172

    (15) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN expression .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 209
    $end            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LINE_BREAK      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    PRINT           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FINAL           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    BOOLEAN_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    QUEUE_TYPE      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    ENUM_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LIST_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    MAP_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    SET_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DYNAMIC_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VOID            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)

  ! SEMICOLON       [ reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .) ]


state 173

    (129) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 210


state 174

    (130) parameter -> IDENTIFIER .

    COMMA           reduce using rule 130 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 130 (parameter -> IDENTIFIER .)


state 175

    (111) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 211


state 176

    (125) parameters -> VOID .
    (66) type -> VOID .

    RPAREN          reduce using rule 125 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 66 (type -> VOID .)


state 177

    (126) parameters -> parameter .
    (127) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 126 (parameters -> parameter .)
    COMMA           shift and go to state 212


state 178

    (55) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 55 (type -> INTEGER_TYPE .)


state 179

    (56) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 56 (type -> DOUBLE_TYPE .)


state 180

    (59) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 59 (type -> STRING_TYPE .)


state 181

    (61) type -> VAR .

    IDENTIFIER      reduce using rule 61 (type -> VAR .)


state 182

    (38) reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 38 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 183

    (39) reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .

    $end            reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LINE_BREAK      reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    PRINT           reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IF              reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    WHILE           reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FOR             reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IDENTIFIER      reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FINAL           reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    CONST           reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    INTEGER_TYPE    reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    QUEUE_TYPE      reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    STRING_TYPE     reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    ENUM_TYPE       reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VAR             reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LIST_TYPE       reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    MAP_TYPE        reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    SET_TYPE        reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VOID            reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RBRACE          reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RPAREN          reduce using rule 39 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)


state 184

    (51) function_call -> IDENTIFIER LPAREN values RPAREN . SEMICOLON
    (52) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 213
    $end            reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LINE_BREAK      reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PRINT           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    WHILE           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FINAL           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER_TYPE    reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE_TYPE     reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN_TYPE    reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    QUEUE_TYPE      reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING_TYPE     reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    ENUM_TYPE       reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LIST_TYPE       reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    MAP_TYPE        reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SET_TYPE        reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DYNAMIC_TYPE    reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VOID            reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RBRACE          reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RPAREN          reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! SEMICOLON       [ reduce using rule 52 (function_call -> IDENTIFIER LPAREN values RPAREN .) ]


state 185

    (53) function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 53 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)


state 186

    (46) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 214


state 187

    (47) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 47 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 188

    (74) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (73) arithmetic -> arithmetic arith_op arithmetic .
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    RPAREN          shift and go to state 215
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

  ! PLUS            [ reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 73 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 70

state 189

    (78) concate -> LPAREN concate PLUS concate . RPAREN
    (77) concate -> concate PLUS concate .
    (77) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 216
    PLUS            shift and go to state 74

  ! PLUS            [ reduce using rule 77 (concate -> concate PLUS concate .) ]


state 190

    (85) logic -> LPAREN logic logic_op logic . RPAREN
    (84) logic -> logic logic_op logic .
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 217
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

  ! LOGICAL_AND     [ reduce using rule 84 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 84 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 75

state 191

    (82) comparison -> LPAREN comparison comp_op number . comparison
    (101) value -> number .
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    COMMA           reduce using rule 101 (value -> number .)
    EQUAL           reduce using rule 101 (value -> number .)
    NOT_EQUAL       reduce using rule 101 (value -> number .)
    LESS            reduce using rule 101 (value -> number .)
    LESS_EQUAL      reduce using rule 101 (value -> number .)
    GREATER         reduce using rule 101 (value -> number .)
    GREATER_EQUAL   reduce using rule 101 (value -> number .)
    LOGICAL_AND     reduce using rule 101 (value -> number .)
    LOGICAL_OR      reduce using rule 101 (value -> number .)
    LPAREN          shift and go to state 157
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    comparison                     shift and go to state 218
    number                         shift and go to state 109
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 192

    (48) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 219


state 193

    (140) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 220


state 194

    (141) for_statement -> FOR LPAREN assignment SEMICOLON . logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 108
    LOGICAL_NOT     shift and go to state 32
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    IDENTIFIER      shift and go to state 93
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    LSQUARE         shift and go to state 58

    logic                          shift and go to state 221
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    number                         shift and go to state 109
    value                          shift and go to state 54
    string                         shift and go to state 110
    list                           shift and go to state 57

state 195

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 135


state 196

    (82) comparison -> LPAREN comparison . comp_op number comparison
    (81) comparison -> comparison . comp_op comparison
    (92) comp_op -> . EQUAL
    (93) comp_op -> . NOT_EQUAL
    (94) comp_op -> . LESS
    (95) comp_op -> . LESS_EQUAL
    (96) comp_op -> . GREATER
    (97) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

    comp_op                        shift and go to state 149

state 197

    (20) int_assignment -> number_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (22) int_assignment -> number_type nullable IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    NULL            shift and go to state 222
    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    arithmetic                     shift and go to state 223
    number                         shift and go to state 122

state 198

    (24) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (25) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 224
    $end            reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    LINE_BREAK      reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    PRINT           reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    IF              reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    WHILE           reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    FOR             reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    IDENTIFIER      reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    FINAL           reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    CONST           reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    INTEGER_TYPE    reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    DOUBLE_TYPE     reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    BOOLEAN_TYPE    reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    QUEUE_TYPE      reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    STRING_TYPE     reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    ENUM_TYPE       reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    VAR             reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    LIST_TYPE       reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    MAP_TYPE        reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    SET_TYPE        reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    DYNAMIC_TYPE    reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    VOID            reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    RBRACE          reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

  ! SEMICOLON       [ reduce using rule 25 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .) ]

    arith_op                       shift and go to state 70

state 199

    (27) string_assignment -> string_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (29) string_assignment -> string_type nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (106) string -> . STRING

    NULL            shift and go to state 225
    LPAREN          shift and go to state 126
    STRING          shift and go to state 52

    concate                        shift and go to state 226
    string                         shift and go to state 125

state 200

    (31) string_assignment -> string_type IDENTIFIER ASSIGN concate . SEMICOLON
    (32) string_assignment -> string_type IDENTIFIER ASSIGN concate .
    (77) concate -> concate . PLUS concate

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 227
    $end            reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    LINE_BREAK      reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    PRINT           reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    IF              reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    WHILE           reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    FOR             reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    IDENTIFIER      reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    FINAL           reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    CONST           reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    INTEGER_TYPE    reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    DOUBLE_TYPE     reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    BOOLEAN_TYPE    reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    QUEUE_TYPE      reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    STRING_TYPE     reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    ENUM_TYPE       reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    VAR             reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    LIST_TYPE       reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    MAP_TYPE        reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    SET_TYPE        reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    DYNAMIC_TYPE    reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    VOID            reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    RBRACE          reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .)
    PLUS            shift and go to state 74

  ! SEMICOLON       [ reduce using rule 32 (string_assignment -> string_type IDENTIFIER ASSIGN concate .) ]


state 201

    (50) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    WHILE           reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FOR             reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 50 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 202

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (67) expression -> . arithmetic
    (68) expression -> . concate
    (69) expression -> . logic
    (70) expression -> . function_call
    (71) expression -> . division
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (83) logic -> . comparison
    (84) logic -> . logic logic_op logic
    (85) logic -> . LPAREN logic logic_op logic RPAREN
    (86) logic -> . LOGICAL_NOT logic
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (75) division -> . number DIVIDE number
    (104) number -> . INTEGER
    (105) number -> . DOUBLE
    (106) string -> . STRING
    (79) comparison -> . values
    (80) comparison -> . boolean
    (81) comparison -> . comparison comp_op comparison
    (82) comparison -> . LPAREN comparison comp_op number comparison
    (98) values -> . value
    (99) values -> . value COMMA values
    (107) boolean -> . TRUE
    (108) boolean -> . FALSE
    (100) value -> . IDENTIFIER
    (101) value -> . number
    (102) value -> . string
    (103) value -> . list
    (109) list -> . LSQUARE RSQUARE
    (110) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 23
    LOGICAL_NOT     shift and go to state 32
    IDENTIFIER      shift and go to state 137
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51
    STRING          shift and go to state 52
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LSQUARE         shift and go to state 58

    expression                     shift and go to state 228
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 139
    division                       shift and go to state 16
    number                         shift and go to state 29
    string                         shift and go to state 30
    comparison                     shift and go to state 31
    values                         shift and go to state 33
    boolean                        shift and go to state 53
    value                          shift and go to state 54
    list                           shift and go to state 57

state 203

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 229


state 204

    (19) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (21) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (72) arithmetic -> . number
    (73) arithmetic -> . arithmetic arith_op arithmetic
    (74) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (104) number -> . INTEGER
    (105) number -> . DOUBLE

    NULL            shift and go to state 230
    LPAREN          shift and go to state 123
    INTEGER         shift and go to state 50
    DOUBLE          shift and go to state 51

    arithmetic                     shift and go to state 231
    number                         shift and go to state 122

state 205

    (23) int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

    SEMICOLON       shift and go to state 232
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 206

    (26) string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (28) string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (76) concate -> . string
    (77) concate -> . concate PLUS concate
    (78) concate -> . LPAREN concate PLUS concate RPAREN
    (106) string -> . STRING

    NULL            shift and go to state 233
    LPAREN          shift and go to state 126
    STRING          shift and go to state 52

    concate                        shift and go to state 234
    string                         shift and go to state 125

state 207

    (30) string_assignment -> modifier string_type IDENTIFIER ASSIGN concate . SEMICOLON
    (77) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 235
    PLUS            shift and go to state 74


state 208

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 236


state 209

    (15) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 210

    (129) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 129 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 129 (parameter -> type IDENTIFIER .)


state 211

    (111) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 237


state 212

    (127) parameters -> parameter COMMA . parameters
    (125) parameters -> . VOID
    (126) parameters -> . parameter
    (127) parameters -> . parameter COMMA parameters
    (128) parameters -> .
    (129) parameter -> . type IDENTIFIER
    (130) parameter -> . IDENTIFIER
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID

    VOID            shift and go to state 176
    RPAREN          reduce using rule 128 (parameters -> .)
    IDENTIFIER      shift and go to state 174
    INTEGER_TYPE    shift and go to state 178
    DOUBLE_TYPE     shift and go to state 179
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 180
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 181
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46

    parameter                      shift and go to state 177
    parameters                     shift and go to state 238
    type                           shift and go to state 173

state 213

    (51) function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    WHILE           reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FINAL           reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    CONST           reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VOID            reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RBRACE          reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RPAREN          reduce using rule 51 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)


state 214

    (46) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 46 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 215

    (74) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LINE_BREAK      reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    PRINT           reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IF              reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    WHILE           reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FOR             reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FINAL           reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    CONST           reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER_TYPE    reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE_TYPE     reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    QUEUE_TYPE      reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING_TYPE     reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    ENUM_TYPE       reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VAR             reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LIST_TYPE       reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MAP_TYPE        reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SET_TYPE        reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VOID            reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RBRACE          reduce using rule 74 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 216

    (78) concate -> LPAREN concate PLUS concate RPAREN .

    PLUS            reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    $end            reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    SEMICOLON       reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    RPAREN          reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    LINE_BREAK      reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    PRINT           reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    IF              reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    WHILE           reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    FOR             reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    IDENTIFIER      reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    FINAL           reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    CONST           reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    INTEGER_TYPE    reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    DOUBLE_TYPE     reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    BOOLEAN_TYPE    reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    QUEUE_TYPE      reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    STRING_TYPE     reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    ENUM_TYPE       reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    VAR             reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    LIST_TYPE       reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    MAP_TYPE        reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    SET_TYPE        reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    DYNAMIC_TYPE    reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    VOID            reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)
    RBRACE          reduce using rule 78 (concate -> LPAREN concate PLUS concate RPAREN .)


state 217

    (85) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    LINE_BREAK      reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    PRINT           reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    IF              reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    WHILE           reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    FOR             reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    IDENTIFIER      reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    FINAL           reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    CONST           reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER_TYPE    reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE_TYPE     reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    QUEUE_TYPE      reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING_TYPE     reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    ENUM_TYPE       reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    VAR             reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    LIST_TYPE       reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    MAP_TYPE        reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    SET_TYPE        reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    VOID            reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)
    RBRACE          reduce using rule 85 (logic -> LPAREN logic logic_op logic RPAREN .)


state 218

    (82) comparison -> LPAREN comparison comp_op number comparison .
    (81) comparison -> comparison . comp_op comparison
    (92) comp_op -> . EQUAL
    (93) comp_op -> . NOT_EQUAL
    (94) comp_op -> . LESS
    (95) comp_op -> . LESS_EQUAL
    (96) comp_op -> . GREATER
    (97) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    LOGICAL_OR      reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    $end            reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    SEMICOLON       reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    RPAREN          reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    LINE_BREAK      reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    PRINT           reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    IF              reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    WHILE           reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    FOR             reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    IDENTIFIER      reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    FINAL           reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    CONST           reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    INTEGER_TYPE    reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    DOUBLE_TYPE     reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    BOOLEAN_TYPE    reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    QUEUE_TYPE      reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    STRING_TYPE     reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    ENUM_TYPE       reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    VAR             reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    LIST_TYPE       reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    MAP_TYPE        reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    SET_TYPE        reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    DYNAMIC_TYPE    reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    VOID            reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    RBRACE          reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .)
    EQUAL           shift and go to state 101
    NOT_EQUAL       shift and go to state 102
    LESS            shift and go to state 103
    LESS_EQUAL      shift and go to state 104
    GREATER         shift and go to state 105
    GREATER_EQUAL   shift and go to state 106

  ! EQUAL           [ reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! LESS            [ reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! GREATER         [ reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 82 (comparison -> LPAREN comparison comp_op number comparison .) ]

    comp_op                        shift and go to state 100

state 219

    (48) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    LINE_BREAK      shift and go to state 28
    RBRACE          reduce using rule 116 (lines -> .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    lines                          shift and go to state 239
    line                           shift and go to state 27
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 220

    (140) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    LINE_BREAK      shift and go to state 28
    RBRACE          reduce using rule 116 (lines -> .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    lines                          shift and go to state 240
    line                           shift and go to state 27
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 221

    (141) for_statement -> FOR LPAREN assignment SEMICOLON logic . SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (84) logic -> logic . logic_op logic
    (87) logic_op -> . LOGICAL_AND
    (88) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 241
    LOGICAL_AND     shift and go to state 76
    LOGICAL_OR      shift and go to state 77

    logic_op                       shift and go to state 75

state 222

    (20) int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 242


state 223

    (22) int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

    SEMICOLON       shift and go to state 243
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 224

    (24) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 24 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 225

    (27) string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 244


state 226

    (29) string_assignment -> string_type nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (77) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 245
    PLUS            shift and go to state 74


state 227

    (31) string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 31 (string_assignment -> string_type IDENTIFIER ASSIGN concate SEMICOLON .)


state 228

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 246


state 229

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 230

    (19) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 247


state 231

    (21) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (73) arithmetic -> arithmetic . arith_op arithmetic
    (89) arith_op -> . PLUS
    (90) arith_op -> . MINUS
    (91) arith_op -> . TIMES

    SEMICOLON       shift and go to state 248
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72
    TIMES           shift and go to state 73

    arith_op                       shift and go to state 70

state 232

    (23) int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 23 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 233

    (26) string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 249


state 234

    (28) string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (77) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 250
    PLUS            shift and go to state 74


state 235

    (30) string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 30 (string_assignment -> modifier string_type IDENTIFIER ASSIGN concate SEMICOLON .)


state 236

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 237

    (111) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    LINE_BREAK      shift and go to state 28
    RBRACE          reduce using rule 116 (lines -> .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    type                           shift and go to state 18
    lines                          shift and go to state 251
    line                           shift and go to state 27
    print                          shift and go to state 61
    assignment                     shift and go to state 62
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    reassignment                   shift and go to state 68
    modifier                       shift and go to state 17
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 238

    (127) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 127 (parameters -> parameter COMMA parameters .)


state 239

    (48) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 252


state 240

    (140) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 253


state 241

    (141) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON . reassignment RPAREN LBRACE lines RBRACE
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH

    IDENTIFIER      shift and go to state 255

    reassignment                   shift and go to state 254

state 242

    (20) int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 20 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 243

    (22) int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 22 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 244

    (27) string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 27 (string_assignment -> string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 245

    (29) string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 29 (string_assignment -> string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 246

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 247

    (19) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 19 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 248

    (21) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 21 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 249

    (26) string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 26 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 250

    (28) string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 28 (string_assignment -> modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 251

    (111) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 256


state 252

    (48) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 48 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 253

    (140) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 140 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 254

    (141) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 257


state 255

    (38) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (39) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (40) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number
    (42) reassignment -> IDENTIFIER . INLINE_ARITH

    ASSIGN          shift and go to state 84
    INLINE_ARITH    shift and go to state 85


state 256

    (111) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 111 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 257

    (141) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 258


state 258

    (141) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE . lines RBRACE
    (112) lines -> . line LINE_BREAK lines
    (113) lines -> . line lines
    (114) lines -> . line
    (115) lines -> . LINE_BREAK
    (116) lines -> .
    (117) line -> . print
    (118) line -> . assignment
    (119) line -> . function
    (120) line -> . if_statement
    (121) line -> . while_statement
    (122) line -> . for_statement
    (123) line -> . function_call
    (124) line -> . reassignment
    (46) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (47) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (111) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (48) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (49) if_statement -> . if_statement ELSE if_statement
    (50) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (140) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (141) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (51) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (52) function_call -> . IDENTIFIER LPAREN values RPAREN
    (53) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN RPAREN
    (38) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (39) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (40) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number
    (42) reassignment -> . IDENTIFIER INLINE_ARITH
    (44) modifier -> . FINAL
    (45) modifier -> . CONST
    (55) type -> . INTEGER_TYPE
    (56) type -> . DOUBLE_TYPE
    (57) type -> . BOOLEAN_TYPE
    (58) type -> . QUEUE_TYPE
    (59) type -> . STRING_TYPE
    (60) type -> . ENUM_TYPE
    (61) type -> . VAR
    (62) type -> . LIST_TYPE
    (63) type -> . MAP_TYPE
    (64) type -> . SET_TYPE
    (65) type -> . DYNAMIC_TYPE
    (66) type -> . VOID
    (19) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (20) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (21) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (23) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (24) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (25) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (26) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (27) string_assignment -> . string_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (28) string_assignment -> . modifier string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . string_type nullable IDENTIFIER ASSIGN concate SEMICOLON
    (30) string_assignment -> . modifier string_type IDENTIFIER ASSIGN concate SEMICOLON
    (31) string_assignment -> . string_type IDENTIFIER ASSIGN concate SEMICOLON
    (32) string_assignment -> . string_type IDENTIFIER ASSIGN concate
    (33) number_type -> . INTEGER_TYPE
    (34) number_type -> . VAR
    (35) number_type -> . DOUBLE_TYPE
    (36) string_type -> . STRING_TYPE
    (37) string_type -> . VAR

    LINE_BREAK      shift and go to state 28
    RBRACE          reduce using rule 116 (lines -> .)
    PRINT           shift and go to state 22
    IF              shift and go to state 24
    WHILE           shift and go to state 25
    FOR             shift and go to state 26
    IDENTIFIER      shift and go to state 69
    FINAL           shift and go to state 34
    CONST           shift and go to state 35
    INTEGER_TYPE    shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOLEAN_TYPE    shift and go to state 38
    QUEUE_TYPE      shift and go to state 39
    STRING_TYPE     shift and go to state 40
    ENUM_TYPE       shift and go to state 41
    VAR             shift and go to state 42
    LIST_TYPE       shift and go to state 43
    MAP_TYPE        shift and go to state 44
    SET_TYPE        shift and go to state 45
    DYNAMIC_TYPE    shift and go to state 46
    VOID            shift and go to state 47

    assignment                     shift and go to state 62
    reassignment                   shift and go to state 68
    lines                          shift and go to state 259
    line                           shift and go to state 27
    print                          shift and go to state 61
    function                       shift and go to state 63
    if_statement                   shift and go to state 64
    while_statement                shift and go to state 65
    for_statement                  shift and go to state 66
    function_call                  shift and go to state 67
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    number_type                    shift and go to state 48
    string_type                    shift and go to state 49

state 259

    (141) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 260


state 260

    (141) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 141 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 107 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 107 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 124 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 127 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 127 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 143 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 156 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 156 resolved as shift
WARNING: shift/reduce conflict for LESS in state 156 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 156 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 156 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 156 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 172 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 184 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 188 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 188 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 188 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 189 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 190 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 190 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 198 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 200 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 218 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 218 resolved as shift
WARNING: shift/reduce conflict for LESS in state 218 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 218 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 218 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 218 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (statement -> while_statement)
WARNING: rejected rule (line -> while_statement) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (statement -> for_statement)
WARNING: rejected rule (line -> for_statement) in state 8
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> reassignment)
WARNING: rejected rule (line -> reassignment) in state 11
WARNING: reduce/reduce conflict in state 15 resolved using rule (expression -> function_call)
WARNING: rejected rule (line -> function_call) in state 15
WARNING: reduce/reduce conflict in state 27 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 27
WARNING: reduce/reduce conflict in state 29 resolved using rule (arithmetic -> number)
WARNING: rejected rule (value -> number) in state 29
WARNING: reduce/reduce conflict in state 30 resolved using rule (concate -> string)
WARNING: rejected rule (value -> string) in state 30
WARNING: reduce/reduce conflict in state 36 resolved using rule (number_type -> INTEGER_TYPE)
WARNING: rejected rule (type -> INTEGER_TYPE) in state 36
WARNING: reduce/reduce conflict in state 37 resolved using rule (number_type -> DOUBLE_TYPE)
WARNING: rejected rule (type -> DOUBLE_TYPE) in state 37
WARNING: reduce/reduce conflict in state 40 resolved using rule (string_type -> STRING_TYPE)
WARNING: rejected rule (type -> STRING_TYPE) in state 40
WARNING: reduce/reduce conflict in state 42 resolved using rule (number_type -> VAR)
WARNING: rejected rule (type -> VAR) in state 42
WARNING: reduce/reduce conflict in state 42 resolved using rule (number_type -> VAR)
WARNING: rejected rule (string_type -> VAR) in state 42
WARNING: reduce/reduce conflict in state 97 resolved using rule (lines -> LINE_BREAK)
WARNING: rejected rule (lines -> <empty>) in state 97
WARNING: Rule (string_type -> VAR) is never reduced
