Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONTINUE
    DEFAULT
    DEFERRED
    DO
    DOT
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FINALLY
    FOR
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    IN
    INTERFACE
    IS
    KEYWORD
    LIBRARY
    NULL
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WHILE
    WITH
    YIELD

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> lines
Rule 7     statement -> <empty>
Rule 8     assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 9     assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 10    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 11    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 12    nullable -> QUESTION_MARK
Rule 13    modifier -> LATE
Rule 14    modifier -> FINAL
Rule 15    modifier -> CONST
Rule 16    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 17    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 18    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 19    if_statement -> if_statement ELSE if_statement
Rule 20    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 21    function_call -> IDENTIFIER LPAREN parameters RPAREN
Rule 22    type -> INTEGER_TYPE
Rule 23    type -> DOUBLE_TYPE
Rule 24    type -> BOOLEAN_TYPE
Rule 25    type -> QUEUE_TYPE
Rule 26    type -> STRING_TYPE
Rule 27    type -> ENUM_TYPE
Rule 28    type -> VAR
Rule 29    type -> LIST_TYPE
Rule 30    type -> MAP_TYPE
Rule 31    type -> SET_TYPE
Rule 32    type -> DYNAMIC_TYPE
Rule 33    expression -> arithmetic
Rule 34    expression -> logic
Rule 35    expression -> function_call
Rule 36    arithmetic -> value
Rule 37    arithmetic -> arithmetic arith_op arithmetic
Rule 38    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 39    comparison -> value
Rule 40    comparison -> boolean
Rule 41    comparison -> comparison comp_op comparison
Rule 42    comparison -> LPAREN comparison comp_op comparison RPAREN
Rule 43    logic -> comparison
Rule 44    logic -> logic logic_op logic
Rule 45    logic -> LPAREN logic logic_op logic RPAREN
Rule 46    logic -> LOGICAL_NOT logic
Rule 47    logic_op -> LOGICAL_AND
Rule 48    logic_op -> LOGICAL_OR
Rule 49    arith_op -> PLUS
Rule 50    arith_op -> MINUS
Rule 51    arith_op -> TIMES
Rule 52    arith_op -> DIVIDE
Rule 53    comp_op -> EQUAL
Rule 54    comp_op -> NOT_EQUAL
Rule 55    comp_op -> LESS
Rule 56    comp_op -> LESS_EQUAL
Rule 57    comp_op -> GREATER
Rule 58    comp_op -> GREATER_EQUAL
Rule 59    values -> value
Rule 60    values -> value COMMA values
Rule 61    value -> IDENTIFIER
Rule 62    value -> number
Rule 63    value -> string
Rule 64    value -> list
Rule 65    number -> INTEGER
Rule 66    number -> DOUBLE
Rule 67    string -> STRING
Rule 68    boolean -> TRUE
Rule 69    boolean -> FALSE
Rule 70    list -> LSQUARE RSQUARE
Rule 71    list -> LSQUARE values RSQUARE
Rule 72    function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 73    lines -> line LINE_BREAK lines
Rule 74    lines -> line lines
Rule 75    lines -> line
Rule 76    lines -> <empty>
Rule 77    line -> print
Rule 78    line -> assignment
Rule 79    line -> function
Rule 80    line -> if_statement
Rule 81    parameters -> VOID
Rule 82    parameters -> parameter
Rule 83    parameters -> parameter COMMA parameters
Rule 84    parameters -> <empty>
Rule 85    parameter -> type IDENTIFIER

Terminals, with rules where they appear

ABSTRACT             : 
AS                   : 
ASSERT               : 
ASSIGN               : 8 9 10 11
ASYNC                : 
AWAIT                : 
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 24
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 
COMMA                : 60 83
COMMENT              : 
CONST                : 15
CONTINUE             : 
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 52
DO                   : 
DOT                  : 
DOUBLE               : 66
DOUBLE_TYPE          : 23
DYNAMIC_TYPE         : 32
ELSE                 : 19 20
ENUM                 : 
ENUM_TYPE            : 27
EQUAL                : 53
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FALSE                : 69
FINAL                : 14
FINALLY              : 
FOR                  : 
GET                  : 
GREATER              : 57
GREATER_EQUAL        : 58
HIDE                 : 
IDENTIFIER           : 8 9 10 11 21 61 72 85
IF                   : 18
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INTEGER              : 65
INTEGER_TYPE         : 22
INTERFACE            : 
IS                   : 
KEYWORD              : 
LATE                 : 13
LBRACE               : 18 20 72
LESS                 : 55
LESS_EQUAL           : 56
LIBRARY              : 
LINE_BREAK           : 73
LIST_TYPE            : 29
LOGICAL_AND          : 47
LOGICAL_NOT          : 46
LOGICAL_OR           : 48
LPAREN               : 16 17 18 21 38 42 45 72
LSQUARE              : 70 71
MAP_TYPE             : 30
MINUS                : 50
NOT_EQUAL            : 54
NULL                 : 
ON                   : 
OPERATOR             : 
PART                 : 
PLUS                 : 49
PRINT                : 16 17
QUESTION_MARK        : 12
QUEUE_TYPE           : 25
RBRACE               : 18 20 72
RETHROW              : 
RETURN               : 
RPAREN               : 16 17 18 21 38 42 45 72
RSQUARE              : 70 71
SEMICOLON            : 8 9 10 11 16 17
SET                  : 
SET_TYPE             : 31
SHOW                 : 
STATIC               : 
STRING               : 67
STRING_TYPE          : 26
SUPER                : 
SWITCH               : 
SYNC                 : 
THROW                : 
TIMES                : 51
TRUE                 : 68
TRY                  : 
TYPEDEF              : 
VAR                  : 28
VOID                 : 81
WHILE                : 
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 37 38
arithmetic           : 33 37 37 38 38
assignment           : 2 78
boolean              : 40
comp_op              : 41 42
comparison           : 41 41 42 42 43
expression           : 1 8 9 10 11 16
function             : 4 79
function_call        : 35
if_statement         : 5 19 19 20 80
line                 : 73 74 75
lines                : 6 18 20 72 73 74
list                 : 64
logic                : 18 34 44 44 45 45 46
logic_op             : 44 45
modifier             : 8 10
nullable             : 8 9
number               : 62
parameter            : 82 83
parameters           : 21 72 83
print                : 3 77
statement            : 0
string               : 63
type                 : 8 9 10 11 72 85
value                : 36 39 59 60
values               : 60 71

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . lines
    (7) statement -> .
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (73) lines -> . line LINE_BREAK lines
    (74) lines -> . line lines
    (75) lines -> . line
    (76) lines -> .
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE
    (77) line -> . print
    (78) line -> . assignment
    (79) line -> . function
    (80) line -> . if_statement
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> .)
    $end            reduce using rule 7 (statement -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

  ! $end            [ reduce using rule 76 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    lines                          shift and go to state 7
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    modifier                       shift and go to state 11
    type                           shift and go to state 12
    line                           shift and go to state 17
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (78) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 78 (line -> assignment .)
    PRINT           reduce using rule 78 (line -> assignment .)
    IF              reduce using rule 78 (line -> assignment .)
    LATE            reduce using rule 78 (line -> assignment .)
    FINAL           reduce using rule 78 (line -> assignment .)
    CONST           reduce using rule 78 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 78 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 78 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 78 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 78 (line -> assignment .)
    STRING_TYPE     reduce using rule 78 (line -> assignment .)
    ENUM_TYPE       reduce using rule 78 (line -> assignment .)
    VAR             reduce using rule 78 (line -> assignment .)
    LIST_TYPE       reduce using rule 78 (line -> assignment .)
    MAP_TYPE        reduce using rule 78 (line -> assignment .)
    SET_TYPE        reduce using rule 78 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 78 (line -> assignment .)

  ! $end            [ reduce using rule 78 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (77) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 77 (line -> print .)
    PRINT           reduce using rule 77 (line -> print .)
    IF              reduce using rule 77 (line -> print .)
    LATE            reduce using rule 77 (line -> print .)
    FINAL           reduce using rule 77 (line -> print .)
    CONST           reduce using rule 77 (line -> print .)
    INTEGER_TYPE    reduce using rule 77 (line -> print .)
    DOUBLE_TYPE     reduce using rule 77 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 77 (line -> print .)
    QUEUE_TYPE      reduce using rule 77 (line -> print .)
    STRING_TYPE     reduce using rule 77 (line -> print .)
    ENUM_TYPE       reduce using rule 77 (line -> print .)
    VAR             reduce using rule 77 (line -> print .)
    LIST_TYPE       reduce using rule 77 (line -> print .)
    MAP_TYPE        reduce using rule 77 (line -> print .)
    SET_TYPE        reduce using rule 77 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 77 (line -> print .)

  ! $end            [ reduce using rule 77 (line -> print .) ]


state 5

    (4) statement -> function .
    (79) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 79 (line -> function .)
    PRINT           reduce using rule 79 (line -> function .)
    IF              reduce using rule 79 (line -> function .)
    LATE            reduce using rule 79 (line -> function .)
    FINAL           reduce using rule 79 (line -> function .)
    CONST           reduce using rule 79 (line -> function .)
    INTEGER_TYPE    reduce using rule 79 (line -> function .)
    DOUBLE_TYPE     reduce using rule 79 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 79 (line -> function .)
    QUEUE_TYPE      reduce using rule 79 (line -> function .)
    STRING_TYPE     reduce using rule 79 (line -> function .)
    ENUM_TYPE       reduce using rule 79 (line -> function .)
    VAR             reduce using rule 79 (line -> function .)
    LIST_TYPE       reduce using rule 79 (line -> function .)
    MAP_TYPE        reduce using rule 79 (line -> function .)
    SET_TYPE        reduce using rule 79 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 79 (line -> function .)

  ! $end            [ reduce using rule 79 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (80) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 45
    LINE_BREAK      reduce using rule 80 (line -> if_statement .)
    PRINT           reduce using rule 80 (line -> if_statement .)
    IF              reduce using rule 80 (line -> if_statement .)
    LATE            reduce using rule 80 (line -> if_statement .)
    FINAL           reduce using rule 80 (line -> if_statement .)
    CONST           reduce using rule 80 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 80 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 80 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 80 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 80 (line -> if_statement .)
    STRING_TYPE     reduce using rule 80 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 80 (line -> if_statement .)
    VAR             reduce using rule 80 (line -> if_statement .)
    LIST_TYPE       reduce using rule 80 (line -> if_statement .)
    MAP_TYPE        reduce using rule 80 (line -> if_statement .)
    SET_TYPE        reduce using rule 80 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 80 (line -> if_statement .)

  ! $end            [ reduce using rule 80 (line -> if_statement .) ]


state 7

    (6) statement -> lines .

    $end            reduce using rule 6 (statement -> lines .)


state 8

    (33) expression -> arithmetic .
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

    $end            reduce using rule 33 (expression -> arithmetic .)
    RPAREN          reduce using rule 33 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 33 (expression -> arithmetic .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

    arith_op                       shift and go to state 46

state 9

    (34) expression -> logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

    $end            reduce using rule 34 (expression -> logic .)
    RPAREN          reduce using rule 34 (expression -> logic .)
    SEMICOLON       reduce using rule 34 (expression -> logic .)
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

    logic_op                       shift and go to state 51

state 10

    (35) expression -> function_call .

    $end            reduce using rule 35 (expression -> function_call .)
    RPAREN          reduce using rule 35 (expression -> function_call .)
    SEMICOLON       reduce using rule 35 (expression -> function_call .)


state 11

    (8) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    type                           shift and go to state 54

state 12

    (9) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (12) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 56
    QUESTION_MARK   shift and go to state 57

    nullable                       shift and go to state 55

state 13

    (21) function_call -> IDENTIFIER . LPAREN parameters RPAREN
    (61) value -> IDENTIFIER .

    LPAREN          shift and go to state 58
    PLUS            reduce using rule 61 (value -> IDENTIFIER .)
    MINUS           reduce using rule 61 (value -> IDENTIFIER .)
    TIMES           reduce using rule 61 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (value -> IDENTIFIER .)
    $end            reduce using rule 61 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 61 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 61 (value -> IDENTIFIER .)
    LESS            reduce using rule 61 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 61 (value -> IDENTIFIER .)
    GREATER         reduce using rule 61 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 61 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (value -> IDENTIFIER .)


state 14

    (16) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (17) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 59


state 15

    (38) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (45) logic -> LPAREN . logic logic_op logic RPAREN
    (42) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 60
    logic                          shift and go to state 61
    comparison                     shift and go to state 62
    value                          shift and go to state 18
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 16

    (18) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 64


state 17

    (73) lines -> line . LINE_BREAK lines
    (74) lines -> line . lines
    (75) lines -> line .
    (73) lines -> . line LINE_BREAK lines
    (74) lines -> . line lines
    (75) lines -> . line
    (76) lines -> .
    (77) line -> . print
    (78) line -> . assignment
    (79) line -> . function
    (80) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

  ! reduce/reduce conflict for $end resolved using rule 75 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 75 (lines -> line .)
    LINE_BREAK      shift and go to state 65
    $end            reduce using rule 75 (lines -> line .)
    RBRACE          reduce using rule 75 (lines -> line .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

  ! $end            [ reduce using rule 76 (lines -> .) ]
  ! RBRACE          [ reduce using rule 76 (lines -> .) ]

    line                           shift and go to state 17
    lines                          shift and go to state 66
    print                          shift and go to state 67
    assignment                     shift and go to state 68
    function                       shift and go to state 69
    if_statement                   shift and go to state 70
    modifier                       shift and go to state 11
    type                           shift and go to state 12

state 18

    (36) arithmetic -> value .
    (39) comparison -> value .

  ! reduce/reduce conflict for $end resolved using rule 36 (arithmetic -> value .)
  ! reduce/reduce conflict for RPAREN resolved using rule 36 (arithmetic -> value .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (arithmetic -> value .)
    PLUS            reduce using rule 36 (arithmetic -> value .)
    MINUS           reduce using rule 36 (arithmetic -> value .)
    TIMES           reduce using rule 36 (arithmetic -> value .)
    DIVIDE          reduce using rule 36 (arithmetic -> value .)
    $end            reduce using rule 36 (arithmetic -> value .)
    RPAREN          reduce using rule 36 (arithmetic -> value .)
    SEMICOLON       reduce using rule 36 (arithmetic -> value .)
    EQUAL           reduce using rule 39 (comparison -> value .)
    NOT_EQUAL       reduce using rule 39 (comparison -> value .)
    LESS            reduce using rule 39 (comparison -> value .)
    LESS_EQUAL      reduce using rule 39 (comparison -> value .)
    GREATER         reduce using rule 39 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 39 (comparison -> value .)
    LOGICAL_AND     reduce using rule 39 (comparison -> value .)
    LOGICAL_OR      reduce using rule 39 (comparison -> value .)

  ! $end            [ reduce using rule 39 (comparison -> value .) ]
  ! RPAREN          [ reduce using rule 39 (comparison -> value .) ]
  ! SEMICOLON       [ reduce using rule 39 (comparison -> value .) ]


state 19

    (43) logic -> comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 43 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 43 (logic -> comparison .)
    $end            reduce using rule 43 (logic -> comparison .)
    RPAREN          reduce using rule 43 (logic -> comparison .)
    SEMICOLON       reduce using rule 43 (logic -> comparison .)
    EQUAL           shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

    comp_op                        shift and go to state 71

state 20

    (46) logic -> LOGICAL_NOT . logic
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 79
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 78
    comparison                     shift and go to state 19
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 21

    (13) modifier -> LATE .

    INTEGER_TYPE    reduce using rule 13 (modifier -> LATE .)
    DOUBLE_TYPE     reduce using rule 13 (modifier -> LATE .)
    BOOLEAN_TYPE    reduce using rule 13 (modifier -> LATE .)
    QUEUE_TYPE      reduce using rule 13 (modifier -> LATE .)
    STRING_TYPE     reduce using rule 13 (modifier -> LATE .)
    ENUM_TYPE       reduce using rule 13 (modifier -> LATE .)
    VAR             reduce using rule 13 (modifier -> LATE .)
    LIST_TYPE       reduce using rule 13 (modifier -> LATE .)
    MAP_TYPE        reduce using rule 13 (modifier -> LATE .)
    SET_TYPE        reduce using rule 13 (modifier -> LATE .)
    DYNAMIC_TYPE    reduce using rule 13 (modifier -> LATE .)


state 22

    (14) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 14 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 14 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 14 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 14 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 14 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 14 (modifier -> FINAL .)
    VAR             reduce using rule 14 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 14 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 14 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 14 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 14 (modifier -> FINAL .)


state 23

    (15) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 15 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 15 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 15 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 15 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 15 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 15 (modifier -> CONST .)
    VAR             reduce using rule 15 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 15 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 15 (modifier -> CONST .)
    SET_TYPE        reduce using rule 15 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 15 (modifier -> CONST .)


state 24

    (22) type -> INTEGER_TYPE .

    IDENTIFIER      reduce using rule 22 (type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 22 (type -> INTEGER_TYPE .)


state 25

    (23) type -> DOUBLE_TYPE .

    IDENTIFIER      reduce using rule 23 (type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 23 (type -> DOUBLE_TYPE .)


state 26

    (24) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 24 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 24 (type -> BOOLEAN_TYPE .)


state 27

    (25) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 25 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 25 (type -> QUEUE_TYPE .)


state 28

    (26) type -> STRING_TYPE .

    IDENTIFIER      reduce using rule 26 (type -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 26 (type -> STRING_TYPE .)


state 29

    (27) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 27 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 27 (type -> ENUM_TYPE .)


state 30

    (28) type -> VAR .

    IDENTIFIER      reduce using rule 28 (type -> VAR .)
    QUESTION_MARK   reduce using rule 28 (type -> VAR .)


state 31

    (29) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 29 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 29 (type -> LIST_TYPE .)


state 32

    (30) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 30 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 30 (type -> MAP_TYPE .)


state 33

    (31) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 31 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 31 (type -> SET_TYPE .)


state 34

    (32) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 32 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 32 (type -> DYNAMIC_TYPE .)


state 35

    (62) value -> number .

    PLUS            reduce using rule 62 (value -> number .)
    MINUS           reduce using rule 62 (value -> number .)
    TIMES           reduce using rule 62 (value -> number .)
    DIVIDE          reduce using rule 62 (value -> number .)
    $end            reduce using rule 62 (value -> number .)
    EQUAL           reduce using rule 62 (value -> number .)
    NOT_EQUAL       reduce using rule 62 (value -> number .)
    LESS            reduce using rule 62 (value -> number .)
    LESS_EQUAL      reduce using rule 62 (value -> number .)
    GREATER         reduce using rule 62 (value -> number .)
    GREATER_EQUAL   reduce using rule 62 (value -> number .)
    LOGICAL_AND     reduce using rule 62 (value -> number .)
    LOGICAL_OR      reduce using rule 62 (value -> number .)
    RPAREN          reduce using rule 62 (value -> number .)
    SEMICOLON       reduce using rule 62 (value -> number .)
    COMMA           reduce using rule 62 (value -> number .)
    RSQUARE         reduce using rule 62 (value -> number .)


state 36

    (63) value -> string .

    PLUS            reduce using rule 63 (value -> string .)
    MINUS           reduce using rule 63 (value -> string .)
    TIMES           reduce using rule 63 (value -> string .)
    DIVIDE          reduce using rule 63 (value -> string .)
    $end            reduce using rule 63 (value -> string .)
    EQUAL           reduce using rule 63 (value -> string .)
    NOT_EQUAL       reduce using rule 63 (value -> string .)
    LESS            reduce using rule 63 (value -> string .)
    LESS_EQUAL      reduce using rule 63 (value -> string .)
    GREATER         reduce using rule 63 (value -> string .)
    GREATER_EQUAL   reduce using rule 63 (value -> string .)
    LOGICAL_AND     reduce using rule 63 (value -> string .)
    LOGICAL_OR      reduce using rule 63 (value -> string .)
    RPAREN          reduce using rule 63 (value -> string .)
    SEMICOLON       reduce using rule 63 (value -> string .)
    COMMA           reduce using rule 63 (value -> string .)
    RSQUARE         reduce using rule 63 (value -> string .)


state 37

    (64) value -> list .

    PLUS            reduce using rule 64 (value -> list .)
    MINUS           reduce using rule 64 (value -> list .)
    TIMES           reduce using rule 64 (value -> list .)
    DIVIDE          reduce using rule 64 (value -> list .)
    $end            reduce using rule 64 (value -> list .)
    EQUAL           reduce using rule 64 (value -> list .)
    NOT_EQUAL       reduce using rule 64 (value -> list .)
    LESS            reduce using rule 64 (value -> list .)
    LESS_EQUAL      reduce using rule 64 (value -> list .)
    GREATER         reduce using rule 64 (value -> list .)
    GREATER_EQUAL   reduce using rule 64 (value -> list .)
    LOGICAL_AND     reduce using rule 64 (value -> list .)
    LOGICAL_OR      reduce using rule 64 (value -> list .)
    RPAREN          reduce using rule 64 (value -> list .)
    SEMICOLON       reduce using rule 64 (value -> list .)
    COMMA           reduce using rule 64 (value -> list .)
    RSQUARE         reduce using rule 64 (value -> list .)


state 38

    (40) comparison -> boolean .

    EQUAL           reduce using rule 40 (comparison -> boolean .)
    NOT_EQUAL       reduce using rule 40 (comparison -> boolean .)
    LESS            reduce using rule 40 (comparison -> boolean .)
    LESS_EQUAL      reduce using rule 40 (comparison -> boolean .)
    GREATER         reduce using rule 40 (comparison -> boolean .)
    GREATER_EQUAL   reduce using rule 40 (comparison -> boolean .)
    LOGICAL_AND     reduce using rule 40 (comparison -> boolean .)
    LOGICAL_OR      reduce using rule 40 (comparison -> boolean .)
    $end            reduce using rule 40 (comparison -> boolean .)
    RPAREN          reduce using rule 40 (comparison -> boolean .)
    SEMICOLON       reduce using rule 40 (comparison -> boolean .)


state 39

    (65) number -> INTEGER .

    PLUS            reduce using rule 65 (number -> INTEGER .)
    MINUS           reduce using rule 65 (number -> INTEGER .)
    TIMES           reduce using rule 65 (number -> INTEGER .)
    DIVIDE          reduce using rule 65 (number -> INTEGER .)
    $end            reduce using rule 65 (number -> INTEGER .)
    EQUAL           reduce using rule 65 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 65 (number -> INTEGER .)
    LESS            reduce using rule 65 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 65 (number -> INTEGER .)
    GREATER         reduce using rule 65 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 65 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 65 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 65 (number -> INTEGER .)
    RPAREN          reduce using rule 65 (number -> INTEGER .)
    SEMICOLON       reduce using rule 65 (number -> INTEGER .)
    COMMA           reduce using rule 65 (number -> INTEGER .)
    RSQUARE         reduce using rule 65 (number -> INTEGER .)


state 40

    (66) number -> DOUBLE .

    PLUS            reduce using rule 66 (number -> DOUBLE .)
    MINUS           reduce using rule 66 (number -> DOUBLE .)
    TIMES           reduce using rule 66 (number -> DOUBLE .)
    DIVIDE          reduce using rule 66 (number -> DOUBLE .)
    $end            reduce using rule 66 (number -> DOUBLE .)
    EQUAL           reduce using rule 66 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 66 (number -> DOUBLE .)
    LESS            reduce using rule 66 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 66 (number -> DOUBLE .)
    GREATER         reduce using rule 66 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 66 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 66 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 66 (number -> DOUBLE .)
    RPAREN          reduce using rule 66 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 66 (number -> DOUBLE .)
    COMMA           reduce using rule 66 (number -> DOUBLE .)
    RSQUARE         reduce using rule 66 (number -> DOUBLE .)


state 41

    (67) string -> STRING .

    PLUS            reduce using rule 67 (string -> STRING .)
    MINUS           reduce using rule 67 (string -> STRING .)
    TIMES           reduce using rule 67 (string -> STRING .)
    DIVIDE          reduce using rule 67 (string -> STRING .)
    $end            reduce using rule 67 (string -> STRING .)
    EQUAL           reduce using rule 67 (string -> STRING .)
    NOT_EQUAL       reduce using rule 67 (string -> STRING .)
    LESS            reduce using rule 67 (string -> STRING .)
    LESS_EQUAL      reduce using rule 67 (string -> STRING .)
    GREATER         reduce using rule 67 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 67 (string -> STRING .)
    LOGICAL_AND     reduce using rule 67 (string -> STRING .)
    LOGICAL_OR      reduce using rule 67 (string -> STRING .)
    RPAREN          reduce using rule 67 (string -> STRING .)
    SEMICOLON       reduce using rule 67 (string -> STRING .)
    COMMA           reduce using rule 67 (string -> STRING .)
    RSQUARE         reduce using rule 67 (string -> STRING .)


state 42

    (70) list -> LSQUARE . RSQUARE
    (71) list -> LSQUARE . values RSQUARE
    (59) values -> . value
    (60) values -> . value COMMA values
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 81
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    values                         shift and go to state 82
    value                          shift and go to state 83
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 43

    (68) boolean -> TRUE .

    EQUAL           reduce using rule 68 (boolean -> TRUE .)
    NOT_EQUAL       reduce using rule 68 (boolean -> TRUE .)
    LESS            reduce using rule 68 (boolean -> TRUE .)
    LESS_EQUAL      reduce using rule 68 (boolean -> TRUE .)
    GREATER         reduce using rule 68 (boolean -> TRUE .)
    GREATER_EQUAL   reduce using rule 68 (boolean -> TRUE .)
    LOGICAL_AND     reduce using rule 68 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 68 (boolean -> TRUE .)
    $end            reduce using rule 68 (boolean -> TRUE .)
    RPAREN          reduce using rule 68 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 68 (boolean -> TRUE .)


state 44

    (69) boolean -> FALSE .

    EQUAL           reduce using rule 69 (boolean -> FALSE .)
    NOT_EQUAL       reduce using rule 69 (boolean -> FALSE .)
    LESS            reduce using rule 69 (boolean -> FALSE .)
    LESS_EQUAL      reduce using rule 69 (boolean -> FALSE .)
    GREATER         reduce using rule 69 (boolean -> FALSE .)
    GREATER_EQUAL   reduce using rule 69 (boolean -> FALSE .)
    LOGICAL_AND     reduce using rule 69 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 69 (boolean -> FALSE .)
    $end            reduce using rule 69 (boolean -> FALSE .)
    RPAREN          reduce using rule 69 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 69 (boolean -> FALSE .)


state 45

    (19) if_statement -> if_statement ELSE . if_statement
    (20) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 85
    IF              shift and go to state 16

    if_statement                   shift and go to state 84

state 46

    (37) arithmetic -> arithmetic arith_op . arithmetic
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 86
    value                          shift and go to state 87
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 47

    (49) arith_op -> PLUS .

    LPAREN          reduce using rule 49 (arith_op -> PLUS .)
    IDENTIFIER      reduce using rule 49 (arith_op -> PLUS .)
    INTEGER         reduce using rule 49 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 49 (arith_op -> PLUS .)
    STRING          reduce using rule 49 (arith_op -> PLUS .)
    LSQUARE         reduce using rule 49 (arith_op -> PLUS .)


state 48

    (50) arith_op -> MINUS .

    LPAREN          reduce using rule 50 (arith_op -> MINUS .)
    IDENTIFIER      reduce using rule 50 (arith_op -> MINUS .)
    INTEGER         reduce using rule 50 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 50 (arith_op -> MINUS .)
    STRING          reduce using rule 50 (arith_op -> MINUS .)
    LSQUARE         reduce using rule 50 (arith_op -> MINUS .)


state 49

    (51) arith_op -> TIMES .

    LPAREN          reduce using rule 51 (arith_op -> TIMES .)
    IDENTIFIER      reduce using rule 51 (arith_op -> TIMES .)
    INTEGER         reduce using rule 51 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 51 (arith_op -> TIMES .)
    STRING          reduce using rule 51 (arith_op -> TIMES .)
    LSQUARE         reduce using rule 51 (arith_op -> TIMES .)


state 50

    (52) arith_op -> DIVIDE .

    LPAREN          reduce using rule 52 (arith_op -> DIVIDE .)
    IDENTIFIER      reduce using rule 52 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 52 (arith_op -> DIVIDE .)
    DOUBLE          reduce using rule 52 (arith_op -> DIVIDE .)
    STRING          reduce using rule 52 (arith_op -> DIVIDE .)
    LSQUARE         reduce using rule 52 (arith_op -> DIVIDE .)


state 51

    (44) logic -> logic logic_op . logic
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 79
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 89
    comparison                     shift and go to state 19
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 52

    (47) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 47 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 47 (logic_op -> LOGICAL_AND .)
    IDENTIFIER      reduce using rule 47 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 47 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 47 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 47 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 47 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 47 (logic_op -> LOGICAL_AND .)
    LSQUARE         reduce using rule 47 (logic_op -> LOGICAL_AND .)


state 53

    (48) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 48 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 48 (logic_op -> LOGICAL_OR .)
    IDENTIFIER      reduce using rule 48 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 48 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 48 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 48 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 48 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 48 (logic_op -> LOGICAL_OR .)
    LSQUARE         reduce using rule 48 (logic_op -> LOGICAL_OR .)


state 54

    (8) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (12) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 91
    QUESTION_MARK   shift and go to state 57

    nullable                       shift and go to state 90

state 55

    (9) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 92


state 56

    (11) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (72) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 93
    LPAREN          shift and go to state 94


state 57

    (12) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 12 (nullable -> QUESTION_MARK .)


state 58

    (21) function_call -> IDENTIFIER LPAREN . parameters RPAREN
    (81) parameters -> . VOID
    (82) parameters -> . parameter
    (83) parameters -> . parameter COMMA parameters
    (84) parameters -> .
    (85) parameter -> . type IDENTIFIER
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 96
    RPAREN          reduce using rule 84 (parameters -> .)
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    parameters                     shift and go to state 95
    parameter                      shift and go to state 97
    type                           shift and go to state 98

state 59

    (16) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (17) print -> PRINT LPAREN . RPAREN SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    RPAREN          shift and go to state 100
    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 99
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 60

    (38) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

    arith_op                       shift and go to state 101

state 61

    (45) logic -> LPAREN logic . logic_op logic RPAREN
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

    logic_op                       shift and go to state 102

state 62

    (42) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (43) logic -> comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

    LOGICAL_AND     reduce using rule 43 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 43 (logic -> comparison .)
    EQUAL           shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

    comp_op                        shift and go to state 103

state 63

    (61) value -> IDENTIFIER .

    PLUS            reduce using rule 61 (value -> IDENTIFIER .)
    MINUS           reduce using rule 61 (value -> IDENTIFIER .)
    TIMES           reduce using rule 61 (value -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (value -> IDENTIFIER .)
    EQUAL           reduce using rule 61 (value -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 61 (value -> IDENTIFIER .)
    LESS            reduce using rule 61 (value -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 61 (value -> IDENTIFIER .)
    GREATER         reduce using rule 61 (value -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 61 (value -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 61 (value -> IDENTIFIER .)
    $end            reduce using rule 61 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (value -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (value -> IDENTIFIER .)
    COMMA           reduce using rule 61 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 61 (value -> IDENTIFIER .)


state 64

    (18) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 79
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 104
    comparison                     shift and go to state 19
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 65

    (73) lines -> line LINE_BREAK . lines
    (73) lines -> . line LINE_BREAK lines
    (74) lines -> . line lines
    (75) lines -> . line
    (76) lines -> .
    (77) line -> . print
    (78) line -> . assignment
    (79) line -> . function
    (80) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    $end            reduce using rule 76 (lines -> .)
    RBRACE          reduce using rule 76 (lines -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    line                           shift and go to state 17
    lines                          shift and go to state 105
    print                          shift and go to state 67
    assignment                     shift and go to state 68
    function                       shift and go to state 69
    if_statement                   shift and go to state 70
    modifier                       shift and go to state 11
    type                           shift and go to state 12

state 66

    (74) lines -> line lines .

    $end            reduce using rule 74 (lines -> line lines .)
    RBRACE          reduce using rule 74 (lines -> line lines .)


state 67

    (77) line -> print .

    LINE_BREAK      reduce using rule 77 (line -> print .)
    PRINT           reduce using rule 77 (line -> print .)
    IF              reduce using rule 77 (line -> print .)
    LATE            reduce using rule 77 (line -> print .)
    FINAL           reduce using rule 77 (line -> print .)
    CONST           reduce using rule 77 (line -> print .)
    INTEGER_TYPE    reduce using rule 77 (line -> print .)
    DOUBLE_TYPE     reduce using rule 77 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 77 (line -> print .)
    QUEUE_TYPE      reduce using rule 77 (line -> print .)
    STRING_TYPE     reduce using rule 77 (line -> print .)
    ENUM_TYPE       reduce using rule 77 (line -> print .)
    VAR             reduce using rule 77 (line -> print .)
    LIST_TYPE       reduce using rule 77 (line -> print .)
    MAP_TYPE        reduce using rule 77 (line -> print .)
    SET_TYPE        reduce using rule 77 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 77 (line -> print .)
    $end            reduce using rule 77 (line -> print .)
    RBRACE          reduce using rule 77 (line -> print .)


state 68

    (78) line -> assignment .

    LINE_BREAK      reduce using rule 78 (line -> assignment .)
    PRINT           reduce using rule 78 (line -> assignment .)
    IF              reduce using rule 78 (line -> assignment .)
    LATE            reduce using rule 78 (line -> assignment .)
    FINAL           reduce using rule 78 (line -> assignment .)
    CONST           reduce using rule 78 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 78 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 78 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 78 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 78 (line -> assignment .)
    STRING_TYPE     reduce using rule 78 (line -> assignment .)
    ENUM_TYPE       reduce using rule 78 (line -> assignment .)
    VAR             reduce using rule 78 (line -> assignment .)
    LIST_TYPE       reduce using rule 78 (line -> assignment .)
    MAP_TYPE        reduce using rule 78 (line -> assignment .)
    SET_TYPE        reduce using rule 78 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 78 (line -> assignment .)
    $end            reduce using rule 78 (line -> assignment .)
    RBRACE          reduce using rule 78 (line -> assignment .)


state 69

    (79) line -> function .

    LINE_BREAK      reduce using rule 79 (line -> function .)
    PRINT           reduce using rule 79 (line -> function .)
    IF              reduce using rule 79 (line -> function .)
    LATE            reduce using rule 79 (line -> function .)
    FINAL           reduce using rule 79 (line -> function .)
    CONST           reduce using rule 79 (line -> function .)
    INTEGER_TYPE    reduce using rule 79 (line -> function .)
    DOUBLE_TYPE     reduce using rule 79 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 79 (line -> function .)
    QUEUE_TYPE      reduce using rule 79 (line -> function .)
    STRING_TYPE     reduce using rule 79 (line -> function .)
    ENUM_TYPE       reduce using rule 79 (line -> function .)
    VAR             reduce using rule 79 (line -> function .)
    LIST_TYPE       reduce using rule 79 (line -> function .)
    MAP_TYPE        reduce using rule 79 (line -> function .)
    SET_TYPE        reduce using rule 79 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 79 (line -> function .)
    $end            reduce using rule 79 (line -> function .)
    RBRACE          reduce using rule 79 (line -> function .)


state 70

    (80) line -> if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 80 (line -> if_statement .)
    PRINT           reduce using rule 80 (line -> if_statement .)
    IF              reduce using rule 80 (line -> if_statement .)
    LATE            reduce using rule 80 (line -> if_statement .)
    FINAL           reduce using rule 80 (line -> if_statement .)
    CONST           reduce using rule 80 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 80 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 80 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 80 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 80 (line -> if_statement .)
    STRING_TYPE     reduce using rule 80 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 80 (line -> if_statement .)
    VAR             reduce using rule 80 (line -> if_statement .)
    LIST_TYPE       reduce using rule 80 (line -> if_statement .)
    MAP_TYPE        reduce using rule 80 (line -> if_statement .)
    SET_TYPE        reduce using rule 80 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 80 (line -> if_statement .)
    $end            reduce using rule 80 (line -> if_statement .)
    RBRACE          reduce using rule 80 (line -> if_statement .)
    ELSE            shift and go to state 45


state 71

    (41) comparison -> comparison comp_op . comparison
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    comparison                     shift and go to state 106
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 72

    (53) comp_op -> EQUAL .

    LPAREN          reduce using rule 53 (comp_op -> EQUAL .)
    IDENTIFIER      reduce using rule 53 (comp_op -> EQUAL .)
    TRUE            reduce using rule 53 (comp_op -> EQUAL .)
    FALSE           reduce using rule 53 (comp_op -> EQUAL .)
    INTEGER         reduce using rule 53 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 53 (comp_op -> EQUAL .)
    STRING          reduce using rule 53 (comp_op -> EQUAL .)
    LSQUARE         reduce using rule 53 (comp_op -> EQUAL .)


state 73

    (54) comp_op -> NOT_EQUAL .

    LPAREN          reduce using rule 54 (comp_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 54 (comp_op -> NOT_EQUAL .)
    TRUE            reduce using rule 54 (comp_op -> NOT_EQUAL .)
    FALSE           reduce using rule 54 (comp_op -> NOT_EQUAL .)
    INTEGER         reduce using rule 54 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 54 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 54 (comp_op -> NOT_EQUAL .)
    LSQUARE         reduce using rule 54 (comp_op -> NOT_EQUAL .)


state 74

    (55) comp_op -> LESS .

    LPAREN          reduce using rule 55 (comp_op -> LESS .)
    IDENTIFIER      reduce using rule 55 (comp_op -> LESS .)
    TRUE            reduce using rule 55 (comp_op -> LESS .)
    FALSE           reduce using rule 55 (comp_op -> LESS .)
    INTEGER         reduce using rule 55 (comp_op -> LESS .)
    DOUBLE          reduce using rule 55 (comp_op -> LESS .)
    STRING          reduce using rule 55 (comp_op -> LESS .)
    LSQUARE         reduce using rule 55 (comp_op -> LESS .)


state 75

    (56) comp_op -> LESS_EQUAL .

    LPAREN          reduce using rule 56 (comp_op -> LESS_EQUAL .)
    IDENTIFIER      reduce using rule 56 (comp_op -> LESS_EQUAL .)
    TRUE            reduce using rule 56 (comp_op -> LESS_EQUAL .)
    FALSE           reduce using rule 56 (comp_op -> LESS_EQUAL .)
    INTEGER         reduce using rule 56 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 56 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 56 (comp_op -> LESS_EQUAL .)
    LSQUARE         reduce using rule 56 (comp_op -> LESS_EQUAL .)


state 76

    (57) comp_op -> GREATER .

    LPAREN          reduce using rule 57 (comp_op -> GREATER .)
    IDENTIFIER      reduce using rule 57 (comp_op -> GREATER .)
    TRUE            reduce using rule 57 (comp_op -> GREATER .)
    FALSE           reduce using rule 57 (comp_op -> GREATER .)
    INTEGER         reduce using rule 57 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 57 (comp_op -> GREATER .)
    STRING          reduce using rule 57 (comp_op -> GREATER .)
    LSQUARE         reduce using rule 57 (comp_op -> GREATER .)


state 77

    (58) comp_op -> GREATER_EQUAL .

    LPAREN          reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    IDENTIFIER      reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    TRUE            reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    FALSE           reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    INTEGER         reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 58 (comp_op -> GREATER_EQUAL .)
    LSQUARE         reduce using rule 58 (comp_op -> GREATER_EQUAL .)


state 78

    (46) logic -> LOGICAL_NOT logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 46 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 46 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 46 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

  ! LOGICAL_AND     [ reduce using rule 46 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 46 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 51

state 79

    (45) logic -> LPAREN . logic logic_op logic RPAREN
    (42) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 79
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 61
    comparison                     shift and go to state 62
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 80

    (39) comparison -> value .

    EQUAL           reduce using rule 39 (comparison -> value .)
    NOT_EQUAL       reduce using rule 39 (comparison -> value .)
    LESS            reduce using rule 39 (comparison -> value .)
    LESS_EQUAL      reduce using rule 39 (comparison -> value .)
    GREATER         reduce using rule 39 (comparison -> value .)
    GREATER_EQUAL   reduce using rule 39 (comparison -> value .)
    LOGICAL_AND     reduce using rule 39 (comparison -> value .)
    LOGICAL_OR      reduce using rule 39 (comparison -> value .)
    $end            reduce using rule 39 (comparison -> value .)
    RPAREN          reduce using rule 39 (comparison -> value .)
    SEMICOLON       reduce using rule 39 (comparison -> value .)


state 81

    (70) list -> LSQUARE RSQUARE .

    PLUS            reduce using rule 70 (list -> LSQUARE RSQUARE .)
    MINUS           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    TIMES           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    DIVIDE          reduce using rule 70 (list -> LSQUARE RSQUARE .)
    $end            reduce using rule 70 (list -> LSQUARE RSQUARE .)
    EQUAL           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    NOT_EQUAL       reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LESS            reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LESS_EQUAL      reduce using rule 70 (list -> LSQUARE RSQUARE .)
    GREATER         reduce using rule 70 (list -> LSQUARE RSQUARE .)
    GREATER_EQUAL   reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LOGICAL_AND     reduce using rule 70 (list -> LSQUARE RSQUARE .)
    LOGICAL_OR      reduce using rule 70 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 70 (list -> LSQUARE RSQUARE .)
    SEMICOLON       reduce using rule 70 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 70 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 70 (list -> LSQUARE RSQUARE .)


state 82

    (71) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 108


state 83

    (59) values -> value .
    (60) values -> value . COMMA values

    RSQUARE         reduce using rule 59 (values -> value .)
    COMMA           shift and go to state 109


state 84

    (19) if_statement -> if_statement ELSE if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    LATE            reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 19 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 45

  ! ELSE            [ reduce using rule 19 (if_statement -> if_statement ELSE if_statement .) ]


state 85

    (20) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (73) lines -> . line LINE_BREAK lines
    (74) lines -> . line lines
    (75) lines -> . line
    (76) lines -> .
    (77) line -> . print
    (78) line -> . assignment
    (79) line -> . function
    (80) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    RBRACE          reduce using rule 76 (lines -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    if_statement                   shift and go to state 70
    lines                          shift and go to state 110
    line                           shift and go to state 17
    print                          shift and go to state 67
    assignment                     shift and go to state 68
    function                       shift and go to state 69
    modifier                       shift and go to state 11
    type                           shift and go to state 12

state 86

    (37) arithmetic -> arithmetic arith_op arithmetic .
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    $end            reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

  ! PLUS            [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 46

state 87

    (36) arithmetic -> value .

    PLUS            reduce using rule 36 (arithmetic -> value .)
    MINUS           reduce using rule 36 (arithmetic -> value .)
    TIMES           reduce using rule 36 (arithmetic -> value .)
    DIVIDE          reduce using rule 36 (arithmetic -> value .)
    $end            reduce using rule 36 (arithmetic -> value .)
    RPAREN          reduce using rule 36 (arithmetic -> value .)
    SEMICOLON       reduce using rule 36 (arithmetic -> value .)


state 88

    (38) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 60
    value                          shift and go to state 87
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 89

    (44) logic -> logic logic_op logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 44 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 44 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 44 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

  ! LOGICAL_AND     [ reduce using rule 44 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 44 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 51

state 90

    (8) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 111


state 91

    (10) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 112


state 92

    (9) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 113


state 93

    (11) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 114
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 94

    (72) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (81) parameters -> . VOID
    (82) parameters -> . parameter
    (83) parameters -> . parameter COMMA parameters
    (84) parameters -> .
    (85) parameter -> . type IDENTIFIER
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 96
    RPAREN          reduce using rule 84 (parameters -> .)
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    type                           shift and go to state 98
    parameters                     shift and go to state 115
    parameter                      shift and go to state 97

state 95

    (21) function_call -> IDENTIFIER LPAREN parameters . RPAREN

    RPAREN          shift and go to state 116


state 96

    (81) parameters -> VOID .

    RPAREN          reduce using rule 81 (parameters -> VOID .)


state 97

    (82) parameters -> parameter .
    (83) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 82 (parameters -> parameter .)
    COMMA           shift and go to state 117


state 98

    (85) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 118


state 99

    (16) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 119


state 100

    (17) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 120


state 101

    (38) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (37) arithmetic -> arithmetic arith_op . arithmetic
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 88
    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    arithmetic                     shift and go to state 121
    value                          shift and go to state 87
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 102

    (45) logic -> LPAREN logic logic_op . logic RPAREN
    (44) logic -> logic logic_op . logic
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 79
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    logic                          shift and go to state 122
    comparison                     shift and go to state 19
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 103

    (42) comparison -> LPAREN comparison comp_op . comparison RPAREN
    (41) comparison -> comparison comp_op . comparison
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    comparison                     shift and go to state 123
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 104

    (18) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 124
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

    logic_op                       shift and go to state 51

state 105

    (73) lines -> line LINE_BREAK lines .

    $end            reduce using rule 73 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 73 (lines -> line LINE_BREAK lines .)


state 106

    (41) comparison -> comparison comp_op comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    LOGICAL_AND     reduce using rule 41 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 41 (comparison -> comparison comp_op comparison .)
    $end            reduce using rule 41 (comparison -> comparison comp_op comparison .)
    RPAREN          reduce using rule 41 (comparison -> comparison comp_op comparison .)
    SEMICOLON       reduce using rule 41 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

  ! EQUAL           [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 71

state 107

    (42) comparison -> LPAREN . comparison comp_op comparison RPAREN
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    LPAREN          shift and go to state 107
    IDENTIFIER      shift and go to state 63
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    comparison                     shift and go to state 125
    value                          shift and go to state 80
    boolean                        shift and go to state 38
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 108

    (71) list -> LSQUARE values RSQUARE .

    PLUS            reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    MINUS           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    TIMES           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    DIVIDE          reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    $end            reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    EQUAL           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    NOT_EQUAL       reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LESS            reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LESS_EQUAL      reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    GREATER         reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    GREATER_EQUAL   reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LOGICAL_AND     reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    LOGICAL_OR      reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    SEMICOLON       reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 71 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 71 (list -> LSQUARE values RSQUARE .)


state 109

    (60) values -> value COMMA . values
    (59) values -> . value
    (60) values -> . value COMMA values
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 63
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42

    value                          shift and go to state 83
    values                         shift and go to state 126
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37

state 110

    (20) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 127


state 111

    (8) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 128


state 112

    (10) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 129
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 113

    (9) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 130
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 114

    (11) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 131


state 115

    (72) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 132


state 116

    (21) function_call -> IDENTIFIER LPAREN parameters RPAREN .

    $end            reduce using rule 21 (function_call -> IDENTIFIER LPAREN parameters RPAREN .)
    RPAREN          reduce using rule 21 (function_call -> IDENTIFIER LPAREN parameters RPAREN .)
    SEMICOLON       reduce using rule 21 (function_call -> IDENTIFIER LPAREN parameters RPAREN .)


state 117

    (83) parameters -> parameter COMMA . parameters
    (81) parameters -> . VOID
    (82) parameters -> . parameter
    (83) parameters -> . parameter COMMA parameters
    (84) parameters -> .
    (85) parameter -> . type IDENTIFIER
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    VOID            shift and go to state 96
    RPAREN          reduce using rule 84 (parameters -> .)
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    parameter                      shift and go to state 97
    parameters                     shift and go to state 133
    type                           shift and go to state 98

state 118

    (85) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 85 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 85 (parameter -> type IDENTIFIER .)


state 119

    (16) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 134


state 120

    (17) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LATE            reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 17 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 121

    (38) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (37) arithmetic -> arithmetic arith_op arithmetic .
    (37) arithmetic -> arithmetic . arith_op arithmetic
    (49) arith_op -> . PLUS
    (50) arith_op -> . MINUS
    (51) arith_op -> . TIMES
    (52) arith_op -> . DIVIDE

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    RPAREN          shift and go to state 135
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

  ! PLUS            [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! DIVIDE          [ reduce using rule 37 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 46

state 122

    (45) logic -> LPAREN logic logic_op logic . RPAREN
    (44) logic -> logic logic_op logic .
    (44) logic -> logic . logic_op logic
    (47) logic_op -> . LOGICAL_AND
    (48) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 136
    LOGICAL_AND     shift and go to state 52
    LOGICAL_OR      shift and go to state 53

  ! LOGICAL_AND     [ reduce using rule 44 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 44 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 51

state 123

    (42) comparison -> LPAREN comparison comp_op comparison . RPAREN
    (41) comparison -> comparison comp_op comparison .
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
    RPAREN          shift and go to state 137
    LOGICAL_AND     reduce using rule 41 (comparison -> comparison comp_op comparison .)
    LOGICAL_OR      reduce using rule 41 (comparison -> comparison comp_op comparison .)
    EQUAL           shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

  ! EQUAL           [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! NOT_EQUAL       [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS            [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! LESS_EQUAL      [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER         [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]
  ! GREATER_EQUAL   [ reduce using rule 41 (comparison -> comparison comp_op comparison .) ]

    comp_op                        shift and go to state 71

state 124

    (18) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 138


state 125

    (42) comparison -> LPAREN comparison . comp_op comparison RPAREN
    (41) comparison -> comparison . comp_op comparison
    (53) comp_op -> . EQUAL
    (54) comp_op -> . NOT_EQUAL
    (55) comp_op -> . LESS
    (56) comp_op -> . LESS_EQUAL
    (57) comp_op -> . GREATER
    (58) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    LESS            shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    GREATER         shift and go to state 76
    GREATER_EQUAL   shift and go to state 77

    comp_op                        shift and go to state 103

state 126

    (60) values -> value COMMA values .

    RSQUARE         reduce using rule 60 (values -> value COMMA values .)


state 127

    (20) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LATE            reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 20 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 128

    (8) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . arithmetic
    (34) expression -> . logic
    (35) expression -> . function_call
    (36) arithmetic -> . value
    (37) arithmetic -> . arithmetic arith_op arithmetic
    (38) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (43) logic -> . comparison
    (44) logic -> . logic logic_op logic
    (45) logic -> . LPAREN logic logic_op logic RPAREN
    (46) logic -> . LOGICAL_NOT logic
    (21) function_call -> . IDENTIFIER LPAREN parameters RPAREN
    (61) value -> . IDENTIFIER
    (62) value -> . number
    (63) value -> . string
    (64) value -> . list
    (39) comparison -> . value
    (40) comparison -> . boolean
    (41) comparison -> . comparison comp_op comparison
    (42) comparison -> . LPAREN comparison comp_op comparison RPAREN
    (65) number -> . INTEGER
    (66) number -> . DOUBLE
    (67) string -> . STRING
    (70) list -> . LSQUARE RSQUARE
    (71) list -> . LSQUARE values RSQUARE
    (68) boolean -> . TRUE
    (69) boolean -> . FALSE

    LPAREN          shift and go to state 15
    LOGICAL_NOT     shift and go to state 20
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    LSQUARE         shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 139
    arithmetic                     shift and go to state 8
    logic                          shift and go to state 9
    function_call                  shift and go to state 10
    value                          shift and go to state 18
    comparison                     shift and go to state 19
    number                         shift and go to state 35
    string                         shift and go to state 36
    list                           shift and go to state 37
    boolean                        shift and go to state 38

state 129

    (10) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 140


state 130

    (9) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 141


state 131

    (11) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 11 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 132

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 142


state 133

    (83) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 83 (parameters -> parameter COMMA parameters .)


state 134

    (16) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LATE            reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 16 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 135

    (38) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DIVIDE          reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 38 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 136

    (45) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 45 (logic -> LPAREN logic logic_op logic RPAREN .)


state 137

    (42) comparison -> LPAREN comparison comp_op comparison RPAREN .

    EQUAL           reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    NOT_EQUAL       reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS            reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LESS_EQUAL      reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER         reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    GREATER_EQUAL   reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_AND     reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    LOGICAL_OR      reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    $end            reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    RPAREN          reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)
    SEMICOLON       reduce using rule 42 (comparison -> LPAREN comparison comp_op comparison RPAREN .)


state 138

    (18) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (73) lines -> . line LINE_BREAK lines
    (74) lines -> . line lines
    (75) lines -> . line
    (76) lines -> .
    (77) line -> . print
    (78) line -> . assignment
    (79) line -> . function
    (80) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    RBRACE          reduce using rule 76 (lines -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    lines                          shift and go to state 143
    line                           shift and go to state 17
    print                          shift and go to state 67
    assignment                     shift and go to state 68
    function                       shift and go to state 69
    if_statement                   shift and go to state 70
    modifier                       shift and go to state 11
    type                           shift and go to state 12

state 139

    (8) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 144


state 140

    (10) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 10 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 141

    (9) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 9 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 142

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (73) lines -> . line LINE_BREAK lines
    (74) lines -> . line lines
    (75) lines -> . line
    (76) lines -> .
    (77) line -> . print
    (78) line -> . assignment
    (79) line -> . function
    (80) line -> . if_statement
    (16) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (17) print -> . PRINT LPAREN RPAREN SEMICOLON
    (8) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (9) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (10) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (11) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (72) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (18) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (13) modifier -> . LATE
    (14) modifier -> . FINAL
    (15) modifier -> . CONST
    (22) type -> . INTEGER_TYPE
    (23) type -> . DOUBLE_TYPE
    (24) type -> . BOOLEAN_TYPE
    (25) type -> . QUEUE_TYPE
    (26) type -> . STRING_TYPE
    (27) type -> . ENUM_TYPE
    (28) type -> . VAR
    (29) type -> . LIST_TYPE
    (30) type -> . MAP_TYPE
    (31) type -> . SET_TYPE
    (32) type -> . DYNAMIC_TYPE

    RBRACE          reduce using rule 76 (lines -> .)
    PRINT           shift and go to state 14
    IF              shift and go to state 16
    LATE            shift and go to state 21
    FINAL           shift and go to state 22
    CONST           shift and go to state 23
    INTEGER_TYPE    shift and go to state 24
    DOUBLE_TYPE     shift and go to state 25
    BOOLEAN_TYPE    shift and go to state 26
    QUEUE_TYPE      shift and go to state 27
    STRING_TYPE     shift and go to state 28
    ENUM_TYPE       shift and go to state 29
    VAR             shift and go to state 30
    LIST_TYPE       shift and go to state 31
    MAP_TYPE        shift and go to state 32
    SET_TYPE        shift and go to state 33
    DYNAMIC_TYPE    shift and go to state 34

    type                           shift and go to state 12
    lines                          shift and go to state 145
    line                           shift and go to state 17
    print                          shift and go to state 67
    assignment                     shift and go to state 68
    function                       shift and go to state 69
    if_statement                   shift and go to state 70
    modifier                       shift and go to state 11

state 143

    (18) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 146


state 144

    (8) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LATE            reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 8 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 145

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 147


state 146

    (18) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 18 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 147

    (72) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LATE            reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 72 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 78 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 78 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 86 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 86 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 89 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 89 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 122 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 122 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 123 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 123 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 17 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 17
WARNING: reduce/reduce conflict in state 18 resolved using rule (arithmetic -> value)
WARNING: rejected rule (comparison -> value) in state 18
