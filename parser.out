Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    BLOCKCOMMENT
    BREAK
    CASE
    CATCH
    COMMENT
    CONTINUE
    DEFAULT
    DO
    DOT
    ENUM
    EXTENDS
    FINALLY
    GET
    IMPLEMENTS
    IN
    RETURN
    SWITCH
    THROW
    TRY
    TYPEDEF
    ZERO

Grammar

Rule 0     S' -> statement
Rule 1     statement -> expression
Rule 2     statement -> assignment
Rule 3     statement -> print
Rule 4     statement -> function
Rule 5     statement -> if_statement
Rule 6     statement -> while_statement
Rule 7     statement -> for_statement
Rule 8     statement -> lines
Rule 9     statement -> LBRACE lines RBRACE
Rule 10    statement -> reassignment
Rule 11    statement -> <empty>
Rule 12    assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 13    assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON
Rule 14    assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON
Rule 15    assignment -> type IDENTIFIER ASSIGN expression SEMICOLON
Rule 16    assignment -> type IDENTIFIER ASSIGN expression
Rule 17    assignment -> int_assignment
Rule 18    assignment -> string_assignment
Rule 19    assignment -> list_assigment
Rule 20    assignment -> map_assigment
Rule 21    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 22    int_assignment -> number_type IDENTIFIER ASSIGN arithmetic
Rule 23    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 24    int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 25    int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 26    int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 27    int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
Rule 28    string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON
Rule 29    string_assignment -> type_string IDENTIFIER ASSIGN concate
Rule 30    string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 31    string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
Rule 32    string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 33    string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
Rule 34    string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
Rule 35    number_type -> INTEGER_TYPE
Rule 36    number_type -> VAR
Rule 37    number_type -> DOUBLE_TYPE
Rule 38    type_string -> STRING_TYPE
Rule 39    type_string -> VAR
Rule 40    reassignment -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 41    reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON
Rule 42    reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON
Rule 43    reassignment -> IDENTIFIER INLINE_ARITH number
Rule 44    reassignment -> IDENTIFIER INLINE_ARITH
Rule 45    nullable -> QUESTION_MARK
Rule 46    modifier -> FINAL
Rule 47    modifier -> CONST
Rule 48    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 49    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 50    if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE
Rule 51    if_statement -> if_statement ELSE if_statement
Rule 52    if_statement -> if_statement ELSE LBRACE lines RBRACE
Rule 53    function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON
Rule 54    function_call -> IDENTIFIER LPAREN values RPAREN
Rule 55    function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON
Rule 56    function_call -> IDENTIFIER LPAREN RPAREN
Rule 57    type -> INTEGER_TYPE
Rule 58    type -> DOUBLE_TYPE
Rule 59    type -> BOOLEAN_TYPE
Rule 60    type -> QUEUE_TYPE
Rule 61    type -> STRING_TYPE
Rule 62    type -> ENUM_TYPE
Rule 63    type -> VAR
Rule 64    type -> LIST_TYPE
Rule 65    type -> MAP_TYPE
Rule 66    type -> SET_TYPE
Rule 67    type -> DYNAMIC_TYPE
Rule 68    type -> VOID
Rule 69    expression -> arithmetic
Rule 70    expression -> concate
Rule 71    expression -> logic
Rule 72    expression -> function_call
Rule 73    expression -> division
Rule 74    arithmetic -> number
Rule 75    arithmetic -> arithmetic arith_op arithmetic
Rule 76    arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN
Rule 77    division -> number DIVIDE number
Rule 78    concate -> string
Rule 79    concate -> concate PLUS concate
Rule 80    concate -> LPAREN concate PLUS concate RPAREN
Rule 81    comparison -> int_comparison
Rule 82    comparison -> string_comparison
Rule 83    int_comparison -> boolean
Rule 84    int_comparison -> number comp_op number
Rule 85    int_comparison -> LPAREN number comp_op number RPAREN
Rule 86    string_comparison -> boolean
Rule 87    string_comparison -> string comp_op string
Rule 88    string_comparison -> LPAREN string comp_op string RPAREN
Rule 89    logic -> comparison
Rule 90    logic -> logic logic_op logic
Rule 91    logic -> LPAREN logic logic_op logic RPAREN
Rule 92    logic -> LOGICAL_NOT logic
Rule 93    logic_op -> LOGICAL_AND
Rule 94    logic_op -> LOGICAL_OR
Rule 95    arith_op -> PLUS
Rule 96    arith_op -> MINUS
Rule 97    arith_op -> TIMES
Rule 98    comp_op -> EQUAL
Rule 99    comp_op -> NOT_EQUAL
Rule 100   comp_op -> LESS
Rule 101   comp_op -> LESS_EQUAL
Rule 102   comp_op -> GREATER
Rule 103   comp_op -> GREATER_EQUAL
Rule 104   values -> value
Rule 105   values -> value COMMA values
Rule 106   value -> IDENTIFIER
Rule 107   value -> number
Rule 108   value -> string
Rule 109   value -> list
Rule 110   number -> INTEGER
Rule 111   number -> DOUBLE
Rule 112   string -> STRING
Rule 113   boolean -> TRUE
Rule 114   boolean -> FALSE
Rule 115   list -> LSQUARE RSQUARE
Rule 116   list -> LSQUARE values RSQUARE
Rule 117   list_assigment -> IDENTIFIER ASSIGN list SEMICOLON
Rule 118   list_assigment -> type ASSIGN list SEMICOLON
Rule 119   function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
Rule 120   lines -> line LINE_BREAK lines
Rule 121   lines -> line lines
Rule 122   lines -> line
Rule 123   lines -> LINE_BREAK
Rule 124   lines -> <empty>
Rule 125   line -> print
Rule 126   line -> assignment
Rule 127   line -> function
Rule 128   line -> if_statement
Rule 129   line -> while_statement
Rule 130   line -> for_statement
Rule 131   line -> function_call
Rule 132   line -> reassignment
Rule 133   parameters -> VOID
Rule 134   parameters -> parameter
Rule 135   parameters -> parameter COMMA parameters
Rule 136   parameters -> <empty>
Rule 137   parameter -> type IDENTIFIER
Rule 138   parameter -> IDENTIFIER
Rule 139   map -> MAP_TYPE LESS type COMMA type GREATER
Rule 140   map -> MAP_TYPE
Rule 141   map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
Rule 142   map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
Rule 143   map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
Rule 144   map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
Rule 145   map_values -> type COLON type
Rule 146   map_values -> type COLON type COMMA map_values
Rule 147   set -> SET_TYPE LESS type GREATER
Rule 148   set -> SET_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 149   set -> SET_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 150   queue -> QUEUE_TYPE LESS type GREATER
Rule 151   queue -> QUEUE_TYPE LESS type GREATER LSQUARE values RSQUARE
Rule 152   queue -> QUEUE_TYPE LESS type GREATER LSQUARE RSQUARE
Rule 153   while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE
Rule 154   for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

Terminals, with rules where they appear

ABSTRACT             : 
ASSIGN               : 12 13 14 15 16 21 22 23 24 25 26 27 28 29 30 31 32 33 34 40 117 118 141 142 143 144
BLOCKCOMMENT         : 
BOOLEAN_TYPE         : 59
BREAK                : 
CASE                 : 
CATCH                : 
COLON                : 145 146
COMMA                : 105 135 139 146
COMMENT              : 
CONST                : 47
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 77
DO                   : 
DOT                  : 
DOUBLE               : 111
DOUBLE_TYPE          : 37 58
DYNAMIC_TYPE         : 67
ELSE                 : 51 52
ENUM                 : 
ENUM_TYPE            : 62
EQUAL                : 98
EXTENDS              : 
FALSE                : 114
FINAL                : 46
FINALLY              : 
FOR                  : 154
GET                  : 
GREATER              : 102 139 147 148 149 150 151 152
GREATER_EQUAL        : 103
IDENTIFIER           : 12 13 14 15 16 21 22 23 24 25 26 27 28 29 30 31 32 33 34 40 41 42 43 44 53 54 55 56 106 117 119 137 138 141 142 143 143 144
IF                   : 50
IMPLEMENTS           : 
IN                   : 
INLINE_ARITH         : 41 42 43 44
INTEGER              : 110
INTEGER_TYPE         : 35 57
LBRACE               : 9 50 52 119 141 142 143 144 153 154
LESS                 : 100 139 147 148 149 150 151 152
LESS_EQUAL           : 101
LINE_BREAK           : 120 123
LIST_TYPE            : 64
LOGICAL_AND          : 93
LOGICAL_NOT          : 92
LOGICAL_OR           : 94
LPAREN               : 48 49 50 53 54 55 56 76 80 85 88 91 119 153 154
LSQUARE              : 115 116 148 149 151 152
MAP_TYPE             : 65 139 140
MINUS                : 96
NOT_EQUAL            : 99
NULL                 : 23 24 30 31
PLUS                 : 79 80 95
PRINT                : 48 49
QUESTION_MARK        : 45
QUEUE_TYPE           : 60 150 151 152
RBRACE               : 9 50 52 119 141 142 143 144 153 154
RETURN               : 
RPAREN               : 48 49 50 53 54 55 56 76 80 85 88 91 119 153 154
RSQUARE              : 115 116 148 149 151 152
SEMICOLON            : 12 13 14 15 21 23 24 25 26 27 28 30 31 32 33 34 40 41 42 48 49 53 55 117 118 141 142 143 144 154 154
SET_TYPE             : 66 147 148 149
STRING               : 112
STRING_TYPE          : 38 61
SWITCH               : 
THROW                : 
TIMES                : 97
TRUE                 : 113
TRY                  : 
TYPEDEF              : 
VAR                  : 36 39 63
VOID                 : 68 133
WHILE                : 153
ZERO                 : 
error                : 

Nonterminals, with rules where they appear

arith_op             : 75 76
arithmetic           : 21 22 25 26 27 69 75 75 76 76
assignment           : 2 126 154
boolean              : 83 86
comp_op              : 84 85 87 88
comparison           : 89
concate              : 28 29 32 33 34 70 79 79 80 80
division             : 73
expression           : 1 12 13 14 15 16 40 48
for_statement        : 7 130
function             : 4 127
function_call        : 72 131
if_statement         : 5 51 51 52 128
int_assignment       : 17
int_comparison       : 81
line                 : 120 121 122
lines                : 8 9 50 52 119 120 121 153 154
list                 : 109 117 118
list_assigment       : 19
logic                : 50 71 90 90 91 91 92 153 154
logic_op             : 90 91
map                  : 141 142
map_assigment        : 20
map_values           : 142 143 146
modifier             : 12 14 23 25 27 30 32 34
nullable             : 12 13 23 24 25 26 30 31 32 33
number               : 41 43 74 77 77 84 84 85 85 107
number_type          : 21 22 23 24 25 26 27
parameter            : 134 135
parameters           : 119 135
print                : 3 125
queue                : 
reassignment         : 10 132 154
set                  : 
statement            : 0
string               : 78 87 87 88 88 108
string_assignment    : 18
string_comparison    : 82
type                 : 12 13 14 15 16 118 119 137 139 139 145 145 146 146 147 148 149 150 151 152
type_string          : 28 29 30 31 32 33 34
value                : 104 105
values               : 53 54 105 116 148 151
while_statement      : 6 129

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . expression
    (2) statement -> . assignment
    (3) statement -> . print
    (4) statement -> . function
    (5) statement -> . if_statement
    (6) statement -> . while_statement
    (7) statement -> . for_statement
    (8) statement -> . lines
    (9) statement -> . LBRACE lines RBRACE
    (10) statement -> . reassignment
    (11) statement -> .
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

  ! reduce/reduce conflict for $end resolved using rule 11 (statement -> .)
    LBRACE          shift and go to state 10
    $end            reduce using rule 11 (statement -> .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    LINE_BREAK      shift and go to state 30
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

  ! $end            [ reduce using rule 124 (lines -> .) ]

    statement                      shift and go to state 1
    expression                     shift and go to state 2
    assignment                     shift and go to state 3
    print                          shift and go to state 4
    function                       shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    for_statement                  shift and go to state 8
    lines                          shift and go to state 9
    reassignment                   shift and go to state 11
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 15
    division                       shift and go to state 16
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    line                           shift and go to state 29
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 1

    (0) S' -> statement .



state 2

    (1) statement -> expression .

    $end            reduce using rule 1 (statement -> expression .)


state 3

    (2) statement -> assignment .
    (126) line -> assignment .

  ! reduce/reduce conflict for $end resolved using rule 2 (statement -> assignment .)
    $end            reduce using rule 2 (statement -> assignment .)
    LINE_BREAK      reduce using rule 126 (line -> assignment .)
    PRINT           reduce using rule 126 (line -> assignment .)
    IF              reduce using rule 126 (line -> assignment .)
    WHILE           reduce using rule 126 (line -> assignment .)
    FOR             reduce using rule 126 (line -> assignment .)
    IDENTIFIER      reduce using rule 126 (line -> assignment .)
    FINAL           reduce using rule 126 (line -> assignment .)
    CONST           reduce using rule 126 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 126 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 126 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 126 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 126 (line -> assignment .)
    STRING_TYPE     reduce using rule 126 (line -> assignment .)
    ENUM_TYPE       reduce using rule 126 (line -> assignment .)
    VAR             reduce using rule 126 (line -> assignment .)
    LIST_TYPE       reduce using rule 126 (line -> assignment .)
    MAP_TYPE        reduce using rule 126 (line -> assignment .)
    SET_TYPE        reduce using rule 126 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 126 (line -> assignment .)
    VOID            reduce using rule 126 (line -> assignment .)

  ! $end            [ reduce using rule 126 (line -> assignment .) ]


state 4

    (3) statement -> print .
    (125) line -> print .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement -> print .)
    $end            reduce using rule 3 (statement -> print .)
    LINE_BREAK      reduce using rule 125 (line -> print .)
    PRINT           reduce using rule 125 (line -> print .)
    IF              reduce using rule 125 (line -> print .)
    WHILE           reduce using rule 125 (line -> print .)
    FOR             reduce using rule 125 (line -> print .)
    IDENTIFIER      reduce using rule 125 (line -> print .)
    FINAL           reduce using rule 125 (line -> print .)
    CONST           reduce using rule 125 (line -> print .)
    INTEGER_TYPE    reduce using rule 125 (line -> print .)
    DOUBLE_TYPE     reduce using rule 125 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 125 (line -> print .)
    QUEUE_TYPE      reduce using rule 125 (line -> print .)
    STRING_TYPE     reduce using rule 125 (line -> print .)
    ENUM_TYPE       reduce using rule 125 (line -> print .)
    VAR             reduce using rule 125 (line -> print .)
    LIST_TYPE       reduce using rule 125 (line -> print .)
    MAP_TYPE        reduce using rule 125 (line -> print .)
    SET_TYPE        reduce using rule 125 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 125 (line -> print .)
    VOID            reduce using rule 125 (line -> print .)

  ! $end            [ reduce using rule 125 (line -> print .) ]


state 5

    (4) statement -> function .
    (127) line -> function .

  ! reduce/reduce conflict for $end resolved using rule 4 (statement -> function .)
    $end            reduce using rule 4 (statement -> function .)
    LINE_BREAK      reduce using rule 127 (line -> function .)
    PRINT           reduce using rule 127 (line -> function .)
    IF              reduce using rule 127 (line -> function .)
    WHILE           reduce using rule 127 (line -> function .)
    FOR             reduce using rule 127 (line -> function .)
    IDENTIFIER      reduce using rule 127 (line -> function .)
    FINAL           reduce using rule 127 (line -> function .)
    CONST           reduce using rule 127 (line -> function .)
    INTEGER_TYPE    reduce using rule 127 (line -> function .)
    DOUBLE_TYPE     reduce using rule 127 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 127 (line -> function .)
    QUEUE_TYPE      reduce using rule 127 (line -> function .)
    STRING_TYPE     reduce using rule 127 (line -> function .)
    ENUM_TYPE       reduce using rule 127 (line -> function .)
    VAR             reduce using rule 127 (line -> function .)
    LIST_TYPE       reduce using rule 127 (line -> function .)
    MAP_TYPE        reduce using rule 127 (line -> function .)
    SET_TYPE        reduce using rule 127 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 127 (line -> function .)
    VOID            reduce using rule 127 (line -> function .)

  ! $end            [ reduce using rule 127 (line -> function .) ]


state 6

    (5) statement -> if_statement .
    (51) if_statement -> if_statement . ELSE if_statement
    (52) if_statement -> if_statement . ELSE LBRACE lines RBRACE
    (128) line -> if_statement .

  ! reduce/reduce conflict for $end resolved using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    ELSE            shift and go to state 60
    LINE_BREAK      reduce using rule 128 (line -> if_statement .)
    PRINT           reduce using rule 128 (line -> if_statement .)
    IF              reduce using rule 128 (line -> if_statement .)
    WHILE           reduce using rule 128 (line -> if_statement .)
    FOR             reduce using rule 128 (line -> if_statement .)
    IDENTIFIER      reduce using rule 128 (line -> if_statement .)
    FINAL           reduce using rule 128 (line -> if_statement .)
    CONST           reduce using rule 128 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 128 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 128 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 128 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 128 (line -> if_statement .)
    STRING_TYPE     reduce using rule 128 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 128 (line -> if_statement .)
    VAR             reduce using rule 128 (line -> if_statement .)
    LIST_TYPE       reduce using rule 128 (line -> if_statement .)
    MAP_TYPE        reduce using rule 128 (line -> if_statement .)
    SET_TYPE        reduce using rule 128 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 128 (line -> if_statement .)
    VOID            reduce using rule 128 (line -> if_statement .)

  ! $end            [ reduce using rule 128 (line -> if_statement .) ]


state 7

    (6) statement -> while_statement .
    (129) line -> while_statement .

  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> while_statement .)
    $end            reduce using rule 6 (statement -> while_statement .)
    LINE_BREAK      reduce using rule 129 (line -> while_statement .)
    PRINT           reduce using rule 129 (line -> while_statement .)
    IF              reduce using rule 129 (line -> while_statement .)
    WHILE           reduce using rule 129 (line -> while_statement .)
    FOR             reduce using rule 129 (line -> while_statement .)
    IDENTIFIER      reduce using rule 129 (line -> while_statement .)
    FINAL           reduce using rule 129 (line -> while_statement .)
    CONST           reduce using rule 129 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 129 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 129 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 129 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 129 (line -> while_statement .)
    STRING_TYPE     reduce using rule 129 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 129 (line -> while_statement .)
    VAR             reduce using rule 129 (line -> while_statement .)
    LIST_TYPE       reduce using rule 129 (line -> while_statement .)
    MAP_TYPE        reduce using rule 129 (line -> while_statement .)
    SET_TYPE        reduce using rule 129 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 129 (line -> while_statement .)
    VOID            reduce using rule 129 (line -> while_statement .)

  ! $end            [ reduce using rule 129 (line -> while_statement .) ]


state 8

    (7) statement -> for_statement .
    (130) line -> for_statement .

  ! reduce/reduce conflict for $end resolved using rule 7 (statement -> for_statement .)
    $end            reduce using rule 7 (statement -> for_statement .)
    LINE_BREAK      reduce using rule 130 (line -> for_statement .)
    PRINT           reduce using rule 130 (line -> for_statement .)
    IF              reduce using rule 130 (line -> for_statement .)
    WHILE           reduce using rule 130 (line -> for_statement .)
    FOR             reduce using rule 130 (line -> for_statement .)
    IDENTIFIER      reduce using rule 130 (line -> for_statement .)
    FINAL           reduce using rule 130 (line -> for_statement .)
    CONST           reduce using rule 130 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 130 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 130 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 130 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 130 (line -> for_statement .)
    STRING_TYPE     reduce using rule 130 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 130 (line -> for_statement .)
    VAR             reduce using rule 130 (line -> for_statement .)
    LIST_TYPE       reduce using rule 130 (line -> for_statement .)
    MAP_TYPE        reduce using rule 130 (line -> for_statement .)
    SET_TYPE        reduce using rule 130 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 130 (line -> for_statement .)
    VOID            reduce using rule 130 (line -> for_statement .)

  ! $end            [ reduce using rule 130 (line -> for_statement .) ]


state 9

    (8) statement -> lines .

    $end            reduce using rule 8 (statement -> lines .)


state 10

    (9) statement -> LBRACE . lines RBRACE
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 30
    RBRACE          reduce using rule 124 (lines -> .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    lines                          shift and go to state 61
    line                           shift and go to state 29
    print                          shift and go to state 62
    assignment                     shift and go to state 63
    function                       shift and go to state 64
    if_statement                   shift and go to state 65
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    reassignment                   shift and go to state 69
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 11

    (10) statement -> reassignment .
    (132) line -> reassignment .

  ! reduce/reduce conflict for $end resolved using rule 10 (statement -> reassignment .)
    $end            reduce using rule 10 (statement -> reassignment .)
    LINE_BREAK      reduce using rule 132 (line -> reassignment .)
    PRINT           reduce using rule 132 (line -> reassignment .)
    IF              reduce using rule 132 (line -> reassignment .)
    WHILE           reduce using rule 132 (line -> reassignment .)
    FOR             reduce using rule 132 (line -> reassignment .)
    IDENTIFIER      reduce using rule 132 (line -> reassignment .)
    FINAL           reduce using rule 132 (line -> reassignment .)
    CONST           reduce using rule 132 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 132 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 132 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 132 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 132 (line -> reassignment .)
    STRING_TYPE     reduce using rule 132 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 132 (line -> reassignment .)
    VAR             reduce using rule 132 (line -> reassignment .)
    LIST_TYPE       reduce using rule 132 (line -> reassignment .)
    MAP_TYPE        reduce using rule 132 (line -> reassignment .)
    SET_TYPE        reduce using rule 132 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 132 (line -> reassignment .)
    VOID            reduce using rule 132 (line -> reassignment .)

  ! $end            [ reduce using rule 132 (line -> reassignment .) ]


state 12

    (69) expression -> arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    $end            reduce using rule 69 (expression -> arithmetic .)
    SEMICOLON       reduce using rule 69 (expression -> arithmetic .)
    RPAREN          reduce using rule 69 (expression -> arithmetic .)
    LINE_BREAK      reduce using rule 69 (expression -> arithmetic .)
    PRINT           reduce using rule 69 (expression -> arithmetic .)
    IF              reduce using rule 69 (expression -> arithmetic .)
    WHILE           reduce using rule 69 (expression -> arithmetic .)
    FOR             reduce using rule 69 (expression -> arithmetic .)
    IDENTIFIER      reduce using rule 69 (expression -> arithmetic .)
    FINAL           reduce using rule 69 (expression -> arithmetic .)
    CONST           reduce using rule 69 (expression -> arithmetic .)
    INTEGER_TYPE    reduce using rule 69 (expression -> arithmetic .)
    DOUBLE_TYPE     reduce using rule 69 (expression -> arithmetic .)
    BOOLEAN_TYPE    reduce using rule 69 (expression -> arithmetic .)
    QUEUE_TYPE      reduce using rule 69 (expression -> arithmetic .)
    STRING_TYPE     reduce using rule 69 (expression -> arithmetic .)
    ENUM_TYPE       reduce using rule 69 (expression -> arithmetic .)
    VAR             reduce using rule 69 (expression -> arithmetic .)
    LIST_TYPE       reduce using rule 69 (expression -> arithmetic .)
    MAP_TYPE        reduce using rule 69 (expression -> arithmetic .)
    SET_TYPE        reduce using rule 69 (expression -> arithmetic .)
    DYNAMIC_TYPE    reduce using rule 69 (expression -> arithmetic .)
    VOID            reduce using rule 69 (expression -> arithmetic .)
    RBRACE          reduce using rule 69 (expression -> arithmetic .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

    arith_op                       shift and go to state 71

state 13

    (70) expression -> concate .
    (79) concate -> concate . PLUS concate

    $end            reduce using rule 70 (expression -> concate .)
    SEMICOLON       reduce using rule 70 (expression -> concate .)
    RPAREN          reduce using rule 70 (expression -> concate .)
    LINE_BREAK      reduce using rule 70 (expression -> concate .)
    PRINT           reduce using rule 70 (expression -> concate .)
    IF              reduce using rule 70 (expression -> concate .)
    WHILE           reduce using rule 70 (expression -> concate .)
    FOR             reduce using rule 70 (expression -> concate .)
    IDENTIFIER      reduce using rule 70 (expression -> concate .)
    FINAL           reduce using rule 70 (expression -> concate .)
    CONST           reduce using rule 70 (expression -> concate .)
    INTEGER_TYPE    reduce using rule 70 (expression -> concate .)
    DOUBLE_TYPE     reduce using rule 70 (expression -> concate .)
    BOOLEAN_TYPE    reduce using rule 70 (expression -> concate .)
    QUEUE_TYPE      reduce using rule 70 (expression -> concate .)
    STRING_TYPE     reduce using rule 70 (expression -> concate .)
    ENUM_TYPE       reduce using rule 70 (expression -> concate .)
    VAR             reduce using rule 70 (expression -> concate .)
    LIST_TYPE       reduce using rule 70 (expression -> concate .)
    MAP_TYPE        reduce using rule 70 (expression -> concate .)
    SET_TYPE        reduce using rule 70 (expression -> concate .)
    DYNAMIC_TYPE    reduce using rule 70 (expression -> concate .)
    VOID            reduce using rule 70 (expression -> concate .)
    RBRACE          reduce using rule 70 (expression -> concate .)
    PLUS            shift and go to state 75


state 14

    (71) expression -> logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    $end            reduce using rule 71 (expression -> logic .)
    SEMICOLON       reduce using rule 71 (expression -> logic .)
    RPAREN          reduce using rule 71 (expression -> logic .)
    LINE_BREAK      reduce using rule 71 (expression -> logic .)
    PRINT           reduce using rule 71 (expression -> logic .)
    IF              reduce using rule 71 (expression -> logic .)
    WHILE           reduce using rule 71 (expression -> logic .)
    FOR             reduce using rule 71 (expression -> logic .)
    IDENTIFIER      reduce using rule 71 (expression -> logic .)
    FINAL           reduce using rule 71 (expression -> logic .)
    CONST           reduce using rule 71 (expression -> logic .)
    INTEGER_TYPE    reduce using rule 71 (expression -> logic .)
    DOUBLE_TYPE     reduce using rule 71 (expression -> logic .)
    BOOLEAN_TYPE    reduce using rule 71 (expression -> logic .)
    QUEUE_TYPE      reduce using rule 71 (expression -> logic .)
    STRING_TYPE     reduce using rule 71 (expression -> logic .)
    ENUM_TYPE       reduce using rule 71 (expression -> logic .)
    VAR             reduce using rule 71 (expression -> logic .)
    LIST_TYPE       reduce using rule 71 (expression -> logic .)
    MAP_TYPE        reduce using rule 71 (expression -> logic .)
    SET_TYPE        reduce using rule 71 (expression -> logic .)
    DYNAMIC_TYPE    reduce using rule 71 (expression -> logic .)
    VOID            reduce using rule 71 (expression -> logic .)
    RBRACE          reduce using rule 71 (expression -> logic .)
    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

    logic_op                       shift and go to state 76

state 15

    (72) expression -> function_call .
    (131) line -> function_call .

  ! reduce/reduce conflict for $end resolved using rule 72 (expression -> function_call .)
    $end            reduce using rule 72 (expression -> function_call .)
    LINE_BREAK      reduce using rule 131 (line -> function_call .)
    PRINT           reduce using rule 131 (line -> function_call .)
    IF              reduce using rule 131 (line -> function_call .)
    WHILE           reduce using rule 131 (line -> function_call .)
    FOR             reduce using rule 131 (line -> function_call .)
    IDENTIFIER      reduce using rule 131 (line -> function_call .)
    FINAL           reduce using rule 131 (line -> function_call .)
    CONST           reduce using rule 131 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 131 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 131 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 131 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 131 (line -> function_call .)
    STRING_TYPE     reduce using rule 131 (line -> function_call .)
    ENUM_TYPE       reduce using rule 131 (line -> function_call .)
    VAR             reduce using rule 131 (line -> function_call .)
    LIST_TYPE       reduce using rule 131 (line -> function_call .)
    MAP_TYPE        reduce using rule 131 (line -> function_call .)
    SET_TYPE        reduce using rule 131 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 131 (line -> function_call .)
    VOID            reduce using rule 131 (line -> function_call .)

  ! $end            [ reduce using rule 131 (line -> function_call .) ]


state 16

    (73) expression -> division .

    $end            reduce using rule 73 (expression -> division .)
    SEMICOLON       reduce using rule 73 (expression -> division .)
    RPAREN          reduce using rule 73 (expression -> division .)
    LINE_BREAK      reduce using rule 73 (expression -> division .)
    PRINT           reduce using rule 73 (expression -> division .)
    IF              reduce using rule 73 (expression -> division .)
    WHILE           reduce using rule 73 (expression -> division .)
    FOR             reduce using rule 73 (expression -> division .)
    IDENTIFIER      reduce using rule 73 (expression -> division .)
    FINAL           reduce using rule 73 (expression -> division .)
    CONST           reduce using rule 73 (expression -> division .)
    INTEGER_TYPE    reduce using rule 73 (expression -> division .)
    DOUBLE_TYPE     reduce using rule 73 (expression -> division .)
    BOOLEAN_TYPE    reduce using rule 73 (expression -> division .)
    QUEUE_TYPE      reduce using rule 73 (expression -> division .)
    STRING_TYPE     reduce using rule 73 (expression -> division .)
    ENUM_TYPE       reduce using rule 73 (expression -> division .)
    VAR             reduce using rule 73 (expression -> division .)
    LIST_TYPE       reduce using rule 73 (expression -> division .)
    MAP_TYPE        reduce using rule 73 (expression -> division .)
    SET_TYPE        reduce using rule 73 (expression -> division .)
    DYNAMIC_TYPE    reduce using rule 73 (expression -> division .)
    VOID            reduce using rule 73 (expression -> division .)
    RBRACE          reduce using rule 73 (expression -> division .)


state 17

    (12) assignment -> modifier . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier . type IDENTIFIER ASSIGN expression SEMICOLON
    (23) int_assignment -> modifier . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> modifier . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (30) string_assignment -> modifier . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> modifier . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR

    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 79
    number_type                    shift and go to state 80
    type_string                    shift and go to state 81

state 18

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (119) function -> type . IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (118) list_assigment -> type . ASSIGN list SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 84
    ASSIGN          shift and go to state 85
    QUESTION_MARK   shift and go to state 86

    nullable                       shift and go to state 83

state 19

    (40) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (43) reassignment -> IDENTIFIER . INLINE_ARITH number
    (44) reassignment -> IDENTIFIER . INLINE_ARITH
    (53) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN values RPAREN
    (55) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER . LPAREN RPAREN
    (117) list_assigment -> IDENTIFIER . ASSIGN list SEMICOLON
    (143) map_assigment -> IDENTIFIER . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON

    ASSIGN          shift and go to state 88
    INLINE_ARITH    shift and go to state 89
    LPAREN          shift and go to state 90
    IDENTIFIER      shift and go to state 87


state 20

    (17) assignment -> int_assignment .

    $end            reduce using rule 17 (assignment -> int_assignment .)
    LINE_BREAK      reduce using rule 17 (assignment -> int_assignment .)
    PRINT           reduce using rule 17 (assignment -> int_assignment .)
    IF              reduce using rule 17 (assignment -> int_assignment .)
    WHILE           reduce using rule 17 (assignment -> int_assignment .)
    FOR             reduce using rule 17 (assignment -> int_assignment .)
    IDENTIFIER      reduce using rule 17 (assignment -> int_assignment .)
    FINAL           reduce using rule 17 (assignment -> int_assignment .)
    CONST           reduce using rule 17 (assignment -> int_assignment .)
    INTEGER_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    DOUBLE_TYPE     reduce using rule 17 (assignment -> int_assignment .)
    BOOLEAN_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    QUEUE_TYPE      reduce using rule 17 (assignment -> int_assignment .)
    STRING_TYPE     reduce using rule 17 (assignment -> int_assignment .)
    ENUM_TYPE       reduce using rule 17 (assignment -> int_assignment .)
    VAR             reduce using rule 17 (assignment -> int_assignment .)
    LIST_TYPE       reduce using rule 17 (assignment -> int_assignment .)
    MAP_TYPE        reduce using rule 17 (assignment -> int_assignment .)
    SET_TYPE        reduce using rule 17 (assignment -> int_assignment .)
    DYNAMIC_TYPE    reduce using rule 17 (assignment -> int_assignment .)
    VOID            reduce using rule 17 (assignment -> int_assignment .)
    RBRACE          reduce using rule 17 (assignment -> int_assignment .)
    SEMICOLON       reduce using rule 17 (assignment -> int_assignment .)


state 21

    (18) assignment -> string_assignment .

    $end            reduce using rule 18 (assignment -> string_assignment .)
    LINE_BREAK      reduce using rule 18 (assignment -> string_assignment .)
    PRINT           reduce using rule 18 (assignment -> string_assignment .)
    IF              reduce using rule 18 (assignment -> string_assignment .)
    WHILE           reduce using rule 18 (assignment -> string_assignment .)
    FOR             reduce using rule 18 (assignment -> string_assignment .)
    IDENTIFIER      reduce using rule 18 (assignment -> string_assignment .)
    FINAL           reduce using rule 18 (assignment -> string_assignment .)
    CONST           reduce using rule 18 (assignment -> string_assignment .)
    INTEGER_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    DOUBLE_TYPE     reduce using rule 18 (assignment -> string_assignment .)
    BOOLEAN_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    QUEUE_TYPE      reduce using rule 18 (assignment -> string_assignment .)
    STRING_TYPE     reduce using rule 18 (assignment -> string_assignment .)
    ENUM_TYPE       reduce using rule 18 (assignment -> string_assignment .)
    VAR             reduce using rule 18 (assignment -> string_assignment .)
    LIST_TYPE       reduce using rule 18 (assignment -> string_assignment .)
    MAP_TYPE        reduce using rule 18 (assignment -> string_assignment .)
    SET_TYPE        reduce using rule 18 (assignment -> string_assignment .)
    DYNAMIC_TYPE    reduce using rule 18 (assignment -> string_assignment .)
    VOID            reduce using rule 18 (assignment -> string_assignment .)
    RBRACE          reduce using rule 18 (assignment -> string_assignment .)
    SEMICOLON       reduce using rule 18 (assignment -> string_assignment .)


state 22

    (19) assignment -> list_assigment .

    $end            reduce using rule 19 (assignment -> list_assigment .)
    LINE_BREAK      reduce using rule 19 (assignment -> list_assigment .)
    PRINT           reduce using rule 19 (assignment -> list_assigment .)
    IF              reduce using rule 19 (assignment -> list_assigment .)
    WHILE           reduce using rule 19 (assignment -> list_assigment .)
    FOR             reduce using rule 19 (assignment -> list_assigment .)
    IDENTIFIER      reduce using rule 19 (assignment -> list_assigment .)
    FINAL           reduce using rule 19 (assignment -> list_assigment .)
    CONST           reduce using rule 19 (assignment -> list_assigment .)
    INTEGER_TYPE    reduce using rule 19 (assignment -> list_assigment .)
    DOUBLE_TYPE     reduce using rule 19 (assignment -> list_assigment .)
    BOOLEAN_TYPE    reduce using rule 19 (assignment -> list_assigment .)
    QUEUE_TYPE      reduce using rule 19 (assignment -> list_assigment .)
    STRING_TYPE     reduce using rule 19 (assignment -> list_assigment .)
    ENUM_TYPE       reduce using rule 19 (assignment -> list_assigment .)
    VAR             reduce using rule 19 (assignment -> list_assigment .)
    LIST_TYPE       reduce using rule 19 (assignment -> list_assigment .)
    MAP_TYPE        reduce using rule 19 (assignment -> list_assigment .)
    SET_TYPE        reduce using rule 19 (assignment -> list_assigment .)
    DYNAMIC_TYPE    reduce using rule 19 (assignment -> list_assigment .)
    VOID            reduce using rule 19 (assignment -> list_assigment .)
    RBRACE          reduce using rule 19 (assignment -> list_assigment .)
    SEMICOLON       reduce using rule 19 (assignment -> list_assigment .)


state 23

    (20) assignment -> map_assigment .

    $end            reduce using rule 20 (assignment -> map_assigment .)
    LINE_BREAK      reduce using rule 20 (assignment -> map_assigment .)
    PRINT           reduce using rule 20 (assignment -> map_assigment .)
    IF              reduce using rule 20 (assignment -> map_assigment .)
    WHILE           reduce using rule 20 (assignment -> map_assigment .)
    FOR             reduce using rule 20 (assignment -> map_assigment .)
    IDENTIFIER      reduce using rule 20 (assignment -> map_assigment .)
    FINAL           reduce using rule 20 (assignment -> map_assigment .)
    CONST           reduce using rule 20 (assignment -> map_assigment .)
    INTEGER_TYPE    reduce using rule 20 (assignment -> map_assigment .)
    DOUBLE_TYPE     reduce using rule 20 (assignment -> map_assigment .)
    BOOLEAN_TYPE    reduce using rule 20 (assignment -> map_assigment .)
    QUEUE_TYPE      reduce using rule 20 (assignment -> map_assigment .)
    STRING_TYPE     reduce using rule 20 (assignment -> map_assigment .)
    ENUM_TYPE       reduce using rule 20 (assignment -> map_assigment .)
    VAR             reduce using rule 20 (assignment -> map_assigment .)
    LIST_TYPE       reduce using rule 20 (assignment -> map_assigment .)
    MAP_TYPE        reduce using rule 20 (assignment -> map_assigment .)
    SET_TYPE        reduce using rule 20 (assignment -> map_assigment .)
    DYNAMIC_TYPE    reduce using rule 20 (assignment -> map_assigment .)
    VOID            reduce using rule 20 (assignment -> map_assigment .)
    RBRACE          reduce using rule 20 (assignment -> map_assigment .)
    SEMICOLON       reduce using rule 20 (assignment -> map_assigment .)


state 24

    (48) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (49) print -> PRINT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 91


state 25

    (76) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (80) concate -> LPAREN . concate PLUS concate RPAREN
    (91) logic -> LPAREN . logic logic_op logic RPAREN
    (85) int_comparison -> LPAREN . number comp_op number RPAREN
    (88) string_comparison -> LPAREN . string comp_op string RPAREN
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    arithmetic                     shift and go to state 92
    concate                        shift and go to state 93
    logic                          shift and go to state 94
    number                         shift and go to state 95
    string                         shift and go to state 96
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 26

    (50) if_statement -> IF . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 97


state 27

    (153) while_statement -> WHILE . LPAREN logic RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 98


state 28

    (154) for_statement -> FOR . LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    LPAREN          shift and go to state 99


state 29

    (120) lines -> line . LINE_BREAK lines
    (121) lines -> line . lines
    (122) lines -> line .
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

  ! reduce/reduce conflict for $end resolved using rule 122 (lines -> line .)
  ! reduce/reduce conflict for RBRACE resolved using rule 122 (lines -> line .)
    LINE_BREAK      shift and go to state 100
    $end            reduce using rule 122 (lines -> line .)
    RBRACE          reduce using rule 122 (lines -> line .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

  ! $end            [ reduce using rule 124 (lines -> .) ]
  ! RBRACE          [ reduce using rule 124 (lines -> .) ]

    line                           shift and go to state 29
    lines                          shift and go to state 101
    print                          shift and go to state 62
    assignment                     shift and go to state 63
    function                       shift and go to state 64
    if_statement                   shift and go to state 65
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    reassignment                   shift and go to state 69
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 30

    (123) lines -> LINE_BREAK .

    $end            reduce using rule 123 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 123 (lines -> LINE_BREAK .)


state 31

    (74) arithmetic -> number .
    (77) division -> number . DIVIDE number
    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 74 (arithmetic -> number .)
    MINUS           reduce using rule 74 (arithmetic -> number .)
    TIMES           reduce using rule 74 (arithmetic -> number .)
    $end            reduce using rule 74 (arithmetic -> number .)
    SEMICOLON       reduce using rule 74 (arithmetic -> number .)
    RPAREN          reduce using rule 74 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 74 (arithmetic -> number .)
    PRINT           reduce using rule 74 (arithmetic -> number .)
    IF              reduce using rule 74 (arithmetic -> number .)
    WHILE           reduce using rule 74 (arithmetic -> number .)
    FOR             reduce using rule 74 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 74 (arithmetic -> number .)
    FINAL           reduce using rule 74 (arithmetic -> number .)
    CONST           reduce using rule 74 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 74 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 74 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 74 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 74 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 74 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 74 (arithmetic -> number .)
    VAR             reduce using rule 74 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 74 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 74 (arithmetic -> number .)
    SET_TYPE        reduce using rule 74 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 74 (arithmetic -> number .)
    VOID            reduce using rule 74 (arithmetic -> number .)
    RBRACE          reduce using rule 74 (arithmetic -> number .)
    DIVIDE          shift and go to state 102
    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 103

state 32

    (78) concate -> string .
    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 78 (concate -> string .)
    $end            reduce using rule 78 (concate -> string .)
    SEMICOLON       reduce using rule 78 (concate -> string .)
    RPAREN          reduce using rule 78 (concate -> string .)
    LINE_BREAK      reduce using rule 78 (concate -> string .)
    PRINT           reduce using rule 78 (concate -> string .)
    IF              reduce using rule 78 (concate -> string .)
    WHILE           reduce using rule 78 (concate -> string .)
    FOR             reduce using rule 78 (concate -> string .)
    IDENTIFIER      reduce using rule 78 (concate -> string .)
    FINAL           reduce using rule 78 (concate -> string .)
    CONST           reduce using rule 78 (concate -> string .)
    INTEGER_TYPE    reduce using rule 78 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 78 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 78 (concate -> string .)
    QUEUE_TYPE      reduce using rule 78 (concate -> string .)
    STRING_TYPE     reduce using rule 78 (concate -> string .)
    ENUM_TYPE       reduce using rule 78 (concate -> string .)
    VAR             reduce using rule 78 (concate -> string .)
    LIST_TYPE       reduce using rule 78 (concate -> string .)
    MAP_TYPE        reduce using rule 78 (concate -> string .)
    SET_TYPE        reduce using rule 78 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 78 (concate -> string .)
    VOID            reduce using rule 78 (concate -> string .)
    RBRACE          reduce using rule 78 (concate -> string .)
    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 110

state 33

    (89) logic -> comparison .

    LOGICAL_AND     reduce using rule 89 (logic -> comparison .)
    LOGICAL_OR      reduce using rule 89 (logic -> comparison .)
    $end            reduce using rule 89 (logic -> comparison .)
    SEMICOLON       reduce using rule 89 (logic -> comparison .)
    RPAREN          reduce using rule 89 (logic -> comparison .)
    LINE_BREAK      reduce using rule 89 (logic -> comparison .)
    PRINT           reduce using rule 89 (logic -> comparison .)
    IF              reduce using rule 89 (logic -> comparison .)
    WHILE           reduce using rule 89 (logic -> comparison .)
    FOR             reduce using rule 89 (logic -> comparison .)
    IDENTIFIER      reduce using rule 89 (logic -> comparison .)
    FINAL           reduce using rule 89 (logic -> comparison .)
    CONST           reduce using rule 89 (logic -> comparison .)
    INTEGER_TYPE    reduce using rule 89 (logic -> comparison .)
    DOUBLE_TYPE     reduce using rule 89 (logic -> comparison .)
    BOOLEAN_TYPE    reduce using rule 89 (logic -> comparison .)
    QUEUE_TYPE      reduce using rule 89 (logic -> comparison .)
    STRING_TYPE     reduce using rule 89 (logic -> comparison .)
    ENUM_TYPE       reduce using rule 89 (logic -> comparison .)
    VAR             reduce using rule 89 (logic -> comparison .)
    LIST_TYPE       reduce using rule 89 (logic -> comparison .)
    MAP_TYPE        reduce using rule 89 (logic -> comparison .)
    SET_TYPE        reduce using rule 89 (logic -> comparison .)
    DYNAMIC_TYPE    reduce using rule 89 (logic -> comparison .)
    VOID            reduce using rule 89 (logic -> comparison .)
    RBRACE          reduce using rule 89 (logic -> comparison .)


state 34

    (92) logic -> LOGICAL_NOT . logic
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 112
    LOGICAL_NOT     shift and go to state 34
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54

    logic                          shift and go to state 111
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57
    number                         shift and go to state 113
    string                         shift and go to state 114

state 35

    (46) modifier -> FINAL .

    INTEGER_TYPE    reduce using rule 46 (modifier -> FINAL .)
    DOUBLE_TYPE     reduce using rule 46 (modifier -> FINAL .)
    BOOLEAN_TYPE    reduce using rule 46 (modifier -> FINAL .)
    QUEUE_TYPE      reduce using rule 46 (modifier -> FINAL .)
    STRING_TYPE     reduce using rule 46 (modifier -> FINAL .)
    ENUM_TYPE       reduce using rule 46 (modifier -> FINAL .)
    VAR             reduce using rule 46 (modifier -> FINAL .)
    LIST_TYPE       reduce using rule 46 (modifier -> FINAL .)
    MAP_TYPE        reduce using rule 46 (modifier -> FINAL .)
    SET_TYPE        reduce using rule 46 (modifier -> FINAL .)
    DYNAMIC_TYPE    reduce using rule 46 (modifier -> FINAL .)
    VOID            reduce using rule 46 (modifier -> FINAL .)


state 36

    (47) modifier -> CONST .

    INTEGER_TYPE    reduce using rule 47 (modifier -> CONST .)
    DOUBLE_TYPE     reduce using rule 47 (modifier -> CONST .)
    BOOLEAN_TYPE    reduce using rule 47 (modifier -> CONST .)
    QUEUE_TYPE      reduce using rule 47 (modifier -> CONST .)
    STRING_TYPE     reduce using rule 47 (modifier -> CONST .)
    ENUM_TYPE       reduce using rule 47 (modifier -> CONST .)
    VAR             reduce using rule 47 (modifier -> CONST .)
    LIST_TYPE       reduce using rule 47 (modifier -> CONST .)
    MAP_TYPE        reduce using rule 47 (modifier -> CONST .)
    SET_TYPE        reduce using rule 47 (modifier -> CONST .)
    DYNAMIC_TYPE    reduce using rule 47 (modifier -> CONST .)
    VOID            reduce using rule 47 (modifier -> CONST .)


state 37

    (57) type -> INTEGER_TYPE .
    (35) number_type -> INTEGER_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 35 (number_type -> INTEGER_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 35 (number_type -> INTEGER_TYPE .)
    ASSIGN          reduce using rule 57 (type -> INTEGER_TYPE .)
    IDENTIFIER      reduce using rule 35 (number_type -> INTEGER_TYPE .)
    QUESTION_MARK   reduce using rule 35 (number_type -> INTEGER_TYPE .)

  ! IDENTIFIER      [ reduce using rule 57 (type -> INTEGER_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 57 (type -> INTEGER_TYPE .) ]


state 38

    (58) type -> DOUBLE_TYPE .
    (37) number_type -> DOUBLE_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 37 (number_type -> DOUBLE_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 37 (number_type -> DOUBLE_TYPE .)
    ASSIGN          reduce using rule 58 (type -> DOUBLE_TYPE .)
    IDENTIFIER      reduce using rule 37 (number_type -> DOUBLE_TYPE .)
    QUESTION_MARK   reduce using rule 37 (number_type -> DOUBLE_TYPE .)

  ! IDENTIFIER      [ reduce using rule 58 (type -> DOUBLE_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 58 (type -> DOUBLE_TYPE .) ]


state 39

    (59) type -> BOOLEAN_TYPE .

    IDENTIFIER      reduce using rule 59 (type -> BOOLEAN_TYPE .)
    ASSIGN          reduce using rule 59 (type -> BOOLEAN_TYPE .)
    QUESTION_MARK   reduce using rule 59 (type -> BOOLEAN_TYPE .)
    COMMA           reduce using rule 59 (type -> BOOLEAN_TYPE .)
    COLON           reduce using rule 59 (type -> BOOLEAN_TYPE .)
    GREATER         reduce using rule 59 (type -> BOOLEAN_TYPE .)
    RBRACE          reduce using rule 59 (type -> BOOLEAN_TYPE .)


state 40

    (60) type -> QUEUE_TYPE .

    IDENTIFIER      reduce using rule 60 (type -> QUEUE_TYPE .)
    ASSIGN          reduce using rule 60 (type -> QUEUE_TYPE .)
    QUESTION_MARK   reduce using rule 60 (type -> QUEUE_TYPE .)
    COMMA           reduce using rule 60 (type -> QUEUE_TYPE .)
    COLON           reduce using rule 60 (type -> QUEUE_TYPE .)
    GREATER         reduce using rule 60 (type -> QUEUE_TYPE .)
    RBRACE          reduce using rule 60 (type -> QUEUE_TYPE .)


state 41

    (61) type -> STRING_TYPE .
    (38) type_string -> STRING_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 38 (type_string -> STRING_TYPE .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 38 (type_string -> STRING_TYPE .)
    ASSIGN          reduce using rule 61 (type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 38 (type_string -> STRING_TYPE .)
    QUESTION_MARK   reduce using rule 38 (type_string -> STRING_TYPE .)

  ! IDENTIFIER      [ reduce using rule 61 (type -> STRING_TYPE .) ]
  ! QUESTION_MARK   [ reduce using rule 61 (type -> STRING_TYPE .) ]


state 42

    (62) type -> ENUM_TYPE .

    IDENTIFIER      reduce using rule 62 (type -> ENUM_TYPE .)
    ASSIGN          reduce using rule 62 (type -> ENUM_TYPE .)
    QUESTION_MARK   reduce using rule 62 (type -> ENUM_TYPE .)
    COMMA           reduce using rule 62 (type -> ENUM_TYPE .)
    COLON           reduce using rule 62 (type -> ENUM_TYPE .)
    GREATER         reduce using rule 62 (type -> ENUM_TYPE .)
    RBRACE          reduce using rule 62 (type -> ENUM_TYPE .)


state 43

    (63) type -> VAR .
    (36) number_type -> VAR .
    (39) type_string -> VAR .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (number_type -> VAR .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 36 (number_type -> VAR .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (number_type -> VAR .)
  ! reduce/reduce conflict for QUESTION_MARK resolved using rule 36 (number_type -> VAR .)
    ASSIGN          reduce using rule 63 (type -> VAR .)
    IDENTIFIER      reduce using rule 36 (number_type -> VAR .)
    QUESTION_MARK   reduce using rule 36 (number_type -> VAR .)

  ! IDENTIFIER      [ reduce using rule 63 (type -> VAR .) ]
  ! QUESTION_MARK   [ reduce using rule 63 (type -> VAR .) ]
  ! IDENTIFIER      [ reduce using rule 39 (type_string -> VAR .) ]
  ! QUESTION_MARK   [ reduce using rule 39 (type_string -> VAR .) ]


state 44

    (64) type -> LIST_TYPE .

    IDENTIFIER      reduce using rule 64 (type -> LIST_TYPE .)
    ASSIGN          reduce using rule 64 (type -> LIST_TYPE .)
    QUESTION_MARK   reduce using rule 64 (type -> LIST_TYPE .)
    COMMA           reduce using rule 64 (type -> LIST_TYPE .)
    COLON           reduce using rule 64 (type -> LIST_TYPE .)
    GREATER         reduce using rule 64 (type -> LIST_TYPE .)
    RBRACE          reduce using rule 64 (type -> LIST_TYPE .)


state 45

    (65) type -> MAP_TYPE .
    (139) map -> MAP_TYPE . LESS type COMMA type GREATER
    (140) map -> MAP_TYPE .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 65 (type -> MAP_TYPE .)
    IDENTIFIER      reduce using rule 65 (type -> MAP_TYPE .)
    ASSIGN          reduce using rule 65 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 65 (type -> MAP_TYPE .)
    LESS            shift and go to state 115

  ! IDENTIFIER      [ reduce using rule 140 (map -> MAP_TYPE .) ]


state 46

    (66) type -> SET_TYPE .

    IDENTIFIER      reduce using rule 66 (type -> SET_TYPE .)
    ASSIGN          reduce using rule 66 (type -> SET_TYPE .)
    QUESTION_MARK   reduce using rule 66 (type -> SET_TYPE .)
    COMMA           reduce using rule 66 (type -> SET_TYPE .)
    COLON           reduce using rule 66 (type -> SET_TYPE .)
    GREATER         reduce using rule 66 (type -> SET_TYPE .)
    RBRACE          reduce using rule 66 (type -> SET_TYPE .)


state 47

    (67) type -> DYNAMIC_TYPE .

    IDENTIFIER      reduce using rule 67 (type -> DYNAMIC_TYPE .)
    ASSIGN          reduce using rule 67 (type -> DYNAMIC_TYPE .)
    QUESTION_MARK   reduce using rule 67 (type -> DYNAMIC_TYPE .)
    COMMA           reduce using rule 67 (type -> DYNAMIC_TYPE .)
    COLON           reduce using rule 67 (type -> DYNAMIC_TYPE .)
    GREATER         reduce using rule 67 (type -> DYNAMIC_TYPE .)
    RBRACE          reduce using rule 67 (type -> DYNAMIC_TYPE .)


state 48

    (68) type -> VOID .

    IDENTIFIER      reduce using rule 68 (type -> VOID .)
    ASSIGN          reduce using rule 68 (type -> VOID .)
    QUESTION_MARK   reduce using rule 68 (type -> VOID .)
    COMMA           reduce using rule 68 (type -> VOID .)
    COLON           reduce using rule 68 (type -> VOID .)
    GREATER         reduce using rule 68 (type -> VOID .)
    RBRACE          reduce using rule 68 (type -> VOID .)


state 49

    (21) int_assignment -> number_type . IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> number_type . IDENTIFIER ASSIGN arithmetic
    (24) int_assignment -> number_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (26) int_assignment -> number_type . nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 116
    QUESTION_MARK   shift and go to state 86

    nullable                       shift and go to state 117

state 50

    (28) string_assignment -> type_string . IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> type_string . IDENTIFIER ASSIGN concate
    (31) string_assignment -> type_string . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (33) string_assignment -> type_string . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 118
    QUESTION_MARK   shift and go to state 86

    nullable                       shift and go to state 119

state 51

    (141) map_assigment -> map . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> map . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON

    IDENTIFIER      shift and go to state 120


state 52

    (110) number -> INTEGER .

    DIVIDE          reduce using rule 110 (number -> INTEGER .)
    EQUAL           reduce using rule 110 (number -> INTEGER .)
    NOT_EQUAL       reduce using rule 110 (number -> INTEGER .)
    LESS            reduce using rule 110 (number -> INTEGER .)
    LESS_EQUAL      reduce using rule 110 (number -> INTEGER .)
    GREATER         reduce using rule 110 (number -> INTEGER .)
    GREATER_EQUAL   reduce using rule 110 (number -> INTEGER .)
    PLUS            reduce using rule 110 (number -> INTEGER .)
    MINUS           reduce using rule 110 (number -> INTEGER .)
    TIMES           reduce using rule 110 (number -> INTEGER .)
    $end            reduce using rule 110 (number -> INTEGER .)
    SEMICOLON       reduce using rule 110 (number -> INTEGER .)
    RPAREN          reduce using rule 110 (number -> INTEGER .)
    LINE_BREAK      reduce using rule 110 (number -> INTEGER .)
    PRINT           reduce using rule 110 (number -> INTEGER .)
    IF              reduce using rule 110 (number -> INTEGER .)
    WHILE           reduce using rule 110 (number -> INTEGER .)
    FOR             reduce using rule 110 (number -> INTEGER .)
    IDENTIFIER      reduce using rule 110 (number -> INTEGER .)
    FINAL           reduce using rule 110 (number -> INTEGER .)
    CONST           reduce using rule 110 (number -> INTEGER .)
    INTEGER_TYPE    reduce using rule 110 (number -> INTEGER .)
    DOUBLE_TYPE     reduce using rule 110 (number -> INTEGER .)
    BOOLEAN_TYPE    reduce using rule 110 (number -> INTEGER .)
    QUEUE_TYPE      reduce using rule 110 (number -> INTEGER .)
    STRING_TYPE     reduce using rule 110 (number -> INTEGER .)
    ENUM_TYPE       reduce using rule 110 (number -> INTEGER .)
    VAR             reduce using rule 110 (number -> INTEGER .)
    LIST_TYPE       reduce using rule 110 (number -> INTEGER .)
    MAP_TYPE        reduce using rule 110 (number -> INTEGER .)
    SET_TYPE        reduce using rule 110 (number -> INTEGER .)
    DYNAMIC_TYPE    reduce using rule 110 (number -> INTEGER .)
    VOID            reduce using rule 110 (number -> INTEGER .)
    RBRACE          reduce using rule 110 (number -> INTEGER .)
    COMMA           reduce using rule 110 (number -> INTEGER .)
    LOGICAL_AND     reduce using rule 110 (number -> INTEGER .)
    LOGICAL_OR      reduce using rule 110 (number -> INTEGER .)
    RSQUARE         reduce using rule 110 (number -> INTEGER .)


state 53

    (111) number -> DOUBLE .

    DIVIDE          reduce using rule 111 (number -> DOUBLE .)
    EQUAL           reduce using rule 111 (number -> DOUBLE .)
    NOT_EQUAL       reduce using rule 111 (number -> DOUBLE .)
    LESS            reduce using rule 111 (number -> DOUBLE .)
    LESS_EQUAL      reduce using rule 111 (number -> DOUBLE .)
    GREATER         reduce using rule 111 (number -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 111 (number -> DOUBLE .)
    PLUS            reduce using rule 111 (number -> DOUBLE .)
    MINUS           reduce using rule 111 (number -> DOUBLE .)
    TIMES           reduce using rule 111 (number -> DOUBLE .)
    $end            reduce using rule 111 (number -> DOUBLE .)
    SEMICOLON       reduce using rule 111 (number -> DOUBLE .)
    RPAREN          reduce using rule 111 (number -> DOUBLE .)
    LINE_BREAK      reduce using rule 111 (number -> DOUBLE .)
    PRINT           reduce using rule 111 (number -> DOUBLE .)
    IF              reduce using rule 111 (number -> DOUBLE .)
    WHILE           reduce using rule 111 (number -> DOUBLE .)
    FOR             reduce using rule 111 (number -> DOUBLE .)
    IDENTIFIER      reduce using rule 111 (number -> DOUBLE .)
    FINAL           reduce using rule 111 (number -> DOUBLE .)
    CONST           reduce using rule 111 (number -> DOUBLE .)
    INTEGER_TYPE    reduce using rule 111 (number -> DOUBLE .)
    DOUBLE_TYPE     reduce using rule 111 (number -> DOUBLE .)
    BOOLEAN_TYPE    reduce using rule 111 (number -> DOUBLE .)
    QUEUE_TYPE      reduce using rule 111 (number -> DOUBLE .)
    STRING_TYPE     reduce using rule 111 (number -> DOUBLE .)
    ENUM_TYPE       reduce using rule 111 (number -> DOUBLE .)
    VAR             reduce using rule 111 (number -> DOUBLE .)
    LIST_TYPE       reduce using rule 111 (number -> DOUBLE .)
    MAP_TYPE        reduce using rule 111 (number -> DOUBLE .)
    SET_TYPE        reduce using rule 111 (number -> DOUBLE .)
    DYNAMIC_TYPE    reduce using rule 111 (number -> DOUBLE .)
    VOID            reduce using rule 111 (number -> DOUBLE .)
    RBRACE          reduce using rule 111 (number -> DOUBLE .)
    COMMA           reduce using rule 111 (number -> DOUBLE .)
    LOGICAL_AND     reduce using rule 111 (number -> DOUBLE .)
    LOGICAL_OR      reduce using rule 111 (number -> DOUBLE .)
    RSQUARE         reduce using rule 111 (number -> DOUBLE .)


state 54

    (112) string -> STRING .

    EQUAL           reduce using rule 112 (string -> STRING .)
    NOT_EQUAL       reduce using rule 112 (string -> STRING .)
    LESS            reduce using rule 112 (string -> STRING .)
    LESS_EQUAL      reduce using rule 112 (string -> STRING .)
    GREATER         reduce using rule 112 (string -> STRING .)
    GREATER_EQUAL   reduce using rule 112 (string -> STRING .)
    PLUS            reduce using rule 112 (string -> STRING .)
    $end            reduce using rule 112 (string -> STRING .)
    SEMICOLON       reduce using rule 112 (string -> STRING .)
    RPAREN          reduce using rule 112 (string -> STRING .)
    LINE_BREAK      reduce using rule 112 (string -> STRING .)
    PRINT           reduce using rule 112 (string -> STRING .)
    IF              reduce using rule 112 (string -> STRING .)
    WHILE           reduce using rule 112 (string -> STRING .)
    FOR             reduce using rule 112 (string -> STRING .)
    IDENTIFIER      reduce using rule 112 (string -> STRING .)
    FINAL           reduce using rule 112 (string -> STRING .)
    CONST           reduce using rule 112 (string -> STRING .)
    INTEGER_TYPE    reduce using rule 112 (string -> STRING .)
    DOUBLE_TYPE     reduce using rule 112 (string -> STRING .)
    BOOLEAN_TYPE    reduce using rule 112 (string -> STRING .)
    QUEUE_TYPE      reduce using rule 112 (string -> STRING .)
    STRING_TYPE     reduce using rule 112 (string -> STRING .)
    ENUM_TYPE       reduce using rule 112 (string -> STRING .)
    VAR             reduce using rule 112 (string -> STRING .)
    LIST_TYPE       reduce using rule 112 (string -> STRING .)
    MAP_TYPE        reduce using rule 112 (string -> STRING .)
    SET_TYPE        reduce using rule 112 (string -> STRING .)
    DYNAMIC_TYPE    reduce using rule 112 (string -> STRING .)
    VOID            reduce using rule 112 (string -> STRING .)
    RBRACE          reduce using rule 112 (string -> STRING .)
    COMMA           reduce using rule 112 (string -> STRING .)
    LOGICAL_AND     reduce using rule 112 (string -> STRING .)
    LOGICAL_OR      reduce using rule 112 (string -> STRING .)
    RSQUARE         reduce using rule 112 (string -> STRING .)


state 55

    (81) comparison -> int_comparison .

    LOGICAL_AND     reduce using rule 81 (comparison -> int_comparison .)
    LOGICAL_OR      reduce using rule 81 (comparison -> int_comparison .)
    $end            reduce using rule 81 (comparison -> int_comparison .)
    SEMICOLON       reduce using rule 81 (comparison -> int_comparison .)
    RPAREN          reduce using rule 81 (comparison -> int_comparison .)
    LINE_BREAK      reduce using rule 81 (comparison -> int_comparison .)
    PRINT           reduce using rule 81 (comparison -> int_comparison .)
    IF              reduce using rule 81 (comparison -> int_comparison .)
    WHILE           reduce using rule 81 (comparison -> int_comparison .)
    FOR             reduce using rule 81 (comparison -> int_comparison .)
    IDENTIFIER      reduce using rule 81 (comparison -> int_comparison .)
    FINAL           reduce using rule 81 (comparison -> int_comparison .)
    CONST           reduce using rule 81 (comparison -> int_comparison .)
    INTEGER_TYPE    reduce using rule 81 (comparison -> int_comparison .)
    DOUBLE_TYPE     reduce using rule 81 (comparison -> int_comparison .)
    BOOLEAN_TYPE    reduce using rule 81 (comparison -> int_comparison .)
    QUEUE_TYPE      reduce using rule 81 (comparison -> int_comparison .)
    STRING_TYPE     reduce using rule 81 (comparison -> int_comparison .)
    ENUM_TYPE       reduce using rule 81 (comparison -> int_comparison .)
    VAR             reduce using rule 81 (comparison -> int_comparison .)
    LIST_TYPE       reduce using rule 81 (comparison -> int_comparison .)
    MAP_TYPE        reduce using rule 81 (comparison -> int_comparison .)
    SET_TYPE        reduce using rule 81 (comparison -> int_comparison .)
    DYNAMIC_TYPE    reduce using rule 81 (comparison -> int_comparison .)
    VOID            reduce using rule 81 (comparison -> int_comparison .)
    RBRACE          reduce using rule 81 (comparison -> int_comparison .)


state 56

    (82) comparison -> string_comparison .

    LOGICAL_AND     reduce using rule 82 (comparison -> string_comparison .)
    LOGICAL_OR      reduce using rule 82 (comparison -> string_comparison .)
    $end            reduce using rule 82 (comparison -> string_comparison .)
    SEMICOLON       reduce using rule 82 (comparison -> string_comparison .)
    RPAREN          reduce using rule 82 (comparison -> string_comparison .)
    LINE_BREAK      reduce using rule 82 (comparison -> string_comparison .)
    PRINT           reduce using rule 82 (comparison -> string_comparison .)
    IF              reduce using rule 82 (comparison -> string_comparison .)
    WHILE           reduce using rule 82 (comparison -> string_comparison .)
    FOR             reduce using rule 82 (comparison -> string_comparison .)
    IDENTIFIER      reduce using rule 82 (comparison -> string_comparison .)
    FINAL           reduce using rule 82 (comparison -> string_comparison .)
    CONST           reduce using rule 82 (comparison -> string_comparison .)
    INTEGER_TYPE    reduce using rule 82 (comparison -> string_comparison .)
    DOUBLE_TYPE     reduce using rule 82 (comparison -> string_comparison .)
    BOOLEAN_TYPE    reduce using rule 82 (comparison -> string_comparison .)
    QUEUE_TYPE      reduce using rule 82 (comparison -> string_comparison .)
    STRING_TYPE     reduce using rule 82 (comparison -> string_comparison .)
    ENUM_TYPE       reduce using rule 82 (comparison -> string_comparison .)
    VAR             reduce using rule 82 (comparison -> string_comparison .)
    LIST_TYPE       reduce using rule 82 (comparison -> string_comparison .)
    MAP_TYPE        reduce using rule 82 (comparison -> string_comparison .)
    SET_TYPE        reduce using rule 82 (comparison -> string_comparison .)
    DYNAMIC_TYPE    reduce using rule 82 (comparison -> string_comparison .)
    VOID            reduce using rule 82 (comparison -> string_comparison .)
    RBRACE          reduce using rule 82 (comparison -> string_comparison .)


state 57

    (83) int_comparison -> boolean .
    (86) string_comparison -> boolean .

  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for $end resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for RPAREN resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for LINE_BREAK resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for PRINT resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for IF resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for WHILE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for FOR resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for FINAL resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for CONST resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for INTEGER_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for BOOLEAN_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for QUEUE_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for ENUM_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for VAR resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for DYNAMIC_TYPE resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for VOID resolved using rule 83 (int_comparison -> boolean .)
  ! reduce/reduce conflict for RBRACE resolved using rule 83 (int_comparison -> boolean .)
    LOGICAL_AND     reduce using rule 83 (int_comparison -> boolean .)
    LOGICAL_OR      reduce using rule 83 (int_comparison -> boolean .)
    $end            reduce using rule 83 (int_comparison -> boolean .)
    SEMICOLON       reduce using rule 83 (int_comparison -> boolean .)
    RPAREN          reduce using rule 83 (int_comparison -> boolean .)
    LINE_BREAK      reduce using rule 83 (int_comparison -> boolean .)
    PRINT           reduce using rule 83 (int_comparison -> boolean .)
    IF              reduce using rule 83 (int_comparison -> boolean .)
    WHILE           reduce using rule 83 (int_comparison -> boolean .)
    FOR             reduce using rule 83 (int_comparison -> boolean .)
    IDENTIFIER      reduce using rule 83 (int_comparison -> boolean .)
    FINAL           reduce using rule 83 (int_comparison -> boolean .)
    CONST           reduce using rule 83 (int_comparison -> boolean .)
    INTEGER_TYPE    reduce using rule 83 (int_comparison -> boolean .)
    DOUBLE_TYPE     reduce using rule 83 (int_comparison -> boolean .)
    BOOLEAN_TYPE    reduce using rule 83 (int_comparison -> boolean .)
    QUEUE_TYPE      reduce using rule 83 (int_comparison -> boolean .)
    STRING_TYPE     reduce using rule 83 (int_comparison -> boolean .)
    ENUM_TYPE       reduce using rule 83 (int_comparison -> boolean .)
    VAR             reduce using rule 83 (int_comparison -> boolean .)
    LIST_TYPE       reduce using rule 83 (int_comparison -> boolean .)
    MAP_TYPE        reduce using rule 83 (int_comparison -> boolean .)
    SET_TYPE        reduce using rule 83 (int_comparison -> boolean .)
    DYNAMIC_TYPE    reduce using rule 83 (int_comparison -> boolean .)
    VOID            reduce using rule 83 (int_comparison -> boolean .)
    RBRACE          reduce using rule 83 (int_comparison -> boolean .)

  ! LOGICAL_AND     [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! LOGICAL_OR      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! $end            [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! SEMICOLON       [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! RPAREN          [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! LINE_BREAK      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! PRINT           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! IF              [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! WHILE           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! FOR             [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! IDENTIFIER      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! FINAL           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! CONST           [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! INTEGER_TYPE    [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! DOUBLE_TYPE     [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! BOOLEAN_TYPE    [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! QUEUE_TYPE      [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! STRING_TYPE     [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! ENUM_TYPE       [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! VAR             [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! LIST_TYPE       [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! MAP_TYPE        [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! SET_TYPE        [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! DYNAMIC_TYPE    [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! VOID            [ reduce using rule 86 (string_comparison -> boolean .) ]
  ! RBRACE          [ reduce using rule 86 (string_comparison -> boolean .) ]


state 58

    (113) boolean -> TRUE .

    LOGICAL_AND     reduce using rule 113 (boolean -> TRUE .)
    LOGICAL_OR      reduce using rule 113 (boolean -> TRUE .)
    $end            reduce using rule 113 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 113 (boolean -> TRUE .)
    RPAREN          reduce using rule 113 (boolean -> TRUE .)
    LINE_BREAK      reduce using rule 113 (boolean -> TRUE .)
    PRINT           reduce using rule 113 (boolean -> TRUE .)
    IF              reduce using rule 113 (boolean -> TRUE .)
    WHILE           reduce using rule 113 (boolean -> TRUE .)
    FOR             reduce using rule 113 (boolean -> TRUE .)
    IDENTIFIER      reduce using rule 113 (boolean -> TRUE .)
    FINAL           reduce using rule 113 (boolean -> TRUE .)
    CONST           reduce using rule 113 (boolean -> TRUE .)
    INTEGER_TYPE    reduce using rule 113 (boolean -> TRUE .)
    DOUBLE_TYPE     reduce using rule 113 (boolean -> TRUE .)
    BOOLEAN_TYPE    reduce using rule 113 (boolean -> TRUE .)
    QUEUE_TYPE      reduce using rule 113 (boolean -> TRUE .)
    STRING_TYPE     reduce using rule 113 (boolean -> TRUE .)
    ENUM_TYPE       reduce using rule 113 (boolean -> TRUE .)
    VAR             reduce using rule 113 (boolean -> TRUE .)
    LIST_TYPE       reduce using rule 113 (boolean -> TRUE .)
    MAP_TYPE        reduce using rule 113 (boolean -> TRUE .)
    SET_TYPE        reduce using rule 113 (boolean -> TRUE .)
    DYNAMIC_TYPE    reduce using rule 113 (boolean -> TRUE .)
    VOID            reduce using rule 113 (boolean -> TRUE .)
    RBRACE          reduce using rule 113 (boolean -> TRUE .)


state 59

    (114) boolean -> FALSE .

    LOGICAL_AND     reduce using rule 114 (boolean -> FALSE .)
    LOGICAL_OR      reduce using rule 114 (boolean -> FALSE .)
    $end            reduce using rule 114 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 114 (boolean -> FALSE .)
    RPAREN          reduce using rule 114 (boolean -> FALSE .)
    LINE_BREAK      reduce using rule 114 (boolean -> FALSE .)
    PRINT           reduce using rule 114 (boolean -> FALSE .)
    IF              reduce using rule 114 (boolean -> FALSE .)
    WHILE           reduce using rule 114 (boolean -> FALSE .)
    FOR             reduce using rule 114 (boolean -> FALSE .)
    IDENTIFIER      reduce using rule 114 (boolean -> FALSE .)
    FINAL           reduce using rule 114 (boolean -> FALSE .)
    CONST           reduce using rule 114 (boolean -> FALSE .)
    INTEGER_TYPE    reduce using rule 114 (boolean -> FALSE .)
    DOUBLE_TYPE     reduce using rule 114 (boolean -> FALSE .)
    BOOLEAN_TYPE    reduce using rule 114 (boolean -> FALSE .)
    QUEUE_TYPE      reduce using rule 114 (boolean -> FALSE .)
    STRING_TYPE     reduce using rule 114 (boolean -> FALSE .)
    ENUM_TYPE       reduce using rule 114 (boolean -> FALSE .)
    VAR             reduce using rule 114 (boolean -> FALSE .)
    LIST_TYPE       reduce using rule 114 (boolean -> FALSE .)
    MAP_TYPE        reduce using rule 114 (boolean -> FALSE .)
    SET_TYPE        reduce using rule 114 (boolean -> FALSE .)
    DYNAMIC_TYPE    reduce using rule 114 (boolean -> FALSE .)
    VOID            reduce using rule 114 (boolean -> FALSE .)
    RBRACE          reduce using rule 114 (boolean -> FALSE .)


state 60

    (51) if_statement -> if_statement ELSE . if_statement
    (52) if_statement -> if_statement ELSE . LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE

    LBRACE          shift and go to state 122
    IF              shift and go to state 26

    if_statement                   shift and go to state 121

state 61

    (9) statement -> LBRACE lines . RBRACE

    RBRACE          shift and go to state 123


state 62

    (125) line -> print .

    LINE_BREAK      reduce using rule 125 (line -> print .)
    PRINT           reduce using rule 125 (line -> print .)
    IF              reduce using rule 125 (line -> print .)
    WHILE           reduce using rule 125 (line -> print .)
    FOR             reduce using rule 125 (line -> print .)
    IDENTIFIER      reduce using rule 125 (line -> print .)
    FINAL           reduce using rule 125 (line -> print .)
    CONST           reduce using rule 125 (line -> print .)
    INTEGER_TYPE    reduce using rule 125 (line -> print .)
    DOUBLE_TYPE     reduce using rule 125 (line -> print .)
    BOOLEAN_TYPE    reduce using rule 125 (line -> print .)
    QUEUE_TYPE      reduce using rule 125 (line -> print .)
    STRING_TYPE     reduce using rule 125 (line -> print .)
    ENUM_TYPE       reduce using rule 125 (line -> print .)
    VAR             reduce using rule 125 (line -> print .)
    LIST_TYPE       reduce using rule 125 (line -> print .)
    MAP_TYPE        reduce using rule 125 (line -> print .)
    SET_TYPE        reduce using rule 125 (line -> print .)
    DYNAMIC_TYPE    reduce using rule 125 (line -> print .)
    VOID            reduce using rule 125 (line -> print .)
    RBRACE          reduce using rule 125 (line -> print .)
    $end            reduce using rule 125 (line -> print .)


state 63

    (126) line -> assignment .

    LINE_BREAK      reduce using rule 126 (line -> assignment .)
    PRINT           reduce using rule 126 (line -> assignment .)
    IF              reduce using rule 126 (line -> assignment .)
    WHILE           reduce using rule 126 (line -> assignment .)
    FOR             reduce using rule 126 (line -> assignment .)
    IDENTIFIER      reduce using rule 126 (line -> assignment .)
    FINAL           reduce using rule 126 (line -> assignment .)
    CONST           reduce using rule 126 (line -> assignment .)
    INTEGER_TYPE    reduce using rule 126 (line -> assignment .)
    DOUBLE_TYPE     reduce using rule 126 (line -> assignment .)
    BOOLEAN_TYPE    reduce using rule 126 (line -> assignment .)
    QUEUE_TYPE      reduce using rule 126 (line -> assignment .)
    STRING_TYPE     reduce using rule 126 (line -> assignment .)
    ENUM_TYPE       reduce using rule 126 (line -> assignment .)
    VAR             reduce using rule 126 (line -> assignment .)
    LIST_TYPE       reduce using rule 126 (line -> assignment .)
    MAP_TYPE        reduce using rule 126 (line -> assignment .)
    SET_TYPE        reduce using rule 126 (line -> assignment .)
    DYNAMIC_TYPE    reduce using rule 126 (line -> assignment .)
    VOID            reduce using rule 126 (line -> assignment .)
    RBRACE          reduce using rule 126 (line -> assignment .)
    $end            reduce using rule 126 (line -> assignment .)


state 64

    (127) line -> function .

    LINE_BREAK      reduce using rule 127 (line -> function .)
    PRINT           reduce using rule 127 (line -> function .)
    IF              reduce using rule 127 (line -> function .)
    WHILE           reduce using rule 127 (line -> function .)
    FOR             reduce using rule 127 (line -> function .)
    IDENTIFIER      reduce using rule 127 (line -> function .)
    FINAL           reduce using rule 127 (line -> function .)
    CONST           reduce using rule 127 (line -> function .)
    INTEGER_TYPE    reduce using rule 127 (line -> function .)
    DOUBLE_TYPE     reduce using rule 127 (line -> function .)
    BOOLEAN_TYPE    reduce using rule 127 (line -> function .)
    QUEUE_TYPE      reduce using rule 127 (line -> function .)
    STRING_TYPE     reduce using rule 127 (line -> function .)
    ENUM_TYPE       reduce using rule 127 (line -> function .)
    VAR             reduce using rule 127 (line -> function .)
    LIST_TYPE       reduce using rule 127 (line -> function .)
    MAP_TYPE        reduce using rule 127 (line -> function .)
    SET_TYPE        reduce using rule 127 (line -> function .)
    DYNAMIC_TYPE    reduce using rule 127 (line -> function .)
    VOID            reduce using rule 127 (line -> function .)
    RBRACE          reduce using rule 127 (line -> function .)
    $end            reduce using rule 127 (line -> function .)


state 65

    (128) line -> if_statement .
    (51) if_statement -> if_statement . ELSE if_statement
    (52) if_statement -> if_statement . ELSE LBRACE lines RBRACE

    LINE_BREAK      reduce using rule 128 (line -> if_statement .)
    PRINT           reduce using rule 128 (line -> if_statement .)
    IF              reduce using rule 128 (line -> if_statement .)
    WHILE           reduce using rule 128 (line -> if_statement .)
    FOR             reduce using rule 128 (line -> if_statement .)
    IDENTIFIER      reduce using rule 128 (line -> if_statement .)
    FINAL           reduce using rule 128 (line -> if_statement .)
    CONST           reduce using rule 128 (line -> if_statement .)
    INTEGER_TYPE    reduce using rule 128 (line -> if_statement .)
    DOUBLE_TYPE     reduce using rule 128 (line -> if_statement .)
    BOOLEAN_TYPE    reduce using rule 128 (line -> if_statement .)
    QUEUE_TYPE      reduce using rule 128 (line -> if_statement .)
    STRING_TYPE     reduce using rule 128 (line -> if_statement .)
    ENUM_TYPE       reduce using rule 128 (line -> if_statement .)
    VAR             reduce using rule 128 (line -> if_statement .)
    LIST_TYPE       reduce using rule 128 (line -> if_statement .)
    MAP_TYPE        reduce using rule 128 (line -> if_statement .)
    SET_TYPE        reduce using rule 128 (line -> if_statement .)
    DYNAMIC_TYPE    reduce using rule 128 (line -> if_statement .)
    VOID            reduce using rule 128 (line -> if_statement .)
    RBRACE          reduce using rule 128 (line -> if_statement .)
    $end            reduce using rule 128 (line -> if_statement .)
    ELSE            shift and go to state 60


state 66

    (129) line -> while_statement .

    LINE_BREAK      reduce using rule 129 (line -> while_statement .)
    PRINT           reduce using rule 129 (line -> while_statement .)
    IF              reduce using rule 129 (line -> while_statement .)
    WHILE           reduce using rule 129 (line -> while_statement .)
    FOR             reduce using rule 129 (line -> while_statement .)
    IDENTIFIER      reduce using rule 129 (line -> while_statement .)
    FINAL           reduce using rule 129 (line -> while_statement .)
    CONST           reduce using rule 129 (line -> while_statement .)
    INTEGER_TYPE    reduce using rule 129 (line -> while_statement .)
    DOUBLE_TYPE     reduce using rule 129 (line -> while_statement .)
    BOOLEAN_TYPE    reduce using rule 129 (line -> while_statement .)
    QUEUE_TYPE      reduce using rule 129 (line -> while_statement .)
    STRING_TYPE     reduce using rule 129 (line -> while_statement .)
    ENUM_TYPE       reduce using rule 129 (line -> while_statement .)
    VAR             reduce using rule 129 (line -> while_statement .)
    LIST_TYPE       reduce using rule 129 (line -> while_statement .)
    MAP_TYPE        reduce using rule 129 (line -> while_statement .)
    SET_TYPE        reduce using rule 129 (line -> while_statement .)
    DYNAMIC_TYPE    reduce using rule 129 (line -> while_statement .)
    VOID            reduce using rule 129 (line -> while_statement .)
    RBRACE          reduce using rule 129 (line -> while_statement .)
    $end            reduce using rule 129 (line -> while_statement .)


state 67

    (130) line -> for_statement .

    LINE_BREAK      reduce using rule 130 (line -> for_statement .)
    PRINT           reduce using rule 130 (line -> for_statement .)
    IF              reduce using rule 130 (line -> for_statement .)
    WHILE           reduce using rule 130 (line -> for_statement .)
    FOR             reduce using rule 130 (line -> for_statement .)
    IDENTIFIER      reduce using rule 130 (line -> for_statement .)
    FINAL           reduce using rule 130 (line -> for_statement .)
    CONST           reduce using rule 130 (line -> for_statement .)
    INTEGER_TYPE    reduce using rule 130 (line -> for_statement .)
    DOUBLE_TYPE     reduce using rule 130 (line -> for_statement .)
    BOOLEAN_TYPE    reduce using rule 130 (line -> for_statement .)
    QUEUE_TYPE      reduce using rule 130 (line -> for_statement .)
    STRING_TYPE     reduce using rule 130 (line -> for_statement .)
    ENUM_TYPE       reduce using rule 130 (line -> for_statement .)
    VAR             reduce using rule 130 (line -> for_statement .)
    LIST_TYPE       reduce using rule 130 (line -> for_statement .)
    MAP_TYPE        reduce using rule 130 (line -> for_statement .)
    SET_TYPE        reduce using rule 130 (line -> for_statement .)
    DYNAMIC_TYPE    reduce using rule 130 (line -> for_statement .)
    VOID            reduce using rule 130 (line -> for_statement .)
    RBRACE          reduce using rule 130 (line -> for_statement .)
    $end            reduce using rule 130 (line -> for_statement .)


state 68

    (131) line -> function_call .

    LINE_BREAK      reduce using rule 131 (line -> function_call .)
    PRINT           reduce using rule 131 (line -> function_call .)
    IF              reduce using rule 131 (line -> function_call .)
    WHILE           reduce using rule 131 (line -> function_call .)
    FOR             reduce using rule 131 (line -> function_call .)
    IDENTIFIER      reduce using rule 131 (line -> function_call .)
    FINAL           reduce using rule 131 (line -> function_call .)
    CONST           reduce using rule 131 (line -> function_call .)
    INTEGER_TYPE    reduce using rule 131 (line -> function_call .)
    DOUBLE_TYPE     reduce using rule 131 (line -> function_call .)
    BOOLEAN_TYPE    reduce using rule 131 (line -> function_call .)
    QUEUE_TYPE      reduce using rule 131 (line -> function_call .)
    STRING_TYPE     reduce using rule 131 (line -> function_call .)
    ENUM_TYPE       reduce using rule 131 (line -> function_call .)
    VAR             reduce using rule 131 (line -> function_call .)
    LIST_TYPE       reduce using rule 131 (line -> function_call .)
    MAP_TYPE        reduce using rule 131 (line -> function_call .)
    SET_TYPE        reduce using rule 131 (line -> function_call .)
    DYNAMIC_TYPE    reduce using rule 131 (line -> function_call .)
    VOID            reduce using rule 131 (line -> function_call .)
    RBRACE          reduce using rule 131 (line -> function_call .)
    $end            reduce using rule 131 (line -> function_call .)


state 69

    (132) line -> reassignment .

    LINE_BREAK      reduce using rule 132 (line -> reassignment .)
    PRINT           reduce using rule 132 (line -> reassignment .)
    IF              reduce using rule 132 (line -> reassignment .)
    WHILE           reduce using rule 132 (line -> reassignment .)
    FOR             reduce using rule 132 (line -> reassignment .)
    IDENTIFIER      reduce using rule 132 (line -> reassignment .)
    FINAL           reduce using rule 132 (line -> reassignment .)
    CONST           reduce using rule 132 (line -> reassignment .)
    INTEGER_TYPE    reduce using rule 132 (line -> reassignment .)
    DOUBLE_TYPE     reduce using rule 132 (line -> reassignment .)
    BOOLEAN_TYPE    reduce using rule 132 (line -> reassignment .)
    QUEUE_TYPE      reduce using rule 132 (line -> reassignment .)
    STRING_TYPE     reduce using rule 132 (line -> reassignment .)
    ENUM_TYPE       reduce using rule 132 (line -> reassignment .)
    VAR             reduce using rule 132 (line -> reassignment .)
    LIST_TYPE       reduce using rule 132 (line -> reassignment .)
    MAP_TYPE        reduce using rule 132 (line -> reassignment .)
    SET_TYPE        reduce using rule 132 (line -> reassignment .)
    DYNAMIC_TYPE    reduce using rule 132 (line -> reassignment .)
    VOID            reduce using rule 132 (line -> reassignment .)
    RBRACE          reduce using rule 132 (line -> reassignment .)
    $end            reduce using rule 132 (line -> reassignment .)


state 70

    (53) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN values RPAREN
    (55) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER . LPAREN RPAREN
    (40) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (43) reassignment -> IDENTIFIER . INLINE_ARITH number
    (44) reassignment -> IDENTIFIER . INLINE_ARITH
    (117) list_assigment -> IDENTIFIER . ASSIGN list SEMICOLON
    (143) map_assigment -> IDENTIFIER . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON

    LPAREN          shift and go to state 90
    ASSIGN          shift and go to state 88
    INLINE_ARITH    shift and go to state 89
    IDENTIFIER      shift and go to state 87


state 71

    (75) arithmetic -> arithmetic arith_op . arithmetic
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 126
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 124
    number                         shift and go to state 125

state 72

    (95) arith_op -> PLUS .

    LPAREN          reduce using rule 95 (arith_op -> PLUS .)
    INTEGER         reduce using rule 95 (arith_op -> PLUS .)
    DOUBLE          reduce using rule 95 (arith_op -> PLUS .)


state 73

    (96) arith_op -> MINUS .

    LPAREN          reduce using rule 96 (arith_op -> MINUS .)
    INTEGER         reduce using rule 96 (arith_op -> MINUS .)
    DOUBLE          reduce using rule 96 (arith_op -> MINUS .)


state 74

    (97) arith_op -> TIMES .

    LPAREN          reduce using rule 97 (arith_op -> TIMES .)
    INTEGER         reduce using rule 97 (arith_op -> TIMES .)
    DOUBLE          reduce using rule 97 (arith_op -> TIMES .)


state 75

    (79) concate -> concate PLUS . concate
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 129
    STRING          shift and go to state 54

    concate                        shift and go to state 127
    string                         shift and go to state 128

state 76

    (90) logic -> logic logic_op . logic
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 112
    LOGICAL_NOT     shift and go to state 34
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54

    logic                          shift and go to state 130
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57
    number                         shift and go to state 113
    string                         shift and go to state 114

state 77

    (93) logic_op -> LOGICAL_AND .

    LPAREN          reduce using rule 93 (logic_op -> LOGICAL_AND .)
    LOGICAL_NOT     reduce using rule 93 (logic_op -> LOGICAL_AND .)
    TRUE            reduce using rule 93 (logic_op -> LOGICAL_AND .)
    FALSE           reduce using rule 93 (logic_op -> LOGICAL_AND .)
    INTEGER         reduce using rule 93 (logic_op -> LOGICAL_AND .)
    DOUBLE          reduce using rule 93 (logic_op -> LOGICAL_AND .)
    STRING          reduce using rule 93 (logic_op -> LOGICAL_AND .)


state 78

    (94) logic_op -> LOGICAL_OR .

    LPAREN          reduce using rule 94 (logic_op -> LOGICAL_OR .)
    LOGICAL_NOT     reduce using rule 94 (logic_op -> LOGICAL_OR .)
    TRUE            reduce using rule 94 (logic_op -> LOGICAL_OR .)
    FALSE           reduce using rule 94 (logic_op -> LOGICAL_OR .)
    INTEGER         reduce using rule 94 (logic_op -> LOGICAL_OR .)
    DOUBLE          reduce using rule 94 (logic_op -> LOGICAL_OR .)
    STRING          reduce using rule 94 (logic_op -> LOGICAL_OR .)


state 79

    (12) assignment -> modifier type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> modifier type . IDENTIFIER ASSIGN expression SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 132
    QUESTION_MARK   shift and go to state 86

    nullable                       shift and go to state 131

state 80

    (23) int_assignment -> modifier number_type . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier number_type . nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> modifier number_type . IDENTIFIER ASSIGN arithmetic SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 134
    QUESTION_MARK   shift and go to state 86

    nullable                       shift and go to state 133

state 81

    (30) string_assignment -> modifier type_string . nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier type_string . nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> modifier type_string . IDENTIFIER ASSIGN concate SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 136
    QUESTION_MARK   shift and go to state 86

    nullable                       shift and go to state 135

state 82

    (65) type -> MAP_TYPE .

    IDENTIFIER      reduce using rule 65 (type -> MAP_TYPE .)
    QUESTION_MARK   reduce using rule 65 (type -> MAP_TYPE .)
    COMMA           reduce using rule 65 (type -> MAP_TYPE .)
    COLON           reduce using rule 65 (type -> MAP_TYPE .)
    GREATER         reduce using rule 65 (type -> MAP_TYPE .)
    RBRACE          reduce using rule 65 (type -> MAP_TYPE .)


state 83

    (13) assignment -> type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 137


state 84

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression
    (119) function -> type IDENTIFIER . LPAREN parameters RPAREN LBRACE lines RBRACE

    ASSIGN          shift and go to state 138
    LPAREN          shift and go to state 139


state 85

    (118) list_assigment -> type ASSIGN . list SEMICOLON
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    LSQUARE         shift and go to state 141

    list                           shift and go to state 140

state 86

    (45) nullable -> QUESTION_MARK .

    IDENTIFIER      reduce using rule 45 (nullable -> QUESTION_MARK .)


state 87

    (143) map_assigment -> IDENTIFIER IDENTIFIER . ASSIGN LBRACE map_values RBRACE SEMICOLON

    ASSIGN          shift and go to state 142


state 88

    (40) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (117) list_assigment -> IDENTIFIER ASSIGN . list SEMICOLON
    (144) map_assigment -> IDENTIFIER ASSIGN . LBRACE RBRACE SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LBRACE          shift and go to state 146
    LSQUARE         shift and go to state 141
    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    IDENTIFIER      shift and go to state 143
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    expression                     shift and go to state 144
    list                           shift and go to state 145
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 147
    division                       shift and go to state 16
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 89

    (41) reassignment -> IDENTIFIER INLINE_ARITH . number SEMICOLON
    (42) reassignment -> IDENTIFIER INLINE_ARITH . SEMICOLON
    (43) reassignment -> IDENTIFIER INLINE_ARITH . number
    (44) reassignment -> IDENTIFIER INLINE_ARITH .
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    SEMICOLON       shift and go to state 149
    $end            reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LINE_BREAK      reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    PRINT           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IF              reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    WHILE           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FOR             reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    IDENTIFIER      reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    FINAL           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    CONST           reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER_TYPE    reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DOUBLE_TYPE     reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    BOOLEAN_TYPE    reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    QUEUE_TYPE      reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    STRING_TYPE     reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    ENUM_TYPE       reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VAR             reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    LIST_TYPE       reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    MAP_TYPE        reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    SET_TYPE        reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    DYNAMIC_TYPE    reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    VOID            reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RBRACE          reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    RPAREN          reduce using rule 44 (reassignment -> IDENTIFIER INLINE_ARITH .)
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 148

state 90

    (53) function_call -> IDENTIFIER LPAREN . values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN . values RPAREN
    (55) function_call -> IDENTIFIER LPAREN . RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER LPAREN . RPAREN
    (104) values -> . value
    (105) values -> . value COMMA values
    (106) value -> . IDENTIFIER
    (107) value -> . number
    (108) value -> . string
    (109) value -> . list
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    RPAREN          shift and go to state 152
    IDENTIFIER      shift and go to state 150
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 141

    values                         shift and go to state 151
    value                          shift and go to state 153
    number                         shift and go to state 154
    string                         shift and go to state 155
    list                           shift and go to state 156

state 91

    (48) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (49) print -> PRINT LPAREN . RPAREN SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    RPAREN          shift and go to state 158
    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    IDENTIFIER      shift and go to state 143
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    expression                     shift and go to state 157
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 147
    division                       shift and go to state 16
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 92

    (76) arithmetic -> LPAREN arithmetic . arith_op arithmetic RPAREN
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

    arith_op                       shift and go to state 159

state 93

    (80) concate -> LPAREN concate . PLUS concate RPAREN
    (79) concate -> concate . PLUS concate

    PLUS            shift and go to state 160


state 94

    (91) logic -> LPAREN logic . logic_op logic RPAREN
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

    logic_op                       shift and go to state 161

state 95

    (85) int_comparison -> LPAREN number . comp_op number RPAREN
    (74) arithmetic -> number .
    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 74 (arithmetic -> number .)
    MINUS           reduce using rule 74 (arithmetic -> number .)
    TIMES           reduce using rule 74 (arithmetic -> number .)
    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 162

state 96

    (88) string_comparison -> LPAREN string . comp_op string RPAREN
    (78) concate -> string .
    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    PLUS            reduce using rule 78 (concate -> string .)
    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 163

state 97

    (50) if_statement -> IF LPAREN . logic RPAREN LBRACE lines RBRACE
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 112
    LOGICAL_NOT     shift and go to state 34
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54

    logic                          shift and go to state 164
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57
    number                         shift and go to state 113
    string                         shift and go to state 114

state 98

    (153) while_statement -> WHILE LPAREN . logic RPAREN LBRACE lines RBRACE
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 112
    LOGICAL_NOT     shift and go to state 34
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54

    logic                          shift and go to state 165
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57
    number                         shift and go to state 113
    string                         shift and go to state 114

state 99

    (154) for_statement -> FOR LPAREN . assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48
    IDENTIFIER      shift and go to state 168

    assignment                     shift and go to state 166
    modifier                       shift and go to state 17
    type                           shift and go to state 167
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 100

    (120) lines -> line LINE_BREAK . lines
    (123) lines -> LINE_BREAK .
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

  ! reduce/reduce conflict for $end resolved using rule 123 (lines -> LINE_BREAK .)
  ! reduce/reduce conflict for RBRACE resolved using rule 123 (lines -> LINE_BREAK .)
    $end            reduce using rule 123 (lines -> LINE_BREAK .)
    RBRACE          reduce using rule 123 (lines -> LINE_BREAK .)
    LINE_BREAK      shift and go to state 30
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

  ! $end            [ reduce using rule 124 (lines -> .) ]
  ! RBRACE          [ reduce using rule 124 (lines -> .) ]

    line                           shift and go to state 29
    lines                          shift and go to state 169
    print                          shift and go to state 62
    assignment                     shift and go to state 63
    function                       shift and go to state 64
    if_statement                   shift and go to state 65
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    reassignment                   shift and go to state 69
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 101

    (121) lines -> line lines .

    $end            reduce using rule 121 (lines -> line lines .)
    RBRACE          reduce using rule 121 (lines -> line lines .)


state 102

    (77) division -> number DIVIDE . number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 170

state 103

    (84) int_comparison -> number comp_op . number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 171

state 104

    (98) comp_op -> EQUAL .

    INTEGER         reduce using rule 98 (comp_op -> EQUAL .)
    DOUBLE          reduce using rule 98 (comp_op -> EQUAL .)
    STRING          reduce using rule 98 (comp_op -> EQUAL .)


state 105

    (99) comp_op -> NOT_EQUAL .

    INTEGER         reduce using rule 99 (comp_op -> NOT_EQUAL .)
    DOUBLE          reduce using rule 99 (comp_op -> NOT_EQUAL .)
    STRING          reduce using rule 99 (comp_op -> NOT_EQUAL .)


state 106

    (100) comp_op -> LESS .

    INTEGER         reduce using rule 100 (comp_op -> LESS .)
    DOUBLE          reduce using rule 100 (comp_op -> LESS .)
    STRING          reduce using rule 100 (comp_op -> LESS .)


state 107

    (101) comp_op -> LESS_EQUAL .

    INTEGER         reduce using rule 101 (comp_op -> LESS_EQUAL .)
    DOUBLE          reduce using rule 101 (comp_op -> LESS_EQUAL .)
    STRING          reduce using rule 101 (comp_op -> LESS_EQUAL .)


state 108

    (102) comp_op -> GREATER .

    INTEGER         reduce using rule 102 (comp_op -> GREATER .)
    DOUBLE          reduce using rule 102 (comp_op -> GREATER .)
    STRING          reduce using rule 102 (comp_op -> GREATER .)


state 109

    (103) comp_op -> GREATER_EQUAL .

    INTEGER         reduce using rule 103 (comp_op -> GREATER_EQUAL .)
    DOUBLE          reduce using rule 103 (comp_op -> GREATER_EQUAL .)
    STRING          reduce using rule 103 (comp_op -> GREATER_EQUAL .)


state 110

    (87) string_comparison -> string comp_op . string
    (112) string -> . STRING

    STRING          shift and go to state 54

    string                         shift and go to state 172

state 111

    (92) logic -> LOGICAL_NOT logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    SEMICOLON       reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    RPAREN          reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    LINE_BREAK      reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    PRINT           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    IF              reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    WHILE           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    FOR             reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    IDENTIFIER      reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    FINAL           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    CONST           reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    INTEGER_TYPE    reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    DOUBLE_TYPE     reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    BOOLEAN_TYPE    reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    QUEUE_TYPE      reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    STRING_TYPE     reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    ENUM_TYPE       reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    VAR             reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    LIST_TYPE       reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    MAP_TYPE        reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    SET_TYPE        reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    DYNAMIC_TYPE    reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    VOID            reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    RBRACE          reduce using rule 92 (logic -> LOGICAL_NOT logic .)
    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

  ! LOGICAL_AND     [ reduce using rule 92 (logic -> LOGICAL_NOT logic .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (logic -> LOGICAL_NOT logic .) ]

    logic_op                       shift and go to state 76

state 112

    (91) logic -> LPAREN . logic logic_op logic RPAREN
    (85) int_comparison -> LPAREN . number comp_op number RPAREN
    (88) string_comparison -> LPAREN . string comp_op string RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 112
    LOGICAL_NOT     shift and go to state 34
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    logic                          shift and go to state 94
    number                         shift and go to state 173
    string                         shift and go to state 174
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 113

    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 103

state 114

    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 110

state 115

    (139) map -> MAP_TYPE LESS . type COMMA type GREATER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 175

state 116

    (21) int_assignment -> number_type IDENTIFIER . ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> number_type IDENTIFIER . ASSIGN arithmetic

    ASSIGN          shift and go to state 180


state 117

    (24) int_assignment -> number_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (26) int_assignment -> number_type nullable . IDENTIFIER ASSIGN arithmetic SEMICOLON

    IDENTIFIER      shift and go to state 181


state 118

    (28) string_assignment -> type_string IDENTIFIER . ASSIGN concate SEMICOLON
    (29) string_assignment -> type_string IDENTIFIER . ASSIGN concate

    ASSIGN          shift and go to state 182


state 119

    (31) string_assignment -> type_string nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (33) string_assignment -> type_string nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 183


state 120

    (141) map_assigment -> map IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> map IDENTIFIER . ASSIGN LBRACE map_values RBRACE SEMICOLON

    ASSIGN          shift and go to state 184


state 121

    (51) if_statement -> if_statement ELSE if_statement .
    (51) if_statement -> if_statement . ELSE if_statement
    (52) if_statement -> if_statement . ELSE LBRACE lines RBRACE

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    LINE_BREAK      reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    PRINT           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    IF              reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    WHILE           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    FOR             reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    IDENTIFIER      reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    FINAL           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    CONST           reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    INTEGER_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    DOUBLE_TYPE     reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    BOOLEAN_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    QUEUE_TYPE      reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    STRING_TYPE     reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    ENUM_TYPE       reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    VAR             reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    LIST_TYPE       reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    MAP_TYPE        reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    SET_TYPE        reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    DYNAMIC_TYPE    reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    VOID            reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    RBRACE          reduce using rule 51 (if_statement -> if_statement ELSE if_statement .)
    ELSE            shift and go to state 60

  ! ELSE            [ reduce using rule 51 (if_statement -> if_statement ELSE if_statement .) ]


state 122

    (52) if_statement -> if_statement ELSE LBRACE . lines RBRACE
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 30
    RBRACE          reduce using rule 124 (lines -> .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    if_statement                   shift and go to state 65
    lines                          shift and go to state 185
    line                           shift and go to state 29
    print                          shift and go to state 62
    assignment                     shift and go to state 63
    function                       shift and go to state 64
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    reassignment                   shift and go to state 69
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 123

    (9) statement -> LBRACE lines RBRACE .

    $end            reduce using rule 9 (statement -> LBRACE lines RBRACE .)


state 124

    (75) arithmetic -> arithmetic arith_op arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    $end            reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    SEMICOLON       reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    RPAREN          reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    LINE_BREAK      reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    PRINT           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    IF              reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    WHILE           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    FOR             reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    IDENTIFIER      reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    FINAL           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    CONST           reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    INTEGER_TYPE    reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    DOUBLE_TYPE     reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    BOOLEAN_TYPE    reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    QUEUE_TYPE      reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    STRING_TYPE     reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    ENUM_TYPE       reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    VAR             reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    LIST_TYPE       reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    MAP_TYPE        reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    SET_TYPE        reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    DYNAMIC_TYPE    reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    VOID            reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    RBRACE          reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

  ! PLUS            [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 71

state 125

    (74) arithmetic -> number .

    PLUS            reduce using rule 74 (arithmetic -> number .)
    MINUS           reduce using rule 74 (arithmetic -> number .)
    TIMES           reduce using rule 74 (arithmetic -> number .)
    $end            reduce using rule 74 (arithmetic -> number .)
    SEMICOLON       reduce using rule 74 (arithmetic -> number .)
    RPAREN          reduce using rule 74 (arithmetic -> number .)
    LINE_BREAK      reduce using rule 74 (arithmetic -> number .)
    PRINT           reduce using rule 74 (arithmetic -> number .)
    IF              reduce using rule 74 (arithmetic -> number .)
    WHILE           reduce using rule 74 (arithmetic -> number .)
    FOR             reduce using rule 74 (arithmetic -> number .)
    IDENTIFIER      reduce using rule 74 (arithmetic -> number .)
    FINAL           reduce using rule 74 (arithmetic -> number .)
    CONST           reduce using rule 74 (arithmetic -> number .)
    INTEGER_TYPE    reduce using rule 74 (arithmetic -> number .)
    DOUBLE_TYPE     reduce using rule 74 (arithmetic -> number .)
    BOOLEAN_TYPE    reduce using rule 74 (arithmetic -> number .)
    QUEUE_TYPE      reduce using rule 74 (arithmetic -> number .)
    STRING_TYPE     reduce using rule 74 (arithmetic -> number .)
    ENUM_TYPE       reduce using rule 74 (arithmetic -> number .)
    VAR             reduce using rule 74 (arithmetic -> number .)
    LIST_TYPE       reduce using rule 74 (arithmetic -> number .)
    MAP_TYPE        reduce using rule 74 (arithmetic -> number .)
    SET_TYPE        reduce using rule 74 (arithmetic -> number .)
    DYNAMIC_TYPE    reduce using rule 74 (arithmetic -> number .)
    VOID            reduce using rule 74 (arithmetic -> number .)
    RBRACE          reduce using rule 74 (arithmetic -> number .)


state 126

    (76) arithmetic -> LPAREN . arithmetic arith_op arithmetic RPAREN
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 126
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 92
    number                         shift and go to state 125

state 127

    (79) concate -> concate PLUS concate .
    (79) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    $end            reduce using rule 79 (concate -> concate PLUS concate .)
    SEMICOLON       reduce using rule 79 (concate -> concate PLUS concate .)
    RPAREN          reduce using rule 79 (concate -> concate PLUS concate .)
    LINE_BREAK      reduce using rule 79 (concate -> concate PLUS concate .)
    PRINT           reduce using rule 79 (concate -> concate PLUS concate .)
    IF              reduce using rule 79 (concate -> concate PLUS concate .)
    WHILE           reduce using rule 79 (concate -> concate PLUS concate .)
    FOR             reduce using rule 79 (concate -> concate PLUS concate .)
    IDENTIFIER      reduce using rule 79 (concate -> concate PLUS concate .)
    FINAL           reduce using rule 79 (concate -> concate PLUS concate .)
    CONST           reduce using rule 79 (concate -> concate PLUS concate .)
    INTEGER_TYPE    reduce using rule 79 (concate -> concate PLUS concate .)
    DOUBLE_TYPE     reduce using rule 79 (concate -> concate PLUS concate .)
    BOOLEAN_TYPE    reduce using rule 79 (concate -> concate PLUS concate .)
    QUEUE_TYPE      reduce using rule 79 (concate -> concate PLUS concate .)
    STRING_TYPE     reduce using rule 79 (concate -> concate PLUS concate .)
    ENUM_TYPE       reduce using rule 79 (concate -> concate PLUS concate .)
    VAR             reduce using rule 79 (concate -> concate PLUS concate .)
    LIST_TYPE       reduce using rule 79 (concate -> concate PLUS concate .)
    MAP_TYPE        reduce using rule 79 (concate -> concate PLUS concate .)
    SET_TYPE        reduce using rule 79 (concate -> concate PLUS concate .)
    DYNAMIC_TYPE    reduce using rule 79 (concate -> concate PLUS concate .)
    VOID            reduce using rule 79 (concate -> concate PLUS concate .)
    RBRACE          reduce using rule 79 (concate -> concate PLUS concate .)
    PLUS            shift and go to state 75

  ! PLUS            [ reduce using rule 79 (concate -> concate PLUS concate .) ]


state 128

    (78) concate -> string .

    PLUS            reduce using rule 78 (concate -> string .)
    $end            reduce using rule 78 (concate -> string .)
    SEMICOLON       reduce using rule 78 (concate -> string .)
    RPAREN          reduce using rule 78 (concate -> string .)
    LINE_BREAK      reduce using rule 78 (concate -> string .)
    PRINT           reduce using rule 78 (concate -> string .)
    IF              reduce using rule 78 (concate -> string .)
    WHILE           reduce using rule 78 (concate -> string .)
    FOR             reduce using rule 78 (concate -> string .)
    IDENTIFIER      reduce using rule 78 (concate -> string .)
    FINAL           reduce using rule 78 (concate -> string .)
    CONST           reduce using rule 78 (concate -> string .)
    INTEGER_TYPE    reduce using rule 78 (concate -> string .)
    DOUBLE_TYPE     reduce using rule 78 (concate -> string .)
    BOOLEAN_TYPE    reduce using rule 78 (concate -> string .)
    QUEUE_TYPE      reduce using rule 78 (concate -> string .)
    STRING_TYPE     reduce using rule 78 (concate -> string .)
    ENUM_TYPE       reduce using rule 78 (concate -> string .)
    VAR             reduce using rule 78 (concate -> string .)
    LIST_TYPE       reduce using rule 78 (concate -> string .)
    MAP_TYPE        reduce using rule 78 (concate -> string .)
    SET_TYPE        reduce using rule 78 (concate -> string .)
    DYNAMIC_TYPE    reduce using rule 78 (concate -> string .)
    VOID            reduce using rule 78 (concate -> string .)
    RBRACE          reduce using rule 78 (concate -> string .)


state 129

    (80) concate -> LPAREN . concate PLUS concate RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 129
    STRING          shift and go to state 54

    concate                        shift and go to state 93
    string                         shift and go to state 128

state 130

    (90) logic -> logic logic_op logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    $end            reduce using rule 90 (logic -> logic logic_op logic .)
    SEMICOLON       reduce using rule 90 (logic -> logic logic_op logic .)
    RPAREN          reduce using rule 90 (logic -> logic logic_op logic .)
    LINE_BREAK      reduce using rule 90 (logic -> logic logic_op logic .)
    PRINT           reduce using rule 90 (logic -> logic logic_op logic .)
    IF              reduce using rule 90 (logic -> logic logic_op logic .)
    WHILE           reduce using rule 90 (logic -> logic logic_op logic .)
    FOR             reduce using rule 90 (logic -> logic logic_op logic .)
    IDENTIFIER      reduce using rule 90 (logic -> logic logic_op logic .)
    FINAL           reduce using rule 90 (logic -> logic logic_op logic .)
    CONST           reduce using rule 90 (logic -> logic logic_op logic .)
    INTEGER_TYPE    reduce using rule 90 (logic -> logic logic_op logic .)
    DOUBLE_TYPE     reduce using rule 90 (logic -> logic logic_op logic .)
    BOOLEAN_TYPE    reduce using rule 90 (logic -> logic logic_op logic .)
    QUEUE_TYPE      reduce using rule 90 (logic -> logic logic_op logic .)
    STRING_TYPE     reduce using rule 90 (logic -> logic logic_op logic .)
    ENUM_TYPE       reduce using rule 90 (logic -> logic logic_op logic .)
    VAR             reduce using rule 90 (logic -> logic logic_op logic .)
    LIST_TYPE       reduce using rule 90 (logic -> logic logic_op logic .)
    MAP_TYPE        reduce using rule 90 (logic -> logic logic_op logic .)
    SET_TYPE        reduce using rule 90 (logic -> logic logic_op logic .)
    DYNAMIC_TYPE    reduce using rule 90 (logic -> logic logic_op logic .)
    VOID            reduce using rule 90 (logic -> logic logic_op logic .)
    RBRACE          reduce using rule 90 (logic -> logic logic_op logic .)
    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

  ! LOGICAL_AND     [ reduce using rule 90 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 90 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 76

state 131

    (12) assignment -> modifier type nullable . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 186


state 132

    (14) assignment -> modifier type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 187


state 133

    (23) int_assignment -> modifier number_type nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier number_type nullable . IDENTIFIER ASSIGN arithmetic SEMICOLON

    IDENTIFIER      shift and go to state 188


state 134

    (27) int_assignment -> modifier number_type IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 189


state 135

    (30) string_assignment -> modifier type_string nullable . IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier type_string nullable . IDENTIFIER ASSIGN concate SEMICOLON

    IDENTIFIER      shift and go to state 190


state 136

    (34) string_assignment -> modifier type_string IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 191


state 137

    (13) assignment -> type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 192


state 138

    (15) assignment -> type IDENTIFIER ASSIGN . expression SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN . expression
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    IDENTIFIER      shift and go to state 143
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    expression                     shift and go to state 193
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 147
    division                       shift and go to state 16
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 139

    (119) function -> type IDENTIFIER LPAREN . parameters RPAREN LBRACE lines RBRACE
    (133) parameters -> . VOID
    (134) parameters -> . parameter
    (135) parameters -> . parameter COMMA parameters
    (136) parameters -> .
    (137) parameter -> . type IDENTIFIER
    (138) parameter -> . IDENTIFIER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    VOID            shift and go to state 197
    RPAREN          reduce using rule 136 (parameters -> .)
    IDENTIFIER      shift and go to state 195
    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47

    type                           shift and go to state 194
    parameters                     shift and go to state 196
    parameter                      shift and go to state 198

state 140

    (118) list_assigment -> type ASSIGN list . SEMICOLON

    SEMICOLON       shift and go to state 199


state 141

    (115) list -> LSQUARE . RSQUARE
    (116) list -> LSQUARE . values RSQUARE
    (104) values -> . value
    (105) values -> . value COMMA values
    (106) value -> . IDENTIFIER
    (107) value -> . number
    (108) value -> . string
    (109) value -> . list
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    RSQUARE         shift and go to state 200
    IDENTIFIER      shift and go to state 150
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 141

    values                         shift and go to state 201
    value                          shift and go to state 153
    number                         shift and go to state 154
    string                         shift and go to state 155
    list                           shift and go to state 156

state 142

    (143) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN . LBRACE map_values RBRACE SEMICOLON

    LBRACE          shift and go to state 202


state 143

    (53) function_call -> IDENTIFIER . LPAREN values RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER . LPAREN values RPAREN
    (55) function_call -> IDENTIFIER . LPAREN RPAREN SEMICOLON
    (56) function_call -> IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 90


state 144

    (40) reassignment -> IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 203


state 145

    (117) list_assigment -> IDENTIFIER ASSIGN list . SEMICOLON

    SEMICOLON       shift and go to state 204


state 146

    (144) map_assigment -> IDENTIFIER ASSIGN LBRACE . RBRACE SEMICOLON

    RBRACE          shift and go to state 205


state 147

    (72) expression -> function_call .

    SEMICOLON       reduce using rule 72 (expression -> function_call .)
    RPAREN          reduce using rule 72 (expression -> function_call .)
    $end            reduce using rule 72 (expression -> function_call .)
    LINE_BREAK      reduce using rule 72 (expression -> function_call .)
    PRINT           reduce using rule 72 (expression -> function_call .)
    IF              reduce using rule 72 (expression -> function_call .)
    WHILE           reduce using rule 72 (expression -> function_call .)
    FOR             reduce using rule 72 (expression -> function_call .)
    IDENTIFIER      reduce using rule 72 (expression -> function_call .)
    FINAL           reduce using rule 72 (expression -> function_call .)
    CONST           reduce using rule 72 (expression -> function_call .)
    INTEGER_TYPE    reduce using rule 72 (expression -> function_call .)
    DOUBLE_TYPE     reduce using rule 72 (expression -> function_call .)
    BOOLEAN_TYPE    reduce using rule 72 (expression -> function_call .)
    QUEUE_TYPE      reduce using rule 72 (expression -> function_call .)
    STRING_TYPE     reduce using rule 72 (expression -> function_call .)
    ENUM_TYPE       reduce using rule 72 (expression -> function_call .)
    VAR             reduce using rule 72 (expression -> function_call .)
    LIST_TYPE       reduce using rule 72 (expression -> function_call .)
    MAP_TYPE        reduce using rule 72 (expression -> function_call .)
    SET_TYPE        reduce using rule 72 (expression -> function_call .)
    DYNAMIC_TYPE    reduce using rule 72 (expression -> function_call .)
    VOID            reduce using rule 72 (expression -> function_call .)
    RBRACE          reduce using rule 72 (expression -> function_call .)


state 148

    (41) reassignment -> IDENTIFIER INLINE_ARITH number . SEMICOLON
    (43) reassignment -> IDENTIFIER INLINE_ARITH number .

    SEMICOLON       shift and go to state 206
    $end            reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LINE_BREAK      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    PRINT           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IF              reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    WHILE           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FOR             reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    IDENTIFIER      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    FINAL           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    CONST           reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    INTEGER_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DOUBLE_TYPE     reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    BOOLEAN_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    QUEUE_TYPE      reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    STRING_TYPE     reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    ENUM_TYPE       reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VAR             reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    LIST_TYPE       reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    MAP_TYPE        reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    SET_TYPE        reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    DYNAMIC_TYPE    reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    VOID            reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RBRACE          reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)
    RPAREN          reduce using rule 43 (reassignment -> IDENTIFIER INLINE_ARITH number .)


state 149

    (42) reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .

    $end            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LINE_BREAK      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    PRINT           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IF              reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    WHILE           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FOR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    FINAL           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    CONST           reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    INTEGER_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    QUEUE_TYPE      reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    STRING_TYPE     reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    ENUM_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VAR             reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    LIST_TYPE       reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    MAP_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    SET_TYPE        reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    VOID            reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RBRACE          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)
    RPAREN          reduce using rule 42 (reassignment -> IDENTIFIER INLINE_ARITH SEMICOLON .)


state 150

    (106) value -> IDENTIFIER .

    COMMA           reduce using rule 106 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 106 (value -> IDENTIFIER .)
    RSQUARE         reduce using rule 106 (value -> IDENTIFIER .)


state 151

    (53) function_call -> IDENTIFIER LPAREN values . RPAREN SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN values . RPAREN

    RPAREN          shift and go to state 207


state 152

    (55) function_call -> IDENTIFIER LPAREN RPAREN . SEMICOLON
    (56) function_call -> IDENTIFIER LPAREN RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 208
    $end            reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LINE_BREAK      reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FINAL           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONST           reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INTEGER_TYPE    reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOUBLE_TYPE     reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BOOLEAN_TYPE    reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    QUEUE_TYPE      reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    STRING_TYPE     reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ENUM_TYPE       reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LIST_TYPE       reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MAP_TYPE        reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SET_TYPE        reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DYNAMIC_TYPE    reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    VOID            reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .)

  ! SEMICOLON       [ reduce using rule 56 (function_call -> IDENTIFIER LPAREN RPAREN .) ]


state 153

    (104) values -> value .
    (105) values -> value . COMMA values

    RPAREN          reduce using rule 104 (values -> value .)
    RSQUARE         reduce using rule 104 (values -> value .)
    COMMA           shift and go to state 209


state 154

    (107) value -> number .

    COMMA           reduce using rule 107 (value -> number .)
    RPAREN          reduce using rule 107 (value -> number .)
    RSQUARE         reduce using rule 107 (value -> number .)


state 155

    (108) value -> string .

    COMMA           reduce using rule 108 (value -> string .)
    RPAREN          reduce using rule 108 (value -> string .)
    RSQUARE         reduce using rule 108 (value -> string .)


state 156

    (109) value -> list .

    COMMA           reduce using rule 109 (value -> list .)
    RPAREN          reduce using rule 109 (value -> list .)
    RSQUARE         reduce using rule 109 (value -> list .)


state 157

    (48) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 210


state 158

    (49) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 211


state 159

    (76) arithmetic -> LPAREN arithmetic arith_op . arithmetic RPAREN
    (75) arithmetic -> arithmetic arith_op . arithmetic
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 126
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 212
    number                         shift and go to state 125

state 160

    (80) concate -> LPAREN concate PLUS . concate RPAREN
    (79) concate -> concate PLUS . concate
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 129
    STRING          shift and go to state 54

    concate                        shift and go to state 213
    string                         shift and go to state 128

state 161

    (91) logic -> LPAREN logic logic_op . logic RPAREN
    (90) logic -> logic logic_op . logic
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 112
    LOGICAL_NOT     shift and go to state 34
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54

    logic                          shift and go to state 214
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57
    number                         shift and go to state 113
    string                         shift and go to state 114

state 162

    (85) int_comparison -> LPAREN number comp_op . number RPAREN
    (84) int_comparison -> number comp_op . number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    number                         shift and go to state 215

state 163

    (88) string_comparison -> LPAREN string comp_op . string RPAREN
    (87) string_comparison -> string comp_op . string
    (112) string -> . STRING

    STRING          shift and go to state 54

    string                         shift and go to state 216

state 164

    (50) if_statement -> IF LPAREN logic . RPAREN LBRACE lines RBRACE
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 217
    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

    logic_op                       shift and go to state 76

state 165

    (153) while_statement -> WHILE LPAREN logic . RPAREN LBRACE lines RBRACE
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    RPAREN          shift and go to state 218
    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

    logic_op                       shift and go to state 76

state 166

    (154) for_statement -> FOR LPAREN assignment . SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE

    SEMICOLON       shift and go to state 219


state 167

    (13) assignment -> type . nullable IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> type . IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> type . IDENTIFIER ASSIGN expression
    (118) list_assigment -> type . ASSIGN list SEMICOLON
    (45) nullable -> . QUESTION_MARK

    IDENTIFIER      shift and go to state 220
    ASSIGN          shift and go to state 85
    QUESTION_MARK   shift and go to state 86

    nullable                       shift and go to state 83

state 168

    (117) list_assigment -> IDENTIFIER . ASSIGN list SEMICOLON
    (143) map_assigment -> IDENTIFIER . IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> IDENTIFIER . ASSIGN LBRACE RBRACE SEMICOLON

    ASSIGN          shift and go to state 221
    IDENTIFIER      shift and go to state 87


state 169

    (120) lines -> line LINE_BREAK lines .

    $end            reduce using rule 120 (lines -> line LINE_BREAK lines .)
    RBRACE          reduce using rule 120 (lines -> line LINE_BREAK lines .)


state 170

    (77) division -> number DIVIDE number .

    $end            reduce using rule 77 (division -> number DIVIDE number .)
    SEMICOLON       reduce using rule 77 (division -> number DIVIDE number .)
    RPAREN          reduce using rule 77 (division -> number DIVIDE number .)
    LINE_BREAK      reduce using rule 77 (division -> number DIVIDE number .)
    PRINT           reduce using rule 77 (division -> number DIVIDE number .)
    IF              reduce using rule 77 (division -> number DIVIDE number .)
    WHILE           reduce using rule 77 (division -> number DIVIDE number .)
    FOR             reduce using rule 77 (division -> number DIVIDE number .)
    IDENTIFIER      reduce using rule 77 (division -> number DIVIDE number .)
    FINAL           reduce using rule 77 (division -> number DIVIDE number .)
    CONST           reduce using rule 77 (division -> number DIVIDE number .)
    INTEGER_TYPE    reduce using rule 77 (division -> number DIVIDE number .)
    DOUBLE_TYPE     reduce using rule 77 (division -> number DIVIDE number .)
    BOOLEAN_TYPE    reduce using rule 77 (division -> number DIVIDE number .)
    QUEUE_TYPE      reduce using rule 77 (division -> number DIVIDE number .)
    STRING_TYPE     reduce using rule 77 (division -> number DIVIDE number .)
    ENUM_TYPE       reduce using rule 77 (division -> number DIVIDE number .)
    VAR             reduce using rule 77 (division -> number DIVIDE number .)
    LIST_TYPE       reduce using rule 77 (division -> number DIVIDE number .)
    MAP_TYPE        reduce using rule 77 (division -> number DIVIDE number .)
    SET_TYPE        reduce using rule 77 (division -> number DIVIDE number .)
    DYNAMIC_TYPE    reduce using rule 77 (division -> number DIVIDE number .)
    VOID            reduce using rule 77 (division -> number DIVIDE number .)
    RBRACE          reduce using rule 77 (division -> number DIVIDE number .)


state 171

    (84) int_comparison -> number comp_op number .

    LOGICAL_AND     reduce using rule 84 (int_comparison -> number comp_op number .)
    LOGICAL_OR      reduce using rule 84 (int_comparison -> number comp_op number .)
    $end            reduce using rule 84 (int_comparison -> number comp_op number .)
    SEMICOLON       reduce using rule 84 (int_comparison -> number comp_op number .)
    RPAREN          reduce using rule 84 (int_comparison -> number comp_op number .)
    LINE_BREAK      reduce using rule 84 (int_comparison -> number comp_op number .)
    PRINT           reduce using rule 84 (int_comparison -> number comp_op number .)
    IF              reduce using rule 84 (int_comparison -> number comp_op number .)
    WHILE           reduce using rule 84 (int_comparison -> number comp_op number .)
    FOR             reduce using rule 84 (int_comparison -> number comp_op number .)
    IDENTIFIER      reduce using rule 84 (int_comparison -> number comp_op number .)
    FINAL           reduce using rule 84 (int_comparison -> number comp_op number .)
    CONST           reduce using rule 84 (int_comparison -> number comp_op number .)
    INTEGER_TYPE    reduce using rule 84 (int_comparison -> number comp_op number .)
    DOUBLE_TYPE     reduce using rule 84 (int_comparison -> number comp_op number .)
    BOOLEAN_TYPE    reduce using rule 84 (int_comparison -> number comp_op number .)
    QUEUE_TYPE      reduce using rule 84 (int_comparison -> number comp_op number .)
    STRING_TYPE     reduce using rule 84 (int_comparison -> number comp_op number .)
    ENUM_TYPE       reduce using rule 84 (int_comparison -> number comp_op number .)
    VAR             reduce using rule 84 (int_comparison -> number comp_op number .)
    LIST_TYPE       reduce using rule 84 (int_comparison -> number comp_op number .)
    MAP_TYPE        reduce using rule 84 (int_comparison -> number comp_op number .)
    SET_TYPE        reduce using rule 84 (int_comparison -> number comp_op number .)
    DYNAMIC_TYPE    reduce using rule 84 (int_comparison -> number comp_op number .)
    VOID            reduce using rule 84 (int_comparison -> number comp_op number .)
    RBRACE          reduce using rule 84 (int_comparison -> number comp_op number .)


state 172

    (87) string_comparison -> string comp_op string .

    LOGICAL_AND     reduce using rule 87 (string_comparison -> string comp_op string .)
    LOGICAL_OR      reduce using rule 87 (string_comparison -> string comp_op string .)
    $end            reduce using rule 87 (string_comparison -> string comp_op string .)
    SEMICOLON       reduce using rule 87 (string_comparison -> string comp_op string .)
    RPAREN          reduce using rule 87 (string_comparison -> string comp_op string .)
    LINE_BREAK      reduce using rule 87 (string_comparison -> string comp_op string .)
    PRINT           reduce using rule 87 (string_comparison -> string comp_op string .)
    IF              reduce using rule 87 (string_comparison -> string comp_op string .)
    WHILE           reduce using rule 87 (string_comparison -> string comp_op string .)
    FOR             reduce using rule 87 (string_comparison -> string comp_op string .)
    IDENTIFIER      reduce using rule 87 (string_comparison -> string comp_op string .)
    FINAL           reduce using rule 87 (string_comparison -> string comp_op string .)
    CONST           reduce using rule 87 (string_comparison -> string comp_op string .)
    INTEGER_TYPE    reduce using rule 87 (string_comparison -> string comp_op string .)
    DOUBLE_TYPE     reduce using rule 87 (string_comparison -> string comp_op string .)
    BOOLEAN_TYPE    reduce using rule 87 (string_comparison -> string comp_op string .)
    QUEUE_TYPE      reduce using rule 87 (string_comparison -> string comp_op string .)
    STRING_TYPE     reduce using rule 87 (string_comparison -> string comp_op string .)
    ENUM_TYPE       reduce using rule 87 (string_comparison -> string comp_op string .)
    VAR             reduce using rule 87 (string_comparison -> string comp_op string .)
    LIST_TYPE       reduce using rule 87 (string_comparison -> string comp_op string .)
    MAP_TYPE        reduce using rule 87 (string_comparison -> string comp_op string .)
    SET_TYPE        reduce using rule 87 (string_comparison -> string comp_op string .)
    DYNAMIC_TYPE    reduce using rule 87 (string_comparison -> string comp_op string .)
    VOID            reduce using rule 87 (string_comparison -> string comp_op string .)
    RBRACE          reduce using rule 87 (string_comparison -> string comp_op string .)


state 173

    (85) int_comparison -> LPAREN number . comp_op number RPAREN
    (84) int_comparison -> number . comp_op number
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 162

state 174

    (88) string_comparison -> LPAREN string . comp_op string RPAREN
    (87) string_comparison -> string . comp_op string
    (98) comp_op -> . EQUAL
    (99) comp_op -> . NOT_EQUAL
    (100) comp_op -> . LESS
    (101) comp_op -> . LESS_EQUAL
    (102) comp_op -> . GREATER
    (103) comp_op -> . GREATER_EQUAL

    EQUAL           shift and go to state 104
    NOT_EQUAL       shift and go to state 105
    LESS            shift and go to state 106
    LESS_EQUAL      shift and go to state 107
    GREATER         shift and go to state 108
    GREATER_EQUAL   shift and go to state 109

    comp_op                        shift and go to state 163

state 175

    (139) map -> MAP_TYPE LESS type . COMMA type GREATER

    COMMA           shift and go to state 222


state 176

    (57) type -> INTEGER_TYPE .

    COMMA           reduce using rule 57 (type -> INTEGER_TYPE .)
    IDENTIFIER      reduce using rule 57 (type -> INTEGER_TYPE .)
    COLON           reduce using rule 57 (type -> INTEGER_TYPE .)
    GREATER         reduce using rule 57 (type -> INTEGER_TYPE .)
    RBRACE          reduce using rule 57 (type -> INTEGER_TYPE .)


state 177

    (58) type -> DOUBLE_TYPE .

    COMMA           reduce using rule 58 (type -> DOUBLE_TYPE .)
    IDENTIFIER      reduce using rule 58 (type -> DOUBLE_TYPE .)
    COLON           reduce using rule 58 (type -> DOUBLE_TYPE .)
    GREATER         reduce using rule 58 (type -> DOUBLE_TYPE .)
    RBRACE          reduce using rule 58 (type -> DOUBLE_TYPE .)


state 178

    (61) type -> STRING_TYPE .

    COMMA           reduce using rule 61 (type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 61 (type -> STRING_TYPE .)
    COLON           reduce using rule 61 (type -> STRING_TYPE .)
    GREATER         reduce using rule 61 (type -> STRING_TYPE .)
    RBRACE          reduce using rule 61 (type -> STRING_TYPE .)


state 179

    (63) type -> VAR .

    COMMA           reduce using rule 63 (type -> VAR .)
    IDENTIFIER      reduce using rule 63 (type -> VAR .)
    COLON           reduce using rule 63 (type -> VAR .)
    GREATER         reduce using rule 63 (type -> VAR .)
    RBRACE          reduce using rule 63 (type -> VAR .)


state 180

    (21) int_assignment -> number_type IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (22) int_assignment -> number_type IDENTIFIER ASSIGN . arithmetic
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 126
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 223
    number                         shift and go to state 125

state 181

    (24) int_assignment -> number_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (26) int_assignment -> number_type nullable IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 224


state 182

    (28) string_assignment -> type_string IDENTIFIER ASSIGN . concate SEMICOLON
    (29) string_assignment -> type_string IDENTIFIER ASSIGN . concate
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 129
    STRING          shift and go to state 54

    concate                        shift and go to state 225
    string                         shift and go to state 128

state 183

    (31) string_assignment -> type_string nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (33) string_assignment -> type_string nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 226


state 184

    (141) map_assigment -> map IDENTIFIER ASSIGN . LBRACE RBRACE SEMICOLON
    (142) map_assigment -> map IDENTIFIER ASSIGN . LBRACE map_values RBRACE SEMICOLON

    LBRACE          shift and go to state 227


state 185

    (52) if_statement -> if_statement ELSE LBRACE lines . RBRACE

    RBRACE          shift and go to state 228


state 186

    (12) assignment -> modifier type nullable IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 229


state 187

    (14) assignment -> modifier type IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    IDENTIFIER      shift and go to state 143
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    expression                     shift and go to state 230
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 147
    division                       shift and go to state 16
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 188

    (23) int_assignment -> modifier number_type nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (25) int_assignment -> modifier number_type nullable IDENTIFIER . ASSIGN arithmetic SEMICOLON

    ASSIGN          shift and go to state 231


state 189

    (27) int_assignment -> modifier number_type IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    LPAREN          shift and go to state 126
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 232
    number                         shift and go to state 125

state 190

    (30) string_assignment -> modifier type_string nullable IDENTIFIER . ASSIGN NULL SEMICOLON
    (32) string_assignment -> modifier type_string nullable IDENTIFIER . ASSIGN concate SEMICOLON

    ASSIGN          shift and go to state 233


state 191

    (34) string_assignment -> modifier type_string IDENTIFIER ASSIGN . concate SEMICOLON
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    LPAREN          shift and go to state 129
    STRING          shift and go to state 54

    concate                        shift and go to state 234
    string                         shift and go to state 128

state 192

    (13) assignment -> type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    IDENTIFIER      shift and go to state 143
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    expression                     shift and go to state 235
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 147
    division                       shift and go to state 16
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 193

    (15) assignment -> type IDENTIFIER ASSIGN expression . SEMICOLON
    (16) assignment -> type IDENTIFIER ASSIGN expression .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 236
    $end            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LINE_BREAK      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    PRINT           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    FINAL           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    CONST           reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    INTEGER_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DOUBLE_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    BOOLEAN_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    QUEUE_TYPE      reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    STRING_TYPE     reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    ENUM_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VAR             reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    LIST_TYPE       reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    MAP_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    SET_TYPE        reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    DYNAMIC_TYPE    reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    VOID            reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .)

  ! SEMICOLON       [ reduce using rule 16 (assignment -> type IDENTIFIER ASSIGN expression .) ]


state 194

    (137) parameter -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 237


state 195

    (138) parameter -> IDENTIFIER .

    COMMA           reduce using rule 138 (parameter -> IDENTIFIER .)
    RPAREN          reduce using rule 138 (parameter -> IDENTIFIER .)


state 196

    (119) function -> type IDENTIFIER LPAREN parameters . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 238


state 197

    (133) parameters -> VOID .
    (68) type -> VOID .

    RPAREN          reduce using rule 133 (parameters -> VOID .)
    IDENTIFIER      reduce using rule 68 (type -> VOID .)


state 198

    (134) parameters -> parameter .
    (135) parameters -> parameter . COMMA parameters

    RPAREN          reduce using rule 134 (parameters -> parameter .)
    COMMA           shift and go to state 239


state 199

    (118) list_assigment -> type ASSIGN list SEMICOLON .

    $end            reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    LINE_BREAK      reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    PRINT           reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    IF              reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    WHILE           reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    FOR             reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    IDENTIFIER      reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    FINAL           reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    CONST           reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    INTEGER_TYPE    reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    QUEUE_TYPE      reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    STRING_TYPE     reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    ENUM_TYPE       reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    VAR             reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    LIST_TYPE       reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    MAP_TYPE        reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    SET_TYPE        reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    VOID            reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    RBRACE          reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)
    SEMICOLON       reduce using rule 118 (list_assigment -> type ASSIGN list SEMICOLON .)


state 200

    (115) list -> LSQUARE RSQUARE .

    SEMICOLON       reduce using rule 115 (list -> LSQUARE RSQUARE .)
    COMMA           reduce using rule 115 (list -> LSQUARE RSQUARE .)
    RPAREN          reduce using rule 115 (list -> LSQUARE RSQUARE .)
    RSQUARE         reduce using rule 115 (list -> LSQUARE RSQUARE .)


state 201

    (116) list -> LSQUARE values . RSQUARE

    RSQUARE         shift and go to state 240


state 202

    (143) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE . map_values RBRACE SEMICOLON
    (145) map_values -> . type COLON type
    (146) map_values -> . type COLON type COMMA map_values
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    map_values                     shift and go to state 241
    type                           shift and go to state 242

state 203

    (40) reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RPAREN          reduce using rule 40 (reassignment -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 204

    (117) list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .

    $end            reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    LINE_BREAK      reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    PRINT           reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    IF              reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    WHILE           reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    FOR             reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    IDENTIFIER      reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    FINAL           reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    CONST           reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    INTEGER_TYPE    reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    QUEUE_TYPE      reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    STRING_TYPE     reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    ENUM_TYPE       reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    VAR             reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    LIST_TYPE       reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    MAP_TYPE        reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    SET_TYPE        reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    VOID            reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    RBRACE          reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)
    SEMICOLON       reduce using rule 117 (list_assigment -> IDENTIFIER ASSIGN list SEMICOLON .)


state 205

    (144) map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 243


state 206

    (41) reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .

    $end            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LINE_BREAK      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    PRINT           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IF              reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    WHILE           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FOR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    FINAL           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    CONST           reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    INTEGER_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    QUEUE_TYPE      reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    STRING_TYPE     reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    ENUM_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VAR             reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    LIST_TYPE       reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    MAP_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    SET_TYPE        reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    VOID            reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RBRACE          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)
    RPAREN          reduce using rule 41 (reassignment -> IDENTIFIER INLINE_ARITH number SEMICOLON .)


state 207

    (53) function_call -> IDENTIFIER LPAREN values RPAREN . SEMICOLON
    (54) function_call -> IDENTIFIER LPAREN values RPAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 244
    $end            reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LINE_BREAK      reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    PRINT           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IF              reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    WHILE           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FOR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    IDENTIFIER      reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    FINAL           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    CONST           reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    INTEGER_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DOUBLE_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    BOOLEAN_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    QUEUE_TYPE      reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    STRING_TYPE     reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    ENUM_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VAR             reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    LIST_TYPE       reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    MAP_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    SET_TYPE        reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    DYNAMIC_TYPE    reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    VOID            reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RBRACE          reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)
    RPAREN          reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .)

  ! SEMICOLON       [ reduce using rule 54 (function_call -> IDENTIFIER LPAREN values RPAREN .) ]


state 208

    (55) function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 55 (function_call -> IDENTIFIER LPAREN RPAREN SEMICOLON .)


state 209

    (105) values -> value COMMA . values
    (104) values -> . value
    (105) values -> . value COMMA values
    (106) value -> . IDENTIFIER
    (107) value -> . number
    (108) value -> . string
    (109) value -> . list
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    IDENTIFIER      shift and go to state 150
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    LSQUARE         shift and go to state 141

    value                          shift and go to state 153
    values                         shift and go to state 245
    number                         shift and go to state 154
    string                         shift and go to state 155
    list                           shift and go to state 156

state 210

    (48) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 246


state 211

    (49) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    CONST           reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 49 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 212

    (76) arithmetic -> LPAREN arithmetic arith_op arithmetic . RPAREN
    (75) arithmetic -> arithmetic arith_op arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    RPAREN          shift and go to state 247
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

  ! PLUS            [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! MINUS           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]
  ! TIMES           [ reduce using rule 75 (arithmetic -> arithmetic arith_op arithmetic .) ]

    arith_op                       shift and go to state 71

state 213

    (80) concate -> LPAREN concate PLUS concate . RPAREN
    (79) concate -> concate PLUS concate .
    (79) concate -> concate . PLUS concate

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 248
    PLUS            shift and go to state 75

  ! PLUS            [ reduce using rule 79 (concate -> concate PLUS concate .) ]


state 214

    (91) logic -> LPAREN logic logic_op logic . RPAREN
    (90) logic -> logic logic_op logic .
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
    RPAREN          shift and go to state 249
    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

  ! LOGICAL_AND     [ reduce using rule 90 (logic -> logic logic_op logic .) ]
  ! LOGICAL_OR      [ reduce using rule 90 (logic -> logic logic_op logic .) ]

    logic_op                       shift and go to state 76

state 215

    (85) int_comparison -> LPAREN number comp_op number . RPAREN
    (84) int_comparison -> number comp_op number .

    RPAREN          shift and go to state 250
    LOGICAL_AND     reduce using rule 84 (int_comparison -> number comp_op number .)
    LOGICAL_OR      reduce using rule 84 (int_comparison -> number comp_op number .)


state 216

    (88) string_comparison -> LPAREN string comp_op string . RPAREN
    (87) string_comparison -> string comp_op string .

    RPAREN          shift and go to state 251
    LOGICAL_AND     reduce using rule 87 (string_comparison -> string comp_op string .)
    LOGICAL_OR      reduce using rule 87 (string_comparison -> string comp_op string .)


state 217

    (50) if_statement -> IF LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 252


state 218

    (153) while_statement -> WHILE LPAREN logic RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 253


state 219

    (154) for_statement -> FOR LPAREN assignment SEMICOLON . logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING

    LPAREN          shift and go to state 112
    LOGICAL_NOT     shift and go to state 34
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54

    logic                          shift and go to state 254
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57
    number                         shift and go to state 113
    string                         shift and go to state 114

state 220

    (15) assignment -> type IDENTIFIER . ASSIGN expression SEMICOLON
    (16) assignment -> type IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 138


state 221

    (117) list_assigment -> IDENTIFIER ASSIGN . list SEMICOLON
    (144) map_assigment -> IDENTIFIER ASSIGN . LBRACE RBRACE SEMICOLON
    (115) list -> . LSQUARE RSQUARE
    (116) list -> . LSQUARE values RSQUARE

    LBRACE          shift and go to state 146
    LSQUARE         shift and go to state 141

    list                           shift and go to state 145

state 222

    (139) map -> MAP_TYPE LESS type COMMA . type GREATER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 255

state 223

    (21) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (22) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 256
    $end            reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    LINE_BREAK      reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    PRINT           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    IF              reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    WHILE           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    FOR             reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    IDENTIFIER      reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    FINAL           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    CONST           reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    INTEGER_TYPE    reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    DOUBLE_TYPE     reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    BOOLEAN_TYPE    reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    QUEUE_TYPE      reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    STRING_TYPE     reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    ENUM_TYPE       reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    VAR             reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    LIST_TYPE       reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    MAP_TYPE        reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    SET_TYPE        reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    DYNAMIC_TYPE    reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    VOID            reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    RBRACE          reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

  ! SEMICOLON       [ reduce using rule 22 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic .) ]

    arith_op                       shift and go to state 71

state 224

    (24) int_assignment -> number_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (26) int_assignment -> number_type nullable IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    NULL            shift and go to state 257
    LPAREN          shift and go to state 126
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 258
    number                         shift and go to state 125

state 225

    (28) string_assignment -> type_string IDENTIFIER ASSIGN concate . SEMICOLON
    (29) string_assignment -> type_string IDENTIFIER ASSIGN concate .
    (79) concate -> concate . PLUS concate

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 259
    $end            reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LINE_BREAK      reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    PRINT           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    IF              reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    WHILE           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    FOR             reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    IDENTIFIER      reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    FINAL           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    CONST           reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    INTEGER_TYPE    reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    DOUBLE_TYPE     reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    BOOLEAN_TYPE    reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    QUEUE_TYPE      reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    STRING_TYPE     reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    ENUM_TYPE       reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    VAR             reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    LIST_TYPE       reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    MAP_TYPE        reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    SET_TYPE        reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    DYNAMIC_TYPE    reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    VOID            reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    RBRACE          reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .)
    PLUS            shift and go to state 75

  ! SEMICOLON       [ reduce using rule 29 (string_assignment -> type_string IDENTIFIER ASSIGN concate .) ]


state 226

    (31) string_assignment -> type_string nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (33) string_assignment -> type_string nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    NULL            shift and go to state 260
    LPAREN          shift and go to state 129
    STRING          shift and go to state 54

    concate                        shift and go to state 261
    string                         shift and go to state 128

state 227

    (141) map_assigment -> map IDENTIFIER ASSIGN LBRACE . RBRACE SEMICOLON
    (142) map_assigment -> map IDENTIFIER ASSIGN LBRACE . map_values RBRACE SEMICOLON
    (145) map_values -> . type COLON type
    (146) map_values -> . type COLON type COMMA map_values
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    RBRACE          shift and go to state 262
    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    map_values                     shift and go to state 263
    type                           shift and go to state 242

state 228

    (52) if_statement -> if_statement ELSE LBRACE lines RBRACE .

    ELSE            reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    $end            reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    PRINT           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IF              reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    WHILE           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FOR             reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    FINAL           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    CONST           reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VAR             reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    VOID            reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)
    RBRACE          reduce using rule 52 (if_statement -> if_statement ELSE LBRACE lines RBRACE .)


state 229

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    IDENTIFIER      shift and go to state 143
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    expression                     shift and go to state 264
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 147
    division                       shift and go to state 16
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 230

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 265


state 231

    (23) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (25) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN . arithmetic SEMICOLON
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (110) number -> . INTEGER
    (111) number -> . DOUBLE

    NULL            shift and go to state 266
    LPAREN          shift and go to state 126
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53

    arithmetic                     shift and go to state 267
    number                         shift and go to state 125

state 232

    (27) int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    SEMICOLON       shift and go to state 268
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

    arith_op                       shift and go to state 71

state 233

    (30) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN . NULL SEMICOLON
    (32) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN . concate SEMICOLON
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (112) string -> . STRING

    NULL            shift and go to state 269
    LPAREN          shift and go to state 129
    STRING          shift and go to state 54

    concate                        shift and go to state 270
    string                         shift and go to state 128

state 234

    (34) string_assignment -> modifier type_string IDENTIFIER ASSIGN concate . SEMICOLON
    (79) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 271
    PLUS            shift and go to state 75


state 235

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 272


state 236

    (15) assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 15 (assignment -> type IDENTIFIER ASSIGN expression SEMICOLON .)


state 237

    (137) parameter -> type IDENTIFIER .

    COMMA           reduce using rule 137 (parameter -> type IDENTIFIER .)
    RPAREN          reduce using rule 137 (parameter -> type IDENTIFIER .)


state 238

    (119) function -> type IDENTIFIER LPAREN parameters RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 273


state 239

    (135) parameters -> parameter COMMA . parameters
    (133) parameters -> . VOID
    (134) parameters -> . parameter
    (135) parameters -> . parameter COMMA parameters
    (136) parameters -> .
    (137) parameter -> . type IDENTIFIER
    (138) parameter -> . IDENTIFIER
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    VOID            shift and go to state 197
    RPAREN          reduce using rule 136 (parameters -> .)
    IDENTIFIER      shift and go to state 195
    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47

    parameter                      shift and go to state 198
    parameters                     shift and go to state 274
    type                           shift and go to state 194

state 240

    (116) list -> LSQUARE values RSQUARE .

    SEMICOLON       reduce using rule 116 (list -> LSQUARE values RSQUARE .)
    COMMA           reduce using rule 116 (list -> LSQUARE values RSQUARE .)
    RPAREN          reduce using rule 116 (list -> LSQUARE values RSQUARE .)
    RSQUARE         reduce using rule 116 (list -> LSQUARE values RSQUARE .)


state 241

    (143) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values . RBRACE SEMICOLON

    RBRACE          shift and go to state 275


state 242

    (145) map_values -> type . COLON type
    (146) map_values -> type . COLON type COMMA map_values

    COLON           shift and go to state 276


state 243

    (144) map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .

    $end            reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    PRINT           reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IF              reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    WHILE           reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FOR             reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FINAL           reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    CONST           reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VAR             reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VOID            reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    RBRACE          reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 144 (map_assigment -> IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)


state 244

    (53) function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    PRINT           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IF              reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    WHILE           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FOR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    FINAL           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    CONST           reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VAR             reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    VOID            reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RBRACE          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)
    RPAREN          reduce using rule 53 (function_call -> IDENTIFIER LPAREN values RPAREN SEMICOLON .)


state 245

    (105) values -> value COMMA values .

    RPAREN          reduce using rule 105 (values -> value COMMA values .)
    RSQUARE         reduce using rule 105 (values -> value COMMA values .)


state 246

    (48) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    $end            reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LINE_BREAK      reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTEGER_TYPE    reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    QUEUE_TYPE      reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_TYPE     reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ENUM_TYPE       reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST_TYPE       reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP_TYPE        reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SET_TYPE        reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 48 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 247

    (76) arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .

    PLUS            reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MINUS           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    TIMES           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    $end            reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SEMICOLON       reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RPAREN          reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LINE_BREAK      reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    PRINT           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IF              reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    WHILE           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FOR             reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    IDENTIFIER      reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    FINAL           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    CONST           reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    INTEGER_TYPE    reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DOUBLE_TYPE     reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    QUEUE_TYPE      reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    STRING_TYPE     reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    ENUM_TYPE       reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VAR             reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    LIST_TYPE       reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    MAP_TYPE        reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    SET_TYPE        reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    VOID            reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)
    RBRACE          reduce using rule 76 (arithmetic -> LPAREN arithmetic arith_op arithmetic RPAREN .)


state 248

    (80) concate -> LPAREN concate PLUS concate RPAREN .

    PLUS            reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    $end            reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    SEMICOLON       reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    RPAREN          reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    LINE_BREAK      reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    PRINT           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    IF              reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    WHILE           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    FOR             reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    IDENTIFIER      reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    FINAL           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    CONST           reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    INTEGER_TYPE    reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    DOUBLE_TYPE     reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    BOOLEAN_TYPE    reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    QUEUE_TYPE      reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    STRING_TYPE     reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    ENUM_TYPE       reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    VAR             reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    LIST_TYPE       reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    MAP_TYPE        reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    SET_TYPE        reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    DYNAMIC_TYPE    reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    VOID            reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)
    RBRACE          reduce using rule 80 (concate -> LPAREN concate PLUS concate RPAREN .)


state 249

    (91) logic -> LPAREN logic logic_op logic RPAREN .

    LOGICAL_AND     reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    LOGICAL_OR      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    $end            reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    SEMICOLON       reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    RPAREN          reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    LINE_BREAK      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    PRINT           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    IF              reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    WHILE           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    FOR             reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    IDENTIFIER      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    FINAL           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    CONST           reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    INTEGER_TYPE    reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    DOUBLE_TYPE     reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    BOOLEAN_TYPE    reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    QUEUE_TYPE      reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    STRING_TYPE     reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    ENUM_TYPE       reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    VAR             reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    LIST_TYPE       reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    MAP_TYPE        reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    SET_TYPE        reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    DYNAMIC_TYPE    reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    VOID            reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)
    RBRACE          reduce using rule 91 (logic -> LPAREN logic logic_op logic RPAREN .)


state 250

    (85) int_comparison -> LPAREN number comp_op number RPAREN .

    LOGICAL_AND     reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LOGICAL_OR      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    $end            reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    SEMICOLON       reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    RPAREN          reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LINE_BREAK      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    PRINT           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    IF              reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    WHILE           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    FOR             reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    IDENTIFIER      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    FINAL           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    CONST           reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    INTEGER_TYPE    reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    DOUBLE_TYPE     reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    BOOLEAN_TYPE    reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    QUEUE_TYPE      reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    STRING_TYPE     reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    ENUM_TYPE       reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    VAR             reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    LIST_TYPE       reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    MAP_TYPE        reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    SET_TYPE        reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    DYNAMIC_TYPE    reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    VOID            reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)
    RBRACE          reduce using rule 85 (int_comparison -> LPAREN number comp_op number RPAREN .)


state 251

    (88) string_comparison -> LPAREN string comp_op string RPAREN .

    LOGICAL_AND     reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LOGICAL_OR      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    $end            reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    SEMICOLON       reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    RPAREN          reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LINE_BREAK      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    PRINT           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    IF              reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    WHILE           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    FOR             reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    IDENTIFIER      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    FINAL           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    CONST           reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    INTEGER_TYPE    reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    DOUBLE_TYPE     reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    BOOLEAN_TYPE    reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    QUEUE_TYPE      reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    STRING_TYPE     reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    ENUM_TYPE       reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    VAR             reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    LIST_TYPE       reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    MAP_TYPE        reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    SET_TYPE        reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    DYNAMIC_TYPE    reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    VOID            reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)
    RBRACE          reduce using rule 88 (string_comparison -> LPAREN string comp_op string RPAREN .)


state 252

    (50) if_statement -> IF LPAREN logic RPAREN LBRACE . lines RBRACE
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 30
    RBRACE          reduce using rule 124 (lines -> .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    lines                          shift and go to state 277
    line                           shift and go to state 29
    print                          shift and go to state 62
    assignment                     shift and go to state 63
    function                       shift and go to state 64
    if_statement                   shift and go to state 65
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    reassignment                   shift and go to state 69
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 253

    (153) while_statement -> WHILE LPAREN logic RPAREN LBRACE . lines RBRACE
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 30
    RBRACE          reduce using rule 124 (lines -> .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    lines                          shift and go to state 278
    line                           shift and go to state 29
    print                          shift and go to state 62
    assignment                     shift and go to state 63
    function                       shift and go to state 64
    if_statement                   shift and go to state 65
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    reassignment                   shift and go to state 69
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 254

    (154) for_statement -> FOR LPAREN assignment SEMICOLON logic . SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (90) logic -> logic . logic_op logic
    (93) logic_op -> . LOGICAL_AND
    (94) logic_op -> . LOGICAL_OR

    SEMICOLON       shift and go to state 279
    LOGICAL_AND     shift and go to state 77
    LOGICAL_OR      shift and go to state 78

    logic_op                       shift and go to state 76

state 255

    (139) map -> MAP_TYPE LESS type COMMA type . GREATER

    GREATER         shift and go to state 280


state 256

    (21) int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 21 (int_assignment -> number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 257

    (24) int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 281


state 258

    (26) int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    SEMICOLON       shift and go to state 282
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

    arith_op                       shift and go to state 71

state 259

    (28) string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 28 (string_assignment -> type_string IDENTIFIER ASSIGN concate SEMICOLON .)


state 260

    (31) string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 283


state 261

    (33) string_assignment -> type_string nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (79) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 284
    PLUS            shift and go to state 75


state 262

    (141) map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 285


state 263

    (142) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values . RBRACE SEMICOLON

    RBRACE          shift and go to state 286


state 264

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 287


state 265

    (14) assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 14 (assignment -> modifier type IDENTIFIER ASSIGN expression SEMICOLON .)


state 266

    (23) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 288


state 267

    (25) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic . SEMICOLON
    (75) arithmetic -> arithmetic . arith_op arithmetic
    (95) arith_op -> . PLUS
    (96) arith_op -> . MINUS
    (97) arith_op -> . TIMES

    SEMICOLON       shift and go to state 289
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    TIMES           shift and go to state 74

    arith_op                       shift and go to state 71

state 268

    (27) int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 27 (int_assignment -> modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 269

    (30) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL . SEMICOLON

    SEMICOLON       shift and go to state 290


state 270

    (32) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate . SEMICOLON
    (79) concate -> concate . PLUS concate

    SEMICOLON       shift and go to state 291
    PLUS            shift and go to state 75


state 271

    (34) string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 34 (string_assignment -> modifier type_string IDENTIFIER ASSIGN concate SEMICOLON .)


state 272

    (13) assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 13 (assignment -> type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 273

    (119) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE . lines RBRACE
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 30
    RBRACE          reduce using rule 124 (lines -> .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 18
    lines                          shift and go to state 292
    line                           shift and go to state 29
    print                          shift and go to state 62
    assignment                     shift and go to state 63
    function                       shift and go to state 64
    if_statement                   shift and go to state 65
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    reassignment                   shift and go to state 69
    modifier                       shift and go to state 17
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 274

    (135) parameters -> parameter COMMA parameters .

    RPAREN          reduce using rule 135 (parameters -> parameter COMMA parameters .)


state 275

    (143) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 293


state 276

    (145) map_values -> type COLON . type
    (146) map_values -> type COLON . type COMMA map_values
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 294

state 277

    (50) if_statement -> IF LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 295


state 278

    (153) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 296


state 279

    (154) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON . reassignment RPAREN LBRACE lines RBRACE
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH

    IDENTIFIER      shift and go to state 298

    reassignment                   shift and go to state 297

state 280

    (139) map -> MAP_TYPE LESS type COMMA type GREATER .

    IDENTIFIER      reduce using rule 139 (map -> MAP_TYPE LESS type COMMA type GREATER .)


state 281

    (24) int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 24 (int_assignment -> number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 282

    (26) int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 26 (int_assignment -> number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 283

    (31) string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 31 (string_assignment -> type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 284

    (33) string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 33 (string_assignment -> type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 285

    (141) map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .

    $end            reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    PRINT           reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IF              reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    WHILE           reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FOR             reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    FINAL           reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    CONST           reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VAR             reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    VOID            reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    RBRACE          reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 141 (map_assigment -> map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON .)


state 286

    (142) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 299


state 287

    (12) assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .

    $end            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LINE_BREAK      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    CONST           reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    QUEUE_TYPE      reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_TYPE     reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    ENUM_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    LIST_TYPE       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    MAP_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SET_TYPE        reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (assignment -> modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON .)


state 288

    (23) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 23 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 289

    (25) int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .

    $end            reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LINE_BREAK      reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    PRINT           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IF              reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    WHILE           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FOR             reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    FINAL           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    CONST           reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    INTEGER_TYPE    reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    QUEUE_TYPE      reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    STRING_TYPE     reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    ENUM_TYPE       reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VAR             reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    LIST_TYPE       reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    MAP_TYPE        reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SET_TYPE        reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    VOID            reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    RBRACE          reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)
    SEMICOLON       reduce using rule 25 (int_assignment -> modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON .)


state 290

    (30) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .

    $end            reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LINE_BREAK      reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    PRINT           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IF              reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    WHILE           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FOR             reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    FINAL           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    CONST           reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    INTEGER_TYPE    reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    QUEUE_TYPE      reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    STRING_TYPE     reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    ENUM_TYPE       reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VAR             reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    LIST_TYPE       reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    MAP_TYPE        reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SET_TYPE        reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    VOID            reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    RBRACE          reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)
    SEMICOLON       reduce using rule 30 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON .)


state 291

    (32) string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .

    $end            reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LINE_BREAK      reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    PRINT           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IF              reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    WHILE           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FOR             reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    IDENTIFIER      reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    FINAL           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    CONST           reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    INTEGER_TYPE    reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    QUEUE_TYPE      reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    STRING_TYPE     reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    ENUM_TYPE       reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VAR             reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    LIST_TYPE       reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    MAP_TYPE        reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SET_TYPE        reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    VOID            reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    RBRACE          reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)
    SEMICOLON       reduce using rule 32 (string_assignment -> modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON .)


state 292

    (119) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 300


state 293

    (143) map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .

    $end            reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    PRINT           reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IF              reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    WHILE           reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FOR             reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FINAL           reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    CONST           reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VAR             reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VOID            reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    RBRACE          reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 143 (map_assigment -> IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)


state 294

    (145) map_values -> type COLON type .
    (146) map_values -> type COLON type . COMMA map_values

    RBRACE          reduce using rule 145 (map_values -> type COLON type .)
    COMMA           shift and go to state 301


state 295

    (50) if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .

    ELSE            reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    $end            reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 50 (if_statement -> IF LPAREN logic RPAREN LBRACE lines RBRACE .)


state 296

    (153) while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 153 (while_statement -> WHILE LPAREN logic RPAREN LBRACE lines RBRACE .)


state 297

    (154) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment . RPAREN LBRACE lines RBRACE

    RPAREN          shift and go to state 302


state 298

    (40) reassignment -> IDENTIFIER . ASSIGN expression SEMICOLON
    (41) reassignment -> IDENTIFIER . INLINE_ARITH number SEMICOLON
    (42) reassignment -> IDENTIFIER . INLINE_ARITH SEMICOLON
    (43) reassignment -> IDENTIFIER . INLINE_ARITH number
    (44) reassignment -> IDENTIFIER . INLINE_ARITH

    ASSIGN          shift and go to state 303
    INLINE_ARITH    shift and go to state 89


state 299

    (142) map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .

    $end            reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LINE_BREAK      reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    PRINT           reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IF              reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    WHILE           reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FOR             reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    FINAL           reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    CONST           reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    INTEGER_TYPE    reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    BOOLEAN_TYPE    reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    QUEUE_TYPE      reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    STRING_TYPE     reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    ENUM_TYPE       reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VAR             reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    LIST_TYPE       reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    MAP_TYPE        reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SET_TYPE        reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    DYNAMIC_TYPE    reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    VOID            reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    RBRACE          reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 142 (map_assigment -> map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON .)


state 300

    (119) function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 119 (function -> type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE .)


state 301

    (146) map_values -> type COLON type COMMA . map_values
    (145) map_values -> . type COLON type
    (146) map_values -> . type COLON type COMMA map_values
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID

    INTEGER_TYPE    shift and go to state 176
    DOUBLE_TYPE     shift and go to state 177
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 178
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 179
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 82
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    type                           shift and go to state 242
    map_values                     shift and go to state 304

state 302

    (154) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN . LBRACE lines RBRACE

    LBRACE          shift and go to state 305


state 303

    (40) reassignment -> IDENTIFIER ASSIGN . expression SEMICOLON
    (69) expression -> . arithmetic
    (70) expression -> . concate
    (71) expression -> . logic
    (72) expression -> . function_call
    (73) expression -> . division
    (74) arithmetic -> . number
    (75) arithmetic -> . arithmetic arith_op arithmetic
    (76) arithmetic -> . LPAREN arithmetic arith_op arithmetic RPAREN
    (78) concate -> . string
    (79) concate -> . concate PLUS concate
    (80) concate -> . LPAREN concate PLUS concate RPAREN
    (89) logic -> . comparison
    (90) logic -> . logic logic_op logic
    (91) logic -> . LPAREN logic logic_op logic RPAREN
    (92) logic -> . LOGICAL_NOT logic
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (77) division -> . number DIVIDE number
    (110) number -> . INTEGER
    (111) number -> . DOUBLE
    (112) string -> . STRING
    (81) comparison -> . int_comparison
    (82) comparison -> . string_comparison
    (83) int_comparison -> . boolean
    (84) int_comparison -> . number comp_op number
    (85) int_comparison -> . LPAREN number comp_op number RPAREN
    (86) string_comparison -> . boolean
    (87) string_comparison -> . string comp_op string
    (88) string_comparison -> . LPAREN string comp_op string RPAREN
    (113) boolean -> . TRUE
    (114) boolean -> . FALSE

    LPAREN          shift and go to state 25
    LOGICAL_NOT     shift and go to state 34
    IDENTIFIER      shift and go to state 143
    INTEGER         shift and go to state 52
    DOUBLE          shift and go to state 53
    STRING          shift and go to state 54
    TRUE            shift and go to state 58
    FALSE           shift and go to state 59

    expression                     shift and go to state 144
    arithmetic                     shift and go to state 12
    concate                        shift and go to state 13
    logic                          shift and go to state 14
    function_call                  shift and go to state 147
    division                       shift and go to state 16
    number                         shift and go to state 31
    string                         shift and go to state 32
    comparison                     shift and go to state 33
    int_comparison                 shift and go to state 55
    string_comparison              shift and go to state 56
    boolean                        shift and go to state 57

state 304

    (146) map_values -> type COLON type COMMA map_values .

    RBRACE          reduce using rule 146 (map_values -> type COLON type COMMA map_values .)


state 305

    (154) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE . lines RBRACE
    (120) lines -> . line LINE_BREAK lines
    (121) lines -> . line lines
    (122) lines -> . line
    (123) lines -> . LINE_BREAK
    (124) lines -> .
    (125) line -> . print
    (126) line -> . assignment
    (127) line -> . function
    (128) line -> . if_statement
    (129) line -> . while_statement
    (130) line -> . for_statement
    (131) line -> . function_call
    (132) line -> . reassignment
    (48) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (49) print -> . PRINT LPAREN RPAREN SEMICOLON
    (12) assignment -> . modifier type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (13) assignment -> . type nullable IDENTIFIER ASSIGN expression SEMICOLON
    (14) assignment -> . modifier type IDENTIFIER ASSIGN expression SEMICOLON
    (15) assignment -> . type IDENTIFIER ASSIGN expression SEMICOLON
    (16) assignment -> . type IDENTIFIER ASSIGN expression
    (17) assignment -> . int_assignment
    (18) assignment -> . string_assignment
    (19) assignment -> . list_assigment
    (20) assignment -> . map_assigment
    (119) function -> . type IDENTIFIER LPAREN parameters RPAREN LBRACE lines RBRACE
    (50) if_statement -> . IF LPAREN logic RPAREN LBRACE lines RBRACE
    (51) if_statement -> . if_statement ELSE if_statement
    (52) if_statement -> . if_statement ELSE LBRACE lines RBRACE
    (153) while_statement -> . WHILE LPAREN logic RPAREN LBRACE lines RBRACE
    (154) for_statement -> . FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE
    (53) function_call -> . IDENTIFIER LPAREN values RPAREN SEMICOLON
    (54) function_call -> . IDENTIFIER LPAREN values RPAREN
    (55) function_call -> . IDENTIFIER LPAREN RPAREN SEMICOLON
    (56) function_call -> . IDENTIFIER LPAREN RPAREN
    (40) reassignment -> . IDENTIFIER ASSIGN expression SEMICOLON
    (41) reassignment -> . IDENTIFIER INLINE_ARITH number SEMICOLON
    (42) reassignment -> . IDENTIFIER INLINE_ARITH SEMICOLON
    (43) reassignment -> . IDENTIFIER INLINE_ARITH number
    (44) reassignment -> . IDENTIFIER INLINE_ARITH
    (46) modifier -> . FINAL
    (47) modifier -> . CONST
    (57) type -> . INTEGER_TYPE
    (58) type -> . DOUBLE_TYPE
    (59) type -> . BOOLEAN_TYPE
    (60) type -> . QUEUE_TYPE
    (61) type -> . STRING_TYPE
    (62) type -> . ENUM_TYPE
    (63) type -> . VAR
    (64) type -> . LIST_TYPE
    (65) type -> . MAP_TYPE
    (66) type -> . SET_TYPE
    (67) type -> . DYNAMIC_TYPE
    (68) type -> . VOID
    (21) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (22) int_assignment -> . number_type IDENTIFIER ASSIGN arithmetic
    (23) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (24) int_assignment -> . number_type nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (25) int_assignment -> . modifier number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (26) int_assignment -> . number_type nullable IDENTIFIER ASSIGN arithmetic SEMICOLON
    (27) int_assignment -> . modifier number_type IDENTIFIER ASSIGN arithmetic SEMICOLON
    (28) string_assignment -> . type_string IDENTIFIER ASSIGN concate SEMICOLON
    (29) string_assignment -> . type_string IDENTIFIER ASSIGN concate
    (30) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (31) string_assignment -> . type_string nullable IDENTIFIER ASSIGN NULL SEMICOLON
    (32) string_assignment -> . modifier type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (33) string_assignment -> . type_string nullable IDENTIFIER ASSIGN concate SEMICOLON
    (34) string_assignment -> . modifier type_string IDENTIFIER ASSIGN concate SEMICOLON
    (117) list_assigment -> . IDENTIFIER ASSIGN list SEMICOLON
    (118) list_assigment -> . type ASSIGN list SEMICOLON
    (141) map_assigment -> . map IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (142) map_assigment -> . map IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (143) map_assigment -> . IDENTIFIER IDENTIFIER ASSIGN LBRACE map_values RBRACE SEMICOLON
    (144) map_assigment -> . IDENTIFIER ASSIGN LBRACE RBRACE SEMICOLON
    (35) number_type -> . INTEGER_TYPE
    (36) number_type -> . VAR
    (37) number_type -> . DOUBLE_TYPE
    (38) type_string -> . STRING_TYPE
    (39) type_string -> . VAR
    (139) map -> . MAP_TYPE LESS type COMMA type GREATER
    (140) map -> . MAP_TYPE

    LINE_BREAK      shift and go to state 30
    RBRACE          reduce using rule 124 (lines -> .)
    PRINT           shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IDENTIFIER      shift and go to state 70
    FINAL           shift and go to state 35
    CONST           shift and go to state 36
    INTEGER_TYPE    shift and go to state 37
    DOUBLE_TYPE     shift and go to state 38
    BOOLEAN_TYPE    shift and go to state 39
    QUEUE_TYPE      shift and go to state 40
    STRING_TYPE     shift and go to state 41
    ENUM_TYPE       shift and go to state 42
    VAR             shift and go to state 43
    LIST_TYPE       shift and go to state 44
    MAP_TYPE        shift and go to state 45
    SET_TYPE        shift and go to state 46
    DYNAMIC_TYPE    shift and go to state 47
    VOID            shift and go to state 48

    assignment                     shift and go to state 63
    reassignment                   shift and go to state 69
    lines                          shift and go to state 306
    line                           shift and go to state 29
    print                          shift and go to state 62
    function                       shift and go to state 64
    if_statement                   shift and go to state 65
    while_statement                shift and go to state 66
    for_statement                  shift and go to state 67
    function_call                  shift and go to state 68
    modifier                       shift and go to state 17
    type                           shift and go to state 18
    int_assignment                 shift and go to state 20
    string_assignment              shift and go to state 21
    list_assigment                 shift and go to state 22
    map_assigment                  shift and go to state 23
    number_type                    shift and go to state 49
    type_string                    shift and go to state 50
    map                            shift and go to state 51

state 306

    (154) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines . RBRACE

    RBRACE          shift and go to state 307


state 307

    (154) for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .

    $end            reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LINE_BREAK      reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    PRINT           reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IF              reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    WHILE           reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FOR             reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    IDENTIFIER      reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    FINAL           reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    CONST           reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    INTEGER_TYPE    reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DOUBLE_TYPE     reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    BOOLEAN_TYPE    reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    QUEUE_TYPE      reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    STRING_TYPE     reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    ENUM_TYPE       reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VAR             reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    LIST_TYPE       reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    MAP_TYPE        reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    SET_TYPE        reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    DYNAMIC_TYPE    reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    VOID            reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)
    RBRACE          reduce using rule 154 (for_statement -> FOR LPAREN assignment SEMICOLON logic SEMICOLON reassignment RPAREN LBRACE lines RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGICAL_AND in state 111 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 111 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 124 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 124 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 124 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 130 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 130 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 152 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 193 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 207 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 212 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 212 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 212 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 213 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 214 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 214 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 223 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 225 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (statement -> <empty>)
WARNING: rejected rule (lines -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement -> assignment)
WARNING: rejected rule (line -> assignment) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement -> print)
WARNING: rejected rule (line -> print) in state 4
WARNING: reduce/reduce conflict in state 5 resolved using rule (statement -> function)
WARNING: rejected rule (line -> function) in state 5
WARNING: reduce/reduce conflict in state 6 resolved using rule (statement -> if_statement)
WARNING: rejected rule (line -> if_statement) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (statement -> while_statement)
WARNING: rejected rule (line -> while_statement) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (statement -> for_statement)
WARNING: rejected rule (line -> for_statement) in state 8
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> reassignment)
WARNING: rejected rule (line -> reassignment) in state 11
WARNING: reduce/reduce conflict in state 15 resolved using rule (expression -> function_call)
WARNING: rejected rule (line -> function_call) in state 15
WARNING: reduce/reduce conflict in state 29 resolved using rule (lines -> line)
WARNING: rejected rule (lines -> <empty>) in state 29
WARNING: reduce/reduce conflict in state 37 resolved using rule (number_type -> INTEGER_TYPE)
WARNING: rejected rule (type -> INTEGER_TYPE) in state 37
WARNING: reduce/reduce conflict in state 38 resolved using rule (number_type -> DOUBLE_TYPE)
WARNING: rejected rule (type -> DOUBLE_TYPE) in state 38
WARNING: reduce/reduce conflict in state 41 resolved using rule (type_string -> STRING_TYPE)
WARNING: rejected rule (type -> STRING_TYPE) in state 41
WARNING: reduce/reduce conflict in state 43 resolved using rule (number_type -> VAR)
WARNING: rejected rule (type -> VAR) in state 43
WARNING: reduce/reduce conflict in state 43 resolved using rule (number_type -> VAR)
WARNING: rejected rule (type_string -> VAR) in state 43
WARNING: reduce/reduce conflict in state 45 resolved using rule (type -> MAP_TYPE)
WARNING: rejected rule (map -> MAP_TYPE) in state 45
WARNING: reduce/reduce conflict in state 57 resolved using rule (int_comparison -> boolean)
WARNING: rejected rule (string_comparison -> boolean) in state 57
WARNING: reduce/reduce conflict in state 100 resolved using rule (lines -> LINE_BREAK)
WARNING: rejected rule (lines -> <empty>) in state 100
WARNING: Rule (type_string -> VAR) is never reduced
WARNING: Rule (map -> MAP_TYPE) is never reduced
WARNING: Rule (string_comparison -> boolean) is never reduced
